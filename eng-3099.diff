diff --git a/.gitignore b/.gitignore
index a27241b..defeaaa 100644
--- a/.gitignore
+++ b/.gitignore
@@ -203,6 +203,7 @@ dist
 
 # Cover.profile
 *.profile
+*.profile.*
 benthos-umh
 benthos
 
diff --git a/ENG-3099-Implementation-Plan.md b/ENG-3099-Implementation-Plan.md
new file mode 100644
index 0000000..e718b21
--- /dev/null
+++ b/ENG-3099-Implementation-Plan.md
@@ -0,0 +1,1248 @@
+# ENG-3099 Implementation Plan: Schema Registry Integration for uns_output Plugin
+
+## Overview
+
+This document outlines the implementation plan for integrating JSON schema validation into the `uns_output` plugin using Redpanda's Schema Registry. The enhancement ensures that only messages conforming to registered JSON schemas are published to the UNS, improving data integrity while maintaining the existing fail-open philosophy.
+
+## Objectives
+
+- **Primary**: Validate message payloads against JSON schemas before publishing to `umh.messages`
+- **Secondary**: Support versioned data contracts (`_contract`, `_contractv1`, `_contractv34`)
+- **Tertiary**: Maintain fail-open behavior to prevent data loss on schema registry issues
+- **Performance**: Minimize impact on throughput through efficient caching
+
+## Architecture Overview
+
+```
+Message → Extract data_contract → Parse version → Extract tag_name → Cache lookup → Dual validation → Kafka publish
+             ↓                                        ↓                    ↓              ↓
+        (from metadata)                        (from UNS topic)     Schema Registry   1. Tag allowed?
+                                                                   (if not cached)    2. Payload valid?
+```
+
+## Schema Structure
+
+Our schemas support **dual validation** with both allowed tag names and tag-specific payload schemas:
+
+```json
+{
+   "virtual_path": [
+      "count",
+      "vibration.x-axis", 
+      "vibration.y-axis",
+      "acceleration.x",
+      "serialNumber"
+   ],
+   "fields": {
+      "count": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "vibration.x-axis": {
+         "type": "object", 
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "vibration.y-axis": {
+         "type": "object", 
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "acceleration.x": {
+         "type": "object", 
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "serialNumber": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"}, 
+            "value": {"type": "string"}
+         },
+         "required": ["timestamp_ms", "value"]
+      }
+   }
+}
+```
+
+## Design Decision: Configuration Strategy
+
+### Ticket Requirements vs Implementation Plan
+
+**Original Ticket (ENG-3099) stated:**
+> "The plugin configuration (uns: {}) doesn't need new YAML fields for this feature, since it's an internal behavior."
+
+**Initial Plan proposed:**
+> Adding a required `schema_registry_url` configuration field
+
+**Resolution: Optional Configuration with Auto-derivation**
+
+We chose **Option 2** to balance ticket requirements with practical deployment needs:
+
+**✅ Pros of Our Approach:**
+- **Ticket Compliance**: Works without any configuration changes (auto-derivation)
+- **Smart Defaults**: Automatically derives `http://localhost:8081` from `localhost:9092`
+- **Deployment Flexibility**: Supports non-standard registry URLs when needed
+- **Backward Compatibility**: All existing configurations work unchanged
+- **Explicit Control**: Allows disabling validation by setting empty string
+
+**❌ Rejected Alternatives:**
+- **Option 1 (Auto-derive only)**: Too rigid for complex deployments
+- **Required Configuration**: Would break existing configurations
+- **Environment Variables**: Adds deployment complexity
+
+**Implementation Impact:**
+- Zero breaking changes to existing configurations
+- Logging shows auto-derived URLs for transparency
+- Explicit configuration overrides auto-derivation when needed
+
+## Implementation Details
+
+### 1. Configuration Changes
+
+**File**: `uns_plugin/uns_output.go`
+
+#### 1.1 Configuration Strategy Decision
+
+We implement **Option 2: Optional Configuration with Auto-derivation** to align with the ENG-3099 ticket requirements while maintaining flexibility:
+
+**Reasoning:**
+- **Ticket Alignment**: The original ticket states "The plugin configuration (uns: {}) doesn't need new YAML fields for this feature, since it's an internal behavior"
+- **Smart Defaults**: Auto-derive schema registry URL from broker address (localhost:9092 → http://localhost:8081)
+- **Flexibility**: Allow explicit configuration for non-standard deployments
+- **Backward Compatible**: Existing configurations work unchanged
+- **Future-proof**: Handles various deployment scenarios gracefully
+
+#### 1.2 Update Configuration Struct
+
+```go
+// Update unsOutputConfig struct
+type unsOutputConfig struct {
+	umh_topic           *service.InterpolatedString
+	brokerAddress       string
+	bridgedBy           string
+	schemaRegistryURL   string  // NEW: Schema Registry URL (auto-derived or explicit)
+}
+```
+
+#### 1.3 Add Configuration Field (Optional)
+
+```go
+// In outputConfig() function, add new OPTIONAL field
+Field(service.NewStringField("schema_registry_url").
+	Description(`
+Optional Schema Registry URL for JSON schema validation. If not specified,
+the URL will be auto-derived from the broker_address (e.g., localhost:9092 
+becomes http://localhost:8081).
+
+Set this explicitly for non-standard deployments or to disable validation 
+entirely by setting to an empty string.
+`).
+	Example("http://localhost:8081").
+	Optional())
+```
+
+#### 1.4 Auto-derivation Helper Function
+
+```go
+import (
+	// ... existing imports ...
+	"strings"
+)
+
+// deriveSchemaRegistryURL automatically derives registry URL from broker address
+func deriveSchemaRegistryURL(brokerAddress string) string {
+	if brokerAddress == "" {
+		return "http://localhost:8081" // fallback default
+	}
+	
+	// Extract host from broker address (e.g., "localhost:9092" -> "localhost")
+	if strings.Contains(brokerAddress, ":") {
+		host := strings.Split(brokerAddress, ":")[0]
+		return fmt.Sprintf("http://%s:8081", host)
+	}
+	
+	// If no port specified, assume it's just the host
+	return fmt.Sprintf("http://%s:8081", brokerAddress)
+}
+```
+
+#### 1.5 Update Constructor
+
+```go
+// In newUnsOutput function, implement optional config with auto-derivation
+var schemaRegistryURL string
+if conf.Contains("schema_registry_url") {
+	// Explicit configuration provided
+	url, err := conf.FieldString("schema_registry_url")
+	if err != nil {
+		return nil, batchPolicy, 0, fmt.Errorf("error while parsing schema_registry_url field from the config: %v", err)
+	}
+	schemaRegistryURL = url
+} else {
+	// Auto-derive from broker address
+	schemaRegistryURL = deriveSchemaRegistryURL(config.brokerAddress)
+	mgr.Logger().Infof("Auto-derived schema registry URL: %s (from broker: %s)", 
+		schemaRegistryURL, config.brokerAddress)
+}
+
+config := unsOutputConfig{
+	// ... existing fields ...
+	schemaRegistryURL: schemaRegistryURL,
+}
+
+// Create schema cache if registry URL is provided and not explicitly disabled
+var schemaCache *SchemaCache
+if schemaRegistryURL != "" {
+	schemaCache = NewSchemaCache(schemaRegistryURL, mgr.Logger())
+}
+
+return newUnsOutputWithClient(NewClient(), config, schemaCache, mgr.Logger()), batchPolicy, maxInFlight, nil
+```
+
+### 2. Contract Version Parser
+
+**File**: `uns_plugin/contract_parser.go` (NEW)
+
+```go
+package uns_plugin
+
+import (
+	"regexp"
+	"strconv"
+)
+
+// ContractInfo holds parsed contract information
+type ContractInfo struct {
+	BaseContract string // e.g., "_pump_data" 
+	Version      *int   // nil for latest, specific number for versioned
+	FullName     string // original contract name
+}
+
+var contractVersionRegex = regexp.MustCompile(`^(.+?)v(\d+)$`)
+
+// ParseContract parses a data contract to extract base name and version
+func ParseContract(contract string) ContractInfo {
+	if contract == "" {
+		return ContractInfo{}
+	}
+
+	// Check if contract has version suffix (e.g., "_pump_datav1", "_pump_datav34")
+	matches := contractVersionRegex.FindStringSubmatch(contract)
+	if len(matches) == 3 {
+		baseContract := matches[1]
+		if version, err := strconv.Atoi(matches[2]); err == nil {
+			return ContractInfo{
+				BaseContract: baseContract,
+				Version:      &version,
+				FullName:     contract,
+			}
+		}
+	}
+
+	// No version suffix, assume latest
+	return ContractInfo{
+		BaseContract: contract,
+		Version:      nil, // latest
+		FullName:     contract,
+	}
+}
+
+// CacheKey returns a unique cache key for this contract version
+func (ci ContractInfo) CacheKey() string {
+	if ci.Version == nil {
+		return ci.BaseContract + ":latest"
+	}
+	return ci.BaseContract + ":v" + strconv.Itoa(*ci.Version)
+}
+
+// RegistrySubject returns the subject name for schema registry
+func (ci ContractInfo) RegistrySubject() string {
+	return ci.BaseContract
+}
+```
+
+### 3. Schema Registry Client
+
+**File**: `uns_plugin/schema_registry_client.go` (NEW)
+
+```go
+package uns_plugin
+
+import (
+	"encoding/json"
+	"fmt"
+	"io"
+	"net/http"
+	"time"
+)
+
+// SchemaRegistryClient handles communication with Redpanda Schema Registry
+type SchemaRegistryClient struct {
+	baseURL    string
+	httpClient *http.Client
+}
+
+// SchemaResponse represents the response from schema registry
+type SchemaResponse struct {
+	ID      int    `json:"id"`
+	Version int    `json:"version"`
+	Schema  string `json:"schema"`
+}
+
+// NewSchemaRegistryClient creates a new schema registry client
+func NewSchemaRegistryClient(baseURL string) *SchemaRegistryClient {
+	return &SchemaRegistryClient{
+		baseURL: baseURL,
+		httpClient: &http.Client{
+			Timeout: 10 * time.Second,
+		},
+	}
+}
+
+// GetSchemaForContract retrieves schema for a contract (latest or specific version)
+func (c *SchemaRegistryClient) GetSchemaForContract(contractInfo ContractInfo) (*SchemaResponse, error) {
+	var url string
+	if contractInfo.Version == nil {
+		// Get latest version
+		url = fmt.Sprintf("%s/subjects/%s/versions/latest", c.baseURL, contractInfo.RegistrySubject())
+	} else {
+		// Get specific version
+		url = fmt.Sprintf("%s/subjects/%s/versions/%d", c.baseURL, contractInfo.RegistrySubject(), *contractInfo.Version)
+	}
+	
+	resp, err := c.httpClient.Get(url)
+	if err != nil {
+		return nil, fmt.Errorf("failed to fetch schema for contract %s: %w", contractInfo.FullName, err)
+	}
+	defer resp.Body.Close()
+
+	if resp.StatusCode == 404 {
+		// No schema registered for this contract/version
+		return nil, nil
+	}
+
+	if resp.StatusCode != 200 {
+		return nil, fmt.Errorf("schema registry returned status %d for contract %s", resp.StatusCode, contractInfo.FullName)
+	}
+
+	body, err := io.ReadAll(resp.Body)
+	if err != nil {
+		return nil, fmt.Errorf("failed to read response body: %w", err)
+	}
+
+	var schemaResp SchemaResponse
+	if err := json.Unmarshal(body, &schemaResp); err != nil {
+		return nil, fmt.Errorf("failed to unmarshal schema response: %w", err)
+	}
+
+	return &schemaResp, nil
+}
+
+// GetLatestSchema - kept for backward compatibility, delegates to GetSchemaForContract
+func (c *SchemaRegistryClient) GetLatestSchema(contract string) (*SchemaResponse, error) {
+	contractInfo := ParseContract(contract)
+	return c.GetSchemaForContract(contractInfo)
+}
+```
+
+### 4. UMH Topic Parser
+
+**File**: `uns_plugin/uns_topic_parser.go` (NEW)
+
+```go
+package uns_plugin
+
+import (
+	"fmt"
+	"strings"
+)
+
+// extractTagNameFromUNSTopic extracts the tag name (last part) from a UNS topic
+// Example: "umh.v1.enterprise.site.area._pump_data.vibration.x-axis" -> "vibration.x-axis"
+func extractTagNameFromUNSTopic(unsTopic string) (string, error) {
+	if unsTopic == "" {
+		return "", fmt.Errorf("UNS topic is empty")
+	}
+
+	// Split by dots and get the last part
+	parts := strings.Split(unsTopic, ".")
+	if len(parts) < 2 {
+		return "", fmt.Errorf("invalid UNS topic format: %s", unsTopic)
+	}
+
+	tagName := parts[len(parts)-1]
+	if tagName == "" {
+		return "", fmt.Errorf("tag name is empty in UNS topic: %s", unsTopic)
+	}
+
+	return tagName, nil
+}
+```
+
+### 5. Schema Validator Implementation
+
+**File**: `uns_plugin/schema_validator.go` (NEW)
+
+```go
+package uns_plugin
+
+import (
+	"context"
+	"encoding/json"
+	"fmt"
+	"sync"
+	"time"
+
+	"github.com/kaptinlin/jsonschema"
+	"github.com/redpanda-data/benthos/v4/public/service"
+)
+
+// ContractSchema represents the dual validation schema structure
+type ContractSchema struct {
+	VirtualPath []string                   `json:"virtual_path"` // Allowed tag names
+	Fields      map[string]json.RawMessage `json:"fields"`       // Tag-specific JSON schemas
+}
+
+// SchemaValidator interface for dual validation (tag name + payload)
+type SchemaValidator interface {
+	ValidateTagAndPayload(tagName string, payload []byte) error
+}
+
+// CompiledContractSchema wraps a compiled contract schema for dual validation
+type CompiledContractSchema struct {
+	contractName    string
+	allowedNames    map[string]bool                // Fast lookup for allowed tag names
+	compiledSchemas map[string]*jsonschema.Schema  // Compiled JSON schemas per tag
+}
+
+// NewCompiledContractSchema creates a new compiled contract schema
+func NewCompiledContractSchema(contractName string, schemaJSON []byte) (*CompiledContractSchema, error) {
+	var contractSchema ContractSchema
+	if err := json.Unmarshal(schemaJSON, &contractSchema); err != nil {
+		return nil, fmt.Errorf("failed to parse contract schema: %w", err)
+	}
+
+	// Build allowed names lookup map
+	allowedNames := make(map[string]bool)
+	for _, name := range contractSchema.VirtualPath {
+		allowedNames[name] = true
+	}
+
+	// Compile JSON schemas for each field
+	compiler := jsonschema.NewCompiler()
+	compiledSchemas := make(map[string]*jsonschema.Schema)
+	
+	for tagName, fieldSchemaBytes := range contractSchema.Fields {
+		schema, err := compiler.Compile(fieldSchemaBytes)
+		if err != nil {
+			return nil, fmt.Errorf("failed to compile schema for tag '%s': %w", tagName, err)
+		}
+		compiledSchemas[tagName] = schema
+	}
+
+	return &CompiledContractSchema{
+		contractName:    contractName,
+		allowedNames:    allowedNames,
+		compiledSchemas: compiledSchemas,
+	}, nil
+}
+
+// ValidateTagAndPayload performs dual validation: tag name + payload
+func (c *CompiledContractSchema) ValidateTagAndPayload(tagName string, payload []byte) error {
+	// Step 1: Validate tag name is allowed
+	if !c.allowedNames[tagName] {
+		allowedList := make([]string, 0, len(c.allowedNames))
+		for name := range c.allowedNames {
+			allowedList = append(allowedList, name)
+		}
+		return fmt.Errorf("tag '%s' not allowed for contract '%s'. Allowed tags: %v", 
+			tagName, c.contractName, allowedList)
+	}
+
+	// Step 2: Validate payload against tag-specific schema
+	schema, exists := c.compiledSchemas[tagName]
+	if !exists {
+		return fmt.Errorf("no schema defined for tag '%s' in contract '%s'", tagName, c.contractName)
+	}
+
+	result := schema.ValidateJSON(payload)
+	if !result.IsValid() {
+		// Create detailed error message from validation result
+		var errorMsg string
+		for field, err := range result.Errors {
+			if errorMsg != "" {
+				errorMsg += "; "
+			}
+			errorMsg += fmt.Sprintf("%s: %s", field, err.Message)
+		}
+		return fmt.Errorf("payload validation failed for tag '%s': %s", tagName, errorMsg)
+	}
+
+	return nil
+}
+
+// SchemaCache manages schema retrieval and caching with version support
+type SchemaCache struct {
+	cache            map[string]SchemaValidator // cache key -> validator
+	lastFetch        map[string]time.Time       // cache key -> last fetch time
+	registryURL      string
+	refreshInterval  time.Duration
+	mutex            sync.RWMutex
+	log              *service.Logger
+}
+
+// NewSchemaCache creates a new schema cache
+func NewSchemaCache(registryURL string, logger *service.Logger) *SchemaCache {
+	return &SchemaCache{
+		cache:           make(map[string]SchemaValidator),
+		lastFetch:       make(map[string]time.Time),
+		registryURL:     registryURL,
+		refreshInterval: 10 * time.Minute, // Configurable refresh interval
+		log:             logger,
+	}
+}
+
+// GetValidator retrieves or fetches a validator for the given contract
+func (sc *SchemaCache) GetValidator(ctx context.Context, contractName string) (SchemaValidator, error) {
+	if contractName == "" {
+		return nil, nil // No validation for empty contract
+	}
+
+	contractInfo := ParseContract(contractName)
+	cacheKey := contractInfo.CacheKey()
+
+	sc.mutex.RLock()
+	validator, exists := sc.cache[cacheKey]
+	lastFetch := sc.lastFetch[cacheKey]
+	sc.mutex.RUnlock()
+
+	// For versioned contracts, don't refresh (they're immutable)
+	// For latest contracts, refresh periodically
+	needsRefresh := !exists
+	if contractInfo.Version == nil && exists {
+		// Only refresh "latest" versions periodically
+		needsRefresh = time.Since(lastFetch) > sc.refreshInterval
+	}
+
+	if needsRefresh {
+		return sc.fetchAndCacheSchema(ctx, contractInfo)
+	}
+
+	return validator, nil
+}
+
+// fetchAndCacheSchema fetches schema from registry and caches it
+func (sc *SchemaCache) fetchAndCacheSchema(ctx context.Context, contractInfo ContractInfo) (SchemaValidator, error) {
+	cacheKey := contractInfo.CacheKey()
+	
+	sc.mutex.Lock()
+	defer sc.mutex.Unlock()
+
+	// Double-check pattern - another goroutine might have fetched it
+	if validator, exists := sc.cache[cacheKey]; exists {
+		// For versioned contracts, never refresh
+		if contractInfo.Version != nil {
+			return validator, nil
+		}
+		// For latest, check if we need refresh
+		if time.Since(sc.lastFetch[cacheKey]) <= sc.refreshInterval {
+			return validator, nil
+		}
+	}
+
+	client := NewSchemaRegistryClient(sc.registryURL)
+	schemaResp, err := client.GetSchemaForContract(contractInfo)
+	if err != nil {
+		sc.log.Errorf("Failed to fetch schema for contract %s: %v", contractInfo.FullName, err)
+		// Return nil validator but don't error - fail open
+		sc.cache[cacheKey] = nil
+		sc.lastFetch[cacheKey] = time.Now()
+		return nil, nil
+	}
+
+	if schemaResp == nil {
+		// No schema registered
+		sc.log.Infof("No schema registered for contract '%s'; skipping validation", contractInfo.FullName)
+		sc.cache[cacheKey] = nil
+		sc.lastFetch[cacheKey] = time.Now()
+		return nil, nil
+	}
+
+	// Compile the contract schema (dual validation schema)
+	validator, err := NewCompiledContractSchema(contractInfo.FullName, []byte(schemaResp.Schema))
+	if err != nil {
+		sc.log.Errorf("Failed to compile contract schema for %s: %v", contractInfo.FullName, err)
+		// Fail open - cache nil validator
+		sc.cache[cacheKey] = nil
+		sc.lastFetch[cacheKey] = time.Now()
+		return nil, nil
+	}
+
+	sc.cache[cacheKey] = validator
+	sc.lastFetch[cacheKey] = time.Now()
+
+	versionInfo := "latest"
+	if contractInfo.Version != nil {
+		versionInfo = fmt.Sprintf("v%d", *contractInfo.Version)
+	}
+	sc.log.Infof("Loaded dual validation schema for contract '%s' (%s, registry version %d)", 
+		contractInfo.FullName, versionInfo, schemaResp.Version)
+	return validator, nil
+}
+
+// RefreshOnValidationFailure attempts to refresh schema when validation fails unexpectedly
+// Only works for "latest" version contracts - versioned contracts are immutable
+func (sc *SchemaCache) RefreshOnValidationFailure(ctx context.Context, contractName string) (SchemaValidator, error) {
+	contractInfo := ParseContract(contractName)
+	
+	// Don't refresh versioned contracts - they're immutable
+	if contractInfo.Version != nil {
+		return nil, fmt.Errorf("cannot refresh versioned contract %s", contractInfo.FullName)
+	}
+
+	cacheKey := contractInfo.CacheKey()
+	sc.mutex.Lock()
+	lastFetch := sc.lastFetch[cacheKey]
+	sc.mutex.Unlock()
+
+	// Rate limit: only refresh if it's been at least 1 minute since last fetch
+	if time.Since(lastFetch) < time.Minute {
+		return nil, fmt.Errorf("rate limited: schema refresh attempted too recently")
+	}
+
+	sc.log.Infof("Attempting schema refresh for contract %s due to validation failure", contractInfo.FullName)
+	return sc.fetchAndCacheSchema(ctx, contractInfo)
+}
+```
+
+### 6. uns_output Integration
+
+**File**: `uns_plugin/uns_output.go` (MODIFIED)
+
+#### 6.1 Update Validation Helper Function
+
+```go
+// validateMessage performs dual validation (tag name + payload) for a single message
+func (o *unsOutput) validateMessage(ctx context.Context, msg *service.Message, msgBytes []byte, msgIndex int) error {
+	// Get data contract from message metadata
+	contract := msg.MetaGet("data_contract")
+	if contract == "" {
+		o.log.Debugf("No data_contract metadata found for message %d, skipping validation", msgIndex)
+		return nil
+	}
+
+	// Get UNS topic and extract tag name
+	unsTopicKey, err := o.config.umh_topic.TryString(msg)
+	if err != nil {
+		return fmt.Errorf("failed to get UNS topic for message %d: %v", msgIndex, err)
+	}
+
+	tagName, err := extractTagNameFromUNSTopic(unsTopicKey)
+	if err != nil {
+		return fmt.Errorf("failed to extract tag name from UNS topic '%s' for message %d: %v", unsTopicKey, msgIndex, err)
+	}
+
+	// Parse contract to understand version requirements
+	contractInfo := ParseContract(contract)
+	if contractInfo.BaseContract == "" {
+		o.log.Debugf("Could not parse contract '%s' for message %d, skipping validation", contract, msgIndex)
+		return nil
+	}
+
+	// Get validator for this contract (including version)
+	validator, err := o.schemaCache.GetValidator(ctx, contract)
+	if err != nil {
+		o.log.Errorf("Failed to get validator for contract %s: %v", contract, err)
+		// Fail open - don't block the message
+		return nil
+	}
+
+	if validator == nil {
+		// No schema registered for this contract/version - skip validation
+		return nil
+	}
+
+	// Perform dual validation (tag name + payload)
+	if err := validator.ValidateTagAndPayload(tagName, msgBytes); err != nil {
+		// For versioned contracts, don't attempt refresh (they're immutable)
+		if contractInfo.Version == nil {
+			// Try schema refresh only for "latest" version contracts
+			if refreshedValidator, refreshErr := o.schemaCache.RefreshOnValidationFailure(ctx, contract); refreshErr == nil && refreshedValidator != nil {
+				// Retry validation with refreshed schema
+				if retryErr := refreshedValidator.ValidateTagAndPayload(tagName, msgBytes); retryErr == nil {
+					o.log.Infof("Message %d passed dual validation after schema refresh for contract %s", msgIndex, contract)
+					return nil
+				}
+			}
+		}
+
+		// Log validation failure with detailed information
+		truncatedPayload := string(msgBytes)
+		if len(truncatedPayload) > 200 {
+			truncatedPayload = truncatedPayload[:200] + "..."
+		}
+		
+		versionInfo := "latest"
+		if contractInfo.Version != nil {
+			versionInfo = fmt.Sprintf("v%d", *contractInfo.Version)
+		}
+		
+		return fmt.Errorf("dual validation failed for contract %s (%s), tag '%s' - %v. Payload: %s", 
+			contractInfo.BaseContract, versionInfo, tagName, err, truncatedPayload)
+	}
+
+	o.log.Tracef("Message %d passed dual validation: contract=%s, tag=%s", msgIndex, contract, tagName)
+	return nil
+}
+```
+
+#### 6.2 Example Validation Scenarios
+
+**Valid Message:**
+- UNS Topic: `umh.v1.enterprise.site.area._pump_data.vibration.x-axis`  
+- Tag Name: `vibration.x-axis` (extracted from topic)
+- Contract: `_pump_data` (from metadata)
+- Validation: Check if `vibration.x-axis` is in allowed names + validate payload against vibration.x-axis schema
+
+**Invalid Tag Name:**
+- UNS Topic: `umh.v1.enterprise.site.area._pump_data.unknown_sensor`
+- Tag Name: `unknown_sensor` 
+- Contract: `_pump_data`
+- Result: Rejected - "tag 'unknown_sensor' not allowed for contract '_pump_data'. Allowed tags: [count, vibration.x-axis, vibration.y-axis, acceleration.x, serialNumber]"
+
+**Invalid Payload:**
+- UNS Topic: `umh.v1.enterprise.site.area._pump_data.count`
+- Tag Name: `count`
+- Payload: `{"value": "not_a_number", "timestamp_ms": 1680000000000}`
+- Result: Rejected - "payload validation failed for tag 'count': value: expected number, got string"
+
+## Testing Strategy
+
+Implementation includes comprehensive test coverage for **dual validation** (tag name + payload) with unit tests, integration tests, and performance benchmarks.
+
+### Key Test Scenarios
+
+#### 1. UNS Topic Parsing Tests
+```go
+// Test tag name extraction from various UNS topic formats
+testCases := []struct {
+    unsTopic string
+    expected string
+    shouldErr bool
+}{
+    {"umh.v1.enterprise.site.area._pump_data.count", "count", false},
+    {"umh.v1.site._pump_data.vibration.x-axis", "vibration.x-axis", false},
+    {"umh.v1._pump_data.serialNumber", "serialNumber", false},
+    {"invalid.topic", "", true},
+    {"", "", true},
+}
+```
+
+#### 2. Dual Validation Tests
+```go
+// Test both tag name validation and payload validation
+func TestDualValidation(t *testing.T) {
+    schema := ContractSchema{
+        VirtualPath: []string{"count", "vibration.x-axis", "vibration.y-axis", "serialNumber"},
+        Fields: map[string]json.RawMessage{
+            "count": []byte(`{"type":"object","properties":{"value":{"type":"number"},"timestamp_ms":{"type":"number"}},"required":["value","timestamp_ms"]}`),
+            "vibration.x-axis": []byte(`{"type":"object","properties":{"value":{"type":"number"},"timestamp_ms":{"type":"number"}},"required":["value","timestamp_ms"]}`),
+            "serialNumber": []byte(`{"type":"object","properties":{"value":{"type":"string"},"timestamp_ms":{"type":"number"}},"required":["value","timestamp_ms"]}`),
+            // ... other field schemas
+        },
+    }
+    
+    // Test valid tag + valid payload
+    // Test valid tag + invalid payload  
+    // Test invalid tag + valid payload
+    // Test invalid tag + invalid payload
+}
+```
+
+#### 3. Schema Evolution with Versioned Contracts
+```go
+// Test version-specific validation
+func TestVersionedContractValidation(t *testing.T) {
+    // Test _pump_datav1 vs _pump_data (latest) schemas
+    // Ensure versioned schemas don't refresh
+    // Test different tag name sets per version
+}
+```
+
+#### 4. Integration Test Examples
+
+**Test Case: Tag Not Allowed**
+- Schema: `{"virtual_path": ["count", "vibration.x-axis", "vibration.y-axis"], "fields": {...}}`
+- UNS Topic: `umh.v1.site._pump_data.pressure`
+- Expected: Message dropped with "tag 'pressure' not allowed" error
+
+**Test Case: Payload Schema Mismatch**
+- Schema: Count field expects `{"value": number, "timestamp_ms": number}`
+- Payload: `{"value": "string", "timestamp_ms": 123}`
+- Expected: Message dropped with "payload validation failed for tag 'count': value: expected number, got string"
+
+**Test Case: Both Validations Pass**
+- UNS Topic: `umh.v1.site._pump_data.count`
+- Payload: `{"value": 12.5, "timestamp_ms": 1680000000000}`
+- Expected: Message published successfully
+
+## Configuration Examples
+
+#### Auto-derived Configuration (Default - Recommended)
+
+```yaml
+output:
+  uns:
+    broker_address: "localhost:9092"
+    # schema_registry_url not specified - auto-derived to http://localhost:8081
+```
+
+#### Explicit Configuration
+
+```yaml
+output:
+  uns:
+    schema_registry_url: "http://schema-registry.example.com:8081"
+    broker_address: "kafka.example.com:9092"
+```
+
+#### Disabled Configuration
+
+```yaml
+output:
+  uns:
+    schema_registry_url: ""  # explicitly empty to disable validation
+    broker_address: "localhost:9092"
+```
+
+#### Auto-derivation Examples
+
+| Broker Address | Auto-derived Schema Registry URL |
+|---|---|
+| `localhost:9092` | `http://localhost:8081` |
+| `kafka.example.com:9092` | `http://kafka.example.com:8081` |
+| `redpanda` | `http://redpanda:8081` |
+| `` (empty) | `http://localhost:8081` (fallback) |
+
+## Metrics Implementation
+
+### 7. Schema Validation Metrics
+
+**File**: `uns_plugin/uns_output_metrics.go` (NEW)
+
+Following the established patterns from `uns_input_metrics.go`, we'll implement comprehensive metrics tracking for schema validation:
+
+```go
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package uns_plugin
+
+import (
+	"time"
+
+	"github.com/redpanda-data/benthos/v4/public/service"
+)
+
+// UnsOutputMetrics provides metrics collection for the UNS output plugin schema validation
+type UnsOutputMetrics struct {
+	// Schema loading metrics
+	SchemasLoadedGauge     *service.MetricGauge
+	SchemaCacheHitCounter  *service.MetricCounter
+	SchemaCacheMissCounter *service.MetricCounter
+	SchemaFetchTimer       *service.MetricTimer
+	
+	// Validation metrics
+	ValidationSuccessCounter *service.MetricCounter
+	ValidationFailureCounter *service.MetricCounter
+	TagValidationFailCounter *service.MetricCounter
+	PayloadValidationFailCounter *service.MetricCounter
+	ValidationTimer          *service.MetricTimer
+	
+	// Error metrics
+	SchemaFetchErrorCounter   *service.MetricCounter
+	SchemaCompileErrorCounter *service.MetricCounter
+}
+
+// NewUnsOutputMetrics creates a new metrics collection for the UNS output plugin
+func NewUnsOutputMetrics(metricsProvider *service.Metrics) *UnsOutputMetrics {
+	return &UnsOutputMetrics{
+		// Schema loading metrics
+		SchemasLoadedGauge:     metricsProvider.NewGauge("output_uns_schemas_loaded"),
+		SchemaCacheHitCounter:  metricsProvider.NewCounter("output_uns_schema_cache_hits"),
+		SchemaCacheMissCounter: metricsProvider.NewCounter("output_uns_schema_cache_misses"),
+		SchemaFetchTimer:       metricsProvider.NewTimer("output_uns_schema_fetch_time"),
+		
+		// Validation metrics
+		ValidationSuccessCounter: metricsProvider.NewCounter("output_uns_validation_success"),
+		ValidationFailureCounter: metricsProvider.NewCounter("output_uns_validation_failure"),
+		TagValidationFailCounter: metricsProvider.NewCounter("output_uns_tag_validation_failure"),
+		PayloadValidationFailCounter: metricsProvider.NewCounter("output_uns_payload_validation_failure"),
+		ValidationTimer:          metricsProvider.NewTimer("output_uns_validation_time"),
+		
+		// Error metrics
+		SchemaFetchErrorCounter:   metricsProvider.NewCounter("output_uns_schema_fetch_errors"),
+		SchemaCompileErrorCounter: metricsProvider.NewCounter("output_uns_schema_compile_errors"),
+	}
+}
+
+// LogSchemaLoaded logs when a schema is successfully loaded
+func (m *UnsOutputMetrics) LogSchemaLoaded(startTime time.Time) {
+	m.SchemaFetchTimer.Timing(int64(time.Since(startTime)))
+	m.SchemasLoadedGauge.Set(1) // Increment loaded schemas count
+}
+
+// LogSchemaCacheHit logs a schema cache hit
+func (m *UnsOutputMetrics) LogSchemaCacheHit() {
+	m.SchemaCacheHitCounter.Incr(1)
+}
+
+// LogSchemaCacheMiss logs a schema cache miss
+func (m *UnsOutputMetrics) LogSchemaCacheMiss() {
+	m.SchemaCacheMissCounter.Incr(1)
+}
+
+// LogValidationSuccess logs a successful validation
+func (m *UnsOutputMetrics) LogValidationSuccess(startTime time.Time) {
+	m.ValidationSuccessCounter.Incr(1)
+	m.ValidationTimer.Timing(int64(time.Since(startTime)))
+}
+
+// LogValidationFailure logs a validation failure with type
+func (m *UnsOutputMetrics) LogValidationFailure(startTime time.Time, failureType string) {
+	m.ValidationFailureCounter.Incr(1)
+	m.ValidationTimer.Timing(int64(time.Since(startTime)))
+	
+	switch failureType {
+	case "tag":
+		m.TagValidationFailCounter.Incr(1)
+	case "payload":
+		m.PayloadValidationFailCounter.Incr(1)
+	}
+}
+
+// LogSchemaFetchError logs a schema fetch error
+func (m *UnsOutputMetrics) LogSchemaFetchError() {
+	m.SchemaFetchErrorCounter.Incr(1)
+}
+
+// LogSchemaCompileError logs a schema compilation error
+func (m *UnsOutputMetrics) LogSchemaCompileError() {
+	m.SchemaCompileErrorCounter.Incr(1)
+}
+
+// NewMockOutputMetrics creates a new metrics collection that doesn't actually record metrics
+// Useful for testing when you don't need real metrics
+func NewMockOutputMetrics() *UnsOutputMetrics {
+	mockResources := service.MockResources()
+	mockMetrics := mockResources.Metrics()
+	return &UnsOutputMetrics{
+		SchemasLoadedGauge:     mockMetrics.NewGauge("output_uns_schemas_loaded"),
+		SchemaCacheHitCounter:  mockMetrics.NewCounter("output_uns_schema_cache_hits"),
+		SchemaCacheMissCounter: mockMetrics.NewCounter("output_uns_schema_cache_misses"),
+		SchemaFetchTimer:       mockMetrics.NewTimer("output_uns_schema_fetch_time"),
+		ValidationSuccessCounter: mockMetrics.NewCounter("output_uns_validation_success"),
+		ValidationFailureCounter: mockMetrics.NewCounter("output_uns_validation_failure"),
+		TagValidationFailCounter: mockMetrics.NewCounter("output_uns_tag_validation_failure"),
+		PayloadValidationFailCounter: mockMetrics.NewCounter("output_uns_payload_validation_failure"),
+		ValidationTimer:          mockMetrics.NewTimer("output_uns_validation_time"),
+		SchemaFetchErrorCounter:   mockMetrics.NewCounter("output_uns_schema_fetch_errors"),
+		SchemaCompileErrorCounter: mockMetrics.NewCounter("output_uns_schema_compile_errors"),
+	}
+}
+```
+
+### 8. Integration with uns_output Plugin
+
+**File**: `uns_plugin/uns_output.go` (MODIFIED)
+
+```go
+// Update unsOutput struct to include metrics
+type unsOutput struct {
+	config        unsOutputConfig
+	client        MessagePublisher
+	schemaCache   *SchemaCache
+	metrics       *UnsOutputMetrics
+	log           *service.Logger
+}
+
+// Update constructor to include metrics
+func newUnsOutput(conf *service.ParsedConfig, mgr *service.Resources) (service.BatchOutput, service.BatchPolicy, int, error) {
+	// ... existing config parsing ...
+	
+	// Create schema cache if registry URL is provided and not explicitly disabled
+	var schemaCache *SchemaCache
+	if schemaRegistryURL != "" {
+		schemaCache = NewSchemaCache(schemaRegistryURL, mgr.Logger())
+	}
+	
+	// Create metrics
+	metrics := NewUnsOutputMetrics(mgr.Metrics())
+	
+	return newUnsOutputWithClient(NewClient(), config, schemaCache, metrics, mgr.Logger()), batchPolicy, maxInFlight, nil
+}
+
+// Update testable constructor
+func newUnsOutputWithClient(client MessagePublisher, config unsOutputConfig, schemaCache *SchemaCache, metrics *UnsOutputMetrics, logger *service.Logger) service.BatchOutput {
+	return &unsOutput{
+		client:      client,
+		config:      config,
+		schemaCache: schemaCache,
+		metrics:     metrics,
+		log:         logger,
+	}
+}
+
+// Update WriteBatch to include validation with metrics
+func (o *unsOutput) WriteBatch(ctx context.Context, msgs service.MessageBatch) error {
+	if len(msgs) == 0 {
+		return nil
+	}
+
+	records := make([]Record, 0, len(msgs))
+	for i, msg := range msgs {
+		// ... existing key validation ...
+		
+		// Perform schema validation if schema cache is available
+		if o.schemaCache != nil {
+			if err := o.validateMessage(ctx, msg, msgAsBytes, i); err != nil {
+				// Message failed validation, but continue with fail-open behavior
+				o.log.Warnf("Schema validation failed for message %d: %v", i, err)
+				// Note: Message is still processed (fail-open behavior)
+			}
+		}
+		
+		// ... rest of existing record preparation ...
+	}
+	
+	// ... existing batch sending logic ...
+}
+
+// validateMessage performs schema validation with metrics tracking
+func (o *unsOutput) validateMessage(ctx context.Context, msg *service.Message, msgBytes []byte, msgIndex int) error {
+	startTime := time.Now()
+	
+	// Get data contract from message metadata
+	contract := msg.MetaGet("data_contract")
+	if contract == "" {
+		o.log.Debugf("No data_contract metadata found for message %d, skipping validation", msgIndex)
+		return nil
+	}
+
+	// Get UNS topic and extract tag name
+	unsTopicKey, err := o.config.umh_topic.TryString(msg)
+	if err != nil {
+		return fmt.Errorf("failed to get UNS topic for message %d: %v", msgIndex, err)
+	}
+
+	tagName, err := extractTagNameFromUNSTopic(unsTopicKey)
+	if err != nil {
+		return fmt.Errorf("failed to extract tag name from UNS topic '%s' for message %d: %v", unsTopicKey, msgIndex, err)
+	}
+
+	// Get validator for this contract
+	validator, err := o.schemaCache.GetValidator(ctx, contract)
+	if err != nil {
+		o.metrics.LogSchemaFetchError()
+		o.log.Errorf("Failed to get validator for contract %s: %v", contract, err)
+		return nil // Fail open - don't block the message
+	}
+
+	if validator == nil {
+		// No schema registered for this contract - skip validation
+		return nil
+	}
+
+	// Perform dual validation (tag name + payload)
+	if err := validator.ValidateTagAndPayload(tagName, msgBytes); err != nil {
+		// Determine failure type
+		failureType := "payload"
+		if strings.Contains(err.Error(), "not allowed for contract") {
+			failureType = "tag"
+		}
+		
+		o.metrics.LogValidationFailure(startTime, failureType)
+		return fmt.Errorf("dual validation failed for contract %s, tag '%s' - %v", contract, tagName, err)
+	}
+
+	o.metrics.LogValidationSuccess(startTime)
+	o.log.Tracef("Message %d passed dual validation: contract=%s, tag=%s", msgIndex, contract, tagName)
+	return nil
+}
+```
+
+### 9. Update SchemaCache to Include Metrics
+
+**File**: `uns_plugin/schema_validator.go` (MODIFIED)
+
+```go
+// Update SchemaCache to include metrics
+type SchemaCache struct {
+	cache            map[string]SchemaValidator
+	lastFetch        map[string]time.Time
+	registryURL      string
+	refreshInterval  time.Duration
+	metrics          *UnsOutputMetrics  // NEW: Add metrics
+	mutex            sync.RWMutex
+	log              *service.Logger
+}
+
+// Update constructor to accept metrics
+func NewSchemaCache(registryURL string, logger *service.Logger) *SchemaCache {
+	return &SchemaCache{
+		cache:           make(map[string]SchemaValidator),
+		lastFetch:       make(map[string]time.Time),
+		registryURL:     registryURL,
+		refreshInterval: 10 * time.Minute,
+		log:             logger,
+		// metrics will be set later via SetMetrics
+	}
+}
+
+// SetMetrics sets the metrics instance for the cache
+func (sc *SchemaCache) SetMetrics(metrics *UnsOutputMetrics) {
+	sc.metrics = metrics
+}
+
+// Update fetchAndCacheSchema to include metrics
+func (sc *SchemaCache) fetchAndCacheSchema(ctx context.Context, contractInfo ContractInfo) (SchemaValidator, error) {
+	// ... existing logic ...
+	
+	// Check cache first
+	if validator, exists := sc.cache[cacheKey]; exists {
+		if sc.metrics != nil {
+			sc.metrics.LogSchemaCacheHit()
+		}
+		// ... existing cache hit logic ...
+	}
+	
+	if sc.metrics != nil {
+		sc.metrics.LogSchemaCacheMiss()
+	}
+	
+	fetchStart := time.Now()
+	client := NewSchemaRegistryClient(sc.registryURL)
+	schemaResp, err := client.GetSchemaForContract(contractInfo)
+	if err != nil {
+		if sc.metrics != nil {
+			sc.metrics.LogSchemaFetchError()
+		}
+		sc.log.Errorf("Failed to fetch schema for contract %s: %v", contractInfo.FullName, err)
+		return nil, nil // Fail open
+	}
+	
+	// ... existing response handling ...
+	
+	// Compile the contract schema
+	validator, err := NewCompiledContractSchema(contractInfo.FullName, []byte(schemaResp.Schema))
+	if err != nil {
+		if sc.metrics != nil {
+			sc.metrics.LogSchemaCompileError()
+		}
+		sc.log.Errorf("Failed to compile contract schema for %s: %v", contractInfo.FullName, err)
+		return nil, nil // Fail open
+	}
+	
+	if sc.metrics != nil {
+		sc.metrics.LogSchemaLoaded(fetchStart)
+	}
+	
+	// ... rest of existing caching logic ...
+}
+```
+
+### 10. Available Metrics
+
+The following metrics will be available through Benthos's metrics system:
+
+**Schema Loading Metrics:**
+- `output_uns_schemas_loaded` (Gauge): Number of loaded schemas
+- `output_uns_schema_cache_hits` (Counter): Schema cache hits
+- `output_uns_schema_cache_misses` (Counter): Schema cache misses
+- `output_uns_schema_fetch_time` (Timer): Time to fetch schemas from registry
+
+**Validation Metrics:**
+- `output_uns_validation_success` (Counter): Successful validations
+- `output_uns_validation_failure` (Counter): Failed validations
+- `output_uns_tag_validation_failure` (Counter): Tag name validation failures
+- `output_uns_payload_validation_failure` (Counter): Payload validation failures
+- `output_uns_validation_time` (Timer): Validation duration
+
+**Error Metrics:**
+- `output_uns_schema_fetch_errors` (Counter): Schema registry fetch errors
+- `output_uns_schema_compile_errors` (Counter): Schema compilation errors
+
+## Benefits of Metrics
+
+### 1. **Data Quality Monitoring**
+- Track validation success/failure rates per contract
+- Identify problematic contracts or schemas
+- Monitor data quality trends over time
+
+### 2. **Performance Monitoring**
+- Track validation latency per contract
+- Monitor cache hit rates
+- Identify performance bottlenecks
+
+### 3. **Operational Insights**
+- See which contracts are most/least used
+- Monitor schema loading and refresh patterns
+- Track schema registry health
+
+### 4. **Debugging Support**
+- Identify which tags are being rejected most often
+- Understand payload validation failure patterns
+- Monitor schema compilation issues
+
+### 5. **Capacity Planning**
+- Understand contract usage patterns
+- Plan schema registry capacity
+- Monitor validation throughput
+
+## Dependencies
+
+Add to go.mod:
+```bash
+go get github.com/kaptinlin/jsonschema@latest
+```
+
+## Key Benefits
+
+- ✅ **Dual Validation**: Validates both tag names (from UNS topic) AND payload structure
+- ✅ **Data Quality**: Only valid JSON messages with allowed tag names reach the UNS
+- ✅ **Version Support**: Handles both latest and specific contract versions (`_contract`, `_contractv1`)
+- ✅ **Zero Configuration**: Auto-derives schema registry URL from broker address
+- ✅ **Backward Compatible**: Existing configurations work without changes
+- ✅ **Tag Name Control**: Prevents unauthorized tag names per contract
+- ✅ **Payload Validation**: Ensures payload matches tag-specific JSON schema
+- ✅ **Performance**: Efficient caching minimizes schema registry load
+- ✅ **Reliability**: Fail-open design prevents data loss
+- ✅ **Rich Error Messages**: Clear validation failure messages for debugging
+- ✅ **Comprehensive Metrics**: Full observability into validation performance and data quality
+- ✅ **Operational Insights**: Track contract usage, validation success rates, and performance metrics
+- ✅ **Maintainability**: Clean, testable architecture with comprehensive test coverage 
\ No newline at end of file
diff --git a/ENG-3099-Notes.md b/ENG-3099-Notes.md
new file mode 100644
index 0000000..33768f3
--- /dev/null
+++ b/ENG-3099-Notes.md
@@ -0,0 +1,465 @@
+# ENG-3099 Notes: Real-World Data Model Context
+
+## Overview
+
+This document provides context on the actual data models that will be transformed into the JSON schemas used by our dual validation system in the `uns_output` plugin.
+
+## Data Model Structure Examples
+
+### Example 1: Simple Sensor Data
+
+**Source Data Model:**
+```yaml
+sensor-data:
+  description: "Basic sensor data model"
+  versions:
+    v1:
+      root:
+        value:
+          _type: timeseries-number
+    v2:
+      root:
+        value:
+          _type: timeseries-number
+        timestamp:
+          _type: timeseries-string
+        metadata:
+          _refModel: "sensor-metadata:v1"
+```
+
+**Transformed to Our Schema:**
+
+**Version 1 Schema:**
+```json
+{
+   "virtual_path": ["value"],
+   "fields": {
+      "value": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      }
+   }
+}
+```
+
+**Version 2 Schema:**
+```json
+{
+   "virtual_path": ["value", "timestamp", "metadata"],
+   "fields": {
+      "value": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "timestamp": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "string"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "metadata": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "object"}
+         },
+         "required": ["timestamp_ms", "value"]
+      }
+   }
+}
+```
+
+### Example 2: Complex Pump Model
+
+**Source Data Model:**
+```yaml
+pump:
+  description: "pump from vendor ABC"
+  versions:
+    v1:
+      root:
+        count:
+          _type: timeseries-number
+        vibration:
+          x-axis:
+            _type: timeseries-number
+            _description: "vibration measurement on x-axis" 
+          y-axis:
+            _type: timeseries-number
+            _unit: "mm/s"
+          z-axis:
+            _type: timeseries-number
+        motor:
+          _refModel: "motor:v1"
+        acceleration:
+          x:
+            _type: timeseries-number
+          y: 
+            _type: timeseries-number
+        serialNumber:
+          _type: timeseries-string
+```
+
+**Transformed to Our Schema:**
+> **Note:** The `motor` field is not included in the transformed schema because it only has `_refModel: "motor:v1"` (a reference to another model) without a `_type: timeseries-*`. Only fields with `_type: timeseries-*` are included in the virtual_path and fields for direct validation.
+```json
+{
+   "virtual_path": ["count", "vibration.x-axis", "vibration.y-axis", "vibration.z-axis", "acceleration.x", "acceleration.y", "serialNumber"],
+   "fields": {
+      "count": {
+         "type": "object", 
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "vibration.x-axis": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"}, 
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "vibration.y-axis": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "vibration.z-axis": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "acceleration.x": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "acceleration.y": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "serialNumber": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "string"}
+         },
+         "required": ["timestamp_ms", "value"]
+      }
+   }
+}
+```
+
+## Key Mapping Rules
+
+### 1. Virtual Path Generation
+
+**Simple Structure:**
+- `value` → `["value"]`
+
+**Nested Structure:**
+- `vibration.x-axis` + `vibration.y-axis` + `vibration.z-axis` → `["vibration.x-axis", "vibration.y-axis", "vibration.z-axis"]`
+
+### 2. Payload Type Mapping
+
+| Data Model `_type` | JSON Schema `type` |
+|-------------------|-------------------|
+| `timeseries-number` | `"number"` |
+| `timeseries-string` | `"string"` |
+| `timeseries-boolean` | `"boolean"` |
+
+### 3. Timeseries Standard Structure
+
+All fields with `_type: timeseries-*` get transformed to:
+```json
+{
+   "type": "object",
+   "properties": {
+      "timestamp_ms": {"type": "number"},
+      "value": {"type": "[extracted_type]"}
+   },
+   "required": ["timestamp_ms", "value"]
+}
+```
+
+### 4. Field Inclusion Rules
+
+**Included in virtual_path:**
+- ✅ Fields with `_type: timeseries-*`
+- ✅ Nested fields like `vibration.x-axis` when parent has timeseries children
+
+**Excluded from virtual_path:**
+- ❌ Fields with only `_refModel` (references to other models)
+- ❌ Fields with only metadata (`_description`, `_unit`, etc.) without `_type`
+
+## Validation Flow Examples
+
+### Example 1: Valid Message
+
+**UNS Topic:** `umh.v1.enterprise.site.area._pump_data.vibration.x-axis`
+**Tag Name Extracted:** `vibration.x-axis`
+**Contract:** `_pump_data`
+
+**Validation Steps:**
+1. ✅ Check if `vibration.x-axis` exists in `virtual_path`
+2. ✅ Validate payload against `fields["vibration.x-axis"]` schema
+
+**Payload:**
+```json
+{
+   "timestamp_ms": 1680000000000,
+   "value": 23.5
+}
+```
+
+**Result:** ✅ Passes both tag name and payload validation
+
+### Example 2: Invalid Tag Name
+
+**UNS Topic:** `umh.v1.enterprise.site.area._pump_data.unknown_field`
+**Tag Name Extracted:** `unknown_field`
+
+**Validation Steps:**
+1. ❌ `unknown_field` not found in `virtual_path: ["count", "vibration.x-axis", "vibration.y-axis", "vibration.z-axis", "acceleration.x", "acceleration.y", "serialNumber"]`
+
+**Result:** ❌ Rejected with "tag 'unknown_field' not allowed for contract '_pump_data'. Allowed tags: [count, vibration.x-axis, vibration.y-axis, vibration.z-axis, acceleration.x, acceleration.y, serialNumber]"
+
+### Example 3: Invalid Payload
+
+**UNS Topic:** `umh.v1.enterprise.site.area._pump_data.serialNumber`
+**Tag Name:** `serialNumber` ✅
+**Payload:**
+```json
+{
+   "timestamp_ms": "not_a_number",
+   "value": "ABC123"
+}
+```
+
+**Validation Steps:**
+1. ✅ Tag name validation passes
+2. ❌ Payload validation fails: `timestamp_ms` expected number, got string
+
+**Result:** ❌ Rejected with "payload validation failed for tag 'serialNumber': timestamp_ms: expected number, got string"
+
+## Version Handling
+
+**Data Model Versions:**
+- `sensor-data` v1 vs v2 → Different virtual paths and field schemas
+- `pump` v1 vs v2 → Evolution from basic to advanced monitoring
+- Versioned contracts: `_pump_datav1`, `_pump_datav2`
+
+**Schema Registry Mapping:**
+- `_pump_data` (latest) → Most recent pump model version
+- `_pump_datav1` → Specific version with locked schema (immutable)
+
+## Benefits of This Approach
+
+### 1. **Hierarchical Tag Control**
+- Prevents unauthorized nested tags like `vibration.unauthorized_axis`
+- Supports complex device hierarchies like `temperature.indoor` and `temperature.outdoor`
+
+### 2. **Consistent Timeseries Structure**
+- All data follows `{timestamp_ms, value}` pattern
+- Type safety on `value` field based on `_type` (timeseries-number, timeseries-string, etc.)
+
+### 3. **Model Evolution Support**
+- Version v1: Basic monitoring fields
+- Version v2: Enhanced with additional diagnostics and metadata
+- Versioned contracts ensure backward compatibility
+
+### 4. **Cross-Model References**
+- `_refModel: "motor:v1"` → Links to other schema definitions
+- Allows complex validation across related data structures
+
+### 5. **Rich Metadata Support**
+- `_description`, `_unit`, and other metadata enhance field understanding
+- Metadata is preserved but doesn't affect validation logic
+
+## Implementation Notes
+
+### Schema Transformation (Outside This PR)
+The transformation from YAML data models to JSON schemas happens in a separate pipeline/service and is **not part of ENG-3099**. Our validation system only consumes the final JSON schemas.
+
+### Tag Name Extraction
+Our `extractTagNameFromUNSTopic()` function handles both simple and hierarchical tags:
+- `umh.v1.site._pump_data.count` → `count`
+- `umh.v1.site._pump_data.vibration.x-axis` → `vibration.x-axis`
+- `umh.v1.site._environmental.temperature.outdoor` → `temperature.outdoor`
+
+### Performance Considerations
+- Virtual path lookups use hash maps for O(1) tag name validation
+- Compiled JSON schemas cached per tag for fast payload validation
+- Hierarchical tags don't impact performance vs simple tags
+
+## Real-World Usage Scenarios
+
+### Industrial Motor Device
+```yaml
+motor:
+  description: "Industrial motor with diagnostics"
+  versions:
+    v1:
+      root:
+        rpm:
+          _type: timeseries-number
+          _unit: "rpm"
+        temperature:
+          _type: timeseries-number
+          _unit: "°C"
+        status:
+          _type: timeseries-string
+          _description: "Motor status: running, stopped, error"
+        vibration:
+          level:
+            _type: timeseries-number
+            _unit: "mm/s"
+```
+
+**Generated Virtual Path:** `["rpm", "temperature", "status", "vibration.level"]`
+
+**Generated JSON Schema:**
+```json
+{
+   "virtual_path": ["rpm", "temperature", "status", "vibration.level"],
+   "fields": {
+      "rpm": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "temperature": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "status": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "string"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "vibration.level": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      }
+   }
+}
+```
+
+**Valid UNS Topics:** 
+- `umh.v1.factory.line1.machine5._motor_controller.rpm`
+- `umh.v1.factory.line1.machine5._motor_controller.temperature`
+- `umh.v1.factory.line1.machine5._motor_controller.status`
+- `umh.v1.factory.line1.machine5._motor_controller.vibration.level`
+
+### Environmental Sensors
+```yaml
+environmental:
+  description: "Environmental monitoring sensors"
+  versions:
+    v1:
+      root:
+        temperature:
+          outdoor:
+            _type: timeseries-number
+            _unit: "°C"
+          indoor:
+            _type: timeseries-number
+            _unit: "°C"
+        humidity:
+          _type: timeseries-number
+          _unit: "%"
+        pressure:
+          _type: timeseries-number
+          _unit: "hPa"
+```
+
+**Generated Virtual Path:** `["temperature.outdoor", "temperature.indoor", "humidity", "pressure"]`
+
+**Generated JSON Schema:**
+```json
+{
+   "virtual_path": ["temperature.outdoor", "temperature.indoor", "humidity", "pressure"],
+   "fields": {
+      "temperature.outdoor": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "temperature.indoor": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "humidity": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      },
+      "pressure": {
+         "type": "object",
+         "properties": {
+            "timestamp_ms": {"type": "number"},
+            "value": {"type": "number"}
+         },
+         "required": ["timestamp_ms", "value"]
+      }
+   }
+}
+```
+
+**Valid UNS Topics:**
+- `umh.v1.building.floor2.room201._environmental.temperature.outdoor`
+- `umh.v1.building.floor2.room201._environmental.temperature.indoor`
+- `umh.v1.building.floor2.room201._environmental.humidity`
+- `umh.v1.building.floor2.room201._environmental.pressure`
+
+This rich data model structure provides the foundation for comprehensive validation while maintaining the flexibility needed for complex industrial and IoT use cases. 
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 09e585e..a40a78a 100644
--- a/Makefile
+++ b/Makefile
@@ -79,7 +79,11 @@ test-opc:
 
 .PHONY: test-uns
 test-uns:
-	@$(GINKGO_CMD) $(GINKGO_FLAGS) ./uns_plugin/...
+	@$(GINKGO_CMD) $(GINKGO_FLAGS) --label-filter='!redpanda' ./uns_plugin/...
+
+.PHONY: test-uns-redpanda
+test-uns-redpanda:
+	@$(GINKGO_CMD) $(GINKGO_FLAGS)  ./uns_plugin/...
 
 .PHONY: test-s7comm
 test-s7comm:
diff --git a/go.mod b/go.mod
index c78ef0b..e77ab98 100644
--- a/go.mod
+++ b/go.mod
@@ -37,6 +37,7 @@ require (
 	github.com/gopcua/opcua v0.5.3
 	github.com/grid-x/modbus v0.0.0-20250312115347-d1d8b421f52b
 	github.com/hashicorp/golang-lru v0.5.4
+	github.com/kaptinlin/jsonschema v0.4.6
 	github.com/pierrec/lz4/v4 v4.1.22
 	github.com/redpanda-data/benthos/v4 v4.49.0
 	github.com/redpanda-data/connect/public/bundle/free/v4 v4.49.1
@@ -200,6 +201,7 @@ require (
 	github.com/go-sourcemap/sourcemap v2.1.4+incompatible // indirect
 	github.com/go-sql-driver/mysql v1.9.0 // indirect
 	github.com/go-task/slim-sprig/v3 v3.0.0 // indirect
+	github.com/goccy/go-yaml v1.18.0 // indirect
 	github.com/gocql/gocql v1.7.0 // indirect
 	github.com/godbus/dbus v0.0.0-20190726142602-4481cbc300e2 // indirect
 	github.com/gofrs/uuid v4.4.0+incompatible // indirect
@@ -226,6 +228,8 @@ require (
 	github.com/gorilla/websocket v1.5.3 // indirect
 	github.com/gosimple/slug v1.15.0 // indirect
 	github.com/gosimple/unidecode v1.0.1 // indirect
+	github.com/gotnospirit/makeplural v0.0.0-20180622080156-a5f48d94d976 // indirect
+	github.com/gotnospirit/messageformat v0.0.0-20221001023931-dfe49f1eb092 // indirect
 	github.com/govalues/decimal v0.1.36 // indirect
 	github.com/grid-x/serial v0.0.0-20211107191517-583c7356b3aa // indirect
 	github.com/grpc-ecosystem/go-grpc-middleware v1.4.0 // indirect
@@ -262,6 +266,7 @@ require (
 	github.com/josharian/intern v1.0.0 // indirect
 	github.com/json-iterator/go v1.1.12 // indirect
 	github.com/jzelinskie/stringz v0.0.3 // indirect
+	github.com/kaptinlin/go-i18n v0.1.4 // indirect
 	github.com/klauspost/compress v1.18.0 // indirect
 	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
 	github.com/klauspost/pgzip v1.2.6 // indirect
@@ -385,10 +390,10 @@ require (
 	golang.org/x/mod v0.24.0 // indirect
 	golang.org/x/net v0.39.0 // indirect
 	golang.org/x/oauth2 v0.29.0 // indirect
-	golang.org/x/sync v0.13.0 // indirect
+	golang.org/x/sync v0.14.0 // indirect
 	golang.org/x/sys v0.32.0 // indirect
 	golang.org/x/term v0.31.0 // indirect
-	golang.org/x/text v0.24.0 // indirect
+	golang.org/x/text v0.25.0 // indirect
 	golang.org/x/tools v0.32.0 // indirect
 	golang.org/x/xerrors v0.0.0-20240903120638-7835f813f4da // indirect
 	google.golang.org/api v0.226.0 // indirect
diff --git a/go.sum b/go.sum
index 130726c..661a088 100644
--- a/go.sum
+++ b/go.sum
@@ -1220,6 +1220,8 @@ github.com/gobwas/ws v1.0.2/go.mod h1:szmBTxLgaFppYjEmNtny/v3w89xOydFnnZMcgRRu/E
 github.com/goccy/go-json v0.9.11/go.mod h1:6MelG93GURQebXPDq3khkgXZkazVtN9CRI+MGFi0w8I=
 github.com/goccy/go-json v0.10.5 h1:Fq85nIqj+gXn/S5ahsiTlK3TmC85qgirsdTP/+DeaC4=
 github.com/goccy/go-json v0.10.5/go.mod h1:oq7eo15ShAhp70Anwd5lgX2pLfOS3QCiwU/PULtXL6M=
+github.com/goccy/go-yaml v1.18.0 h1:8W7wMFS12Pcas7KU+VVkaiCng+kG8QiFeFwzFb+rwuw=
+github.com/goccy/go-yaml v1.18.0/go.mod h1:XBurs7gK8ATbW4ZPGKgcbrY1Br56PdM69F7LkFRi1kA=
 github.com/gocql/gocql v1.7.0 h1:O+7U7/1gSN7QTEAaMEsJc1Oq2QHXvCWoF3DFK9HDHus=
 github.com/gocql/gocql v1.7.0/go.mod h1:vnlvXyFZeLBF0Wy+RS8hrOdbn0UWsWtdg07XJnFxZ+4=
 github.com/godbus/dbus v0.0.0-20190726142602-4481cbc300e2 h1:ZpnhV/YsD2/4cESfV5+Hoeu/iUR3ruzNvZ+yQfO03a0=
@@ -1412,6 +1414,10 @@ github.com/gosimple/slug v1.15.0 h1:wRZHsRrRcs6b0XnxMUBM6WK1U1Vg5B0R7VkIf1Xzobo=
 github.com/gosimple/slug v1.15.0/go.mod h1:UiRaFH+GEilHstLUmcBgWcI42viBN7mAb818JrYOeFQ=
 github.com/gosimple/unidecode v1.0.1 h1:hZzFTMMqSswvf0LBJZCZgThIZrpDHFXux9KeGmn6T/o=
 github.com/gosimple/unidecode v1.0.1/go.mod h1:CP0Cr1Y1kogOtx0bJblKzsVWrqYaqfNOnHzpgWw4Awc=
+github.com/gotnospirit/makeplural v0.0.0-20180622080156-a5f48d94d976 h1:b70jEaX2iaJSPZULSUxKtm73LBfsCrMsIlYCUgNGSIs=
+github.com/gotnospirit/makeplural v0.0.0-20180622080156-a5f48d94d976/go.mod h1:ZGQeOwybjD8lkCjIyJfqR5LD2wMVHJ31d6GdPxoTsWY=
+github.com/gotnospirit/messageformat v0.0.0-20221001023931-dfe49f1eb092 h1:c7gcNWTSr1gtLp6PyYi3wzvFCEcHJ4YRobDgqmIgf7Q=
+github.com/gotnospirit/messageformat v0.0.0-20221001023931-dfe49f1eb092/go.mod h1:ZZAN4fkkful3l1lpJwF8JbW41ZiG9TwJ2ZlqzQovBNU=
 github.com/govalues/decimal v0.1.36 h1:dojDpsSvrk0ndAx8+saW5h9WDIHdWpIwrH/yhl9olyU=
 github.com/govalues/decimal v0.1.36/go.mod h1:Ee7eI3Llf7hfqDZtpj8Q6NCIgJy1iY3kH1pSwDrNqlM=
 github.com/grid-x/modbus v0.0.0-20250312115347-d1d8b421f52b h1:12LFb/Ga2TH5SK1sog0EC8VCrOf2XMynjOM/dxF/qYY=
@@ -1574,6 +1580,10 @@ github.com/jung-kurt/gofpdf v1.0.0/go.mod h1:7Id9E/uU8ce6rXgefFLlgrJj/GYY22cpxn+
 github.com/jung-kurt/gofpdf v1.0.3-0.20190309125859-24315acbbda5/go.mod h1:7Id9E/uU8ce6rXgefFLlgrJj/GYY22cpxn+r32jIOes=
 github.com/jzelinskie/stringz v0.0.3 h1:0GhG3lVMYrYtIvRbxvQI6zqRTT1P1xyQlpa0FhfUXas=
 github.com/jzelinskie/stringz v0.0.3/go.mod h1:hHYbgxJuNLRw91CmpuFsYEOyQqpDVFg8pvEh23vy4P0=
+github.com/kaptinlin/go-i18n v0.1.4 h1:wCiwAn1LOcvymvWIVAM4m5dUAMiHunTdEubLDk4hTGs=
+github.com/kaptinlin/go-i18n v0.1.4/go.mod h1:g1fn1GvTgT4CiLE8/fFE1hboHWJ6erivrDpiDtCcFKg=
+github.com/kaptinlin/jsonschema v0.4.6 h1:vOSFg5tjmfkOdKg+D6Oo4fVOM/pActWu/ntkPsI1T64=
+github.com/kaptinlin/jsonschema v0.4.6/go.mod h1:1DUd7r5SdyB2ZnMtyB7uLv64dE3zTFTiYytDCd+AEL0=
 github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51/go.mod h1:CzGEWj7cYgsdH8dAjBGEr58BoE7ScuLd+fwFZ44+/x8=
 github.com/keybase/go-keychain v0.0.0-20231219164618-57a3676c3af6 h1:IsMZxCuZqKuao2vNdfD82fjjgPLfyHLpR41Z88viRWs=
 github.com/keybase/go-keychain v0.0.0-20231219164618-57a3676c3af6/go.mod h1:3VeWNIJaW+O5xpRQbPp0Ybqu1vJd/pm7s2F473HRrkw=
@@ -1775,8 +1785,8 @@ github.com/pborman/getopt v0.0.0-20180729010549-6fdd0a2c7117/go.mod h1:85jBQOZwp
 github.com/pebbe/zmq4 v1.3.0 h1:iBbv/Ugiw26/BVf1NXtYOCwUL0kefCwzgnypYBQj8iM=
 github.com/pebbe/zmq4 v1.3.0/go.mod h1:nqnPueOapVhE2wItZ0uOErngczsJdLOGkebMxaO8r48=
 github.com/pelletier/go-toml v1.9.5 h1:4yBQzkHv+7BHq2PQUZF3Mx0IYxG7LsP222s7Agd3ve8=
-github.com/pelletier/go-toml/v2 v2.2.3 h1:YmeHyLY8mFWbdkNWwpr+qIL2bEqT0o95WSdkNHvL12M=
-github.com/pelletier/go-toml/v2 v2.2.3/go.mod h1:MfCQTFTvCcUyyvvwm1+G6H/jORL20Xlb6rzQu9GuUkc=
+github.com/pelletier/go-toml/v2 v2.2.4 h1:mye9XuhQ6gvn5h28+VilKrrPoQVanw5PMw/TB0t5Ec4=
+github.com/pelletier/go-toml/v2 v2.2.4/go.mod h1:2gIqNv+qfxSVS7cM2xJQKtLSTLUE9V8t9Stt+h56mCY=
 github.com/pgvector/pgvector-go v0.3.0 h1:Ij+Yt78R//uYqs3Zk35evZFvr+G0blW0OUN+Q2D1RWc=
 github.com/pgvector/pgvector-go v0.3.0/go.mod h1:duFy+PXWfW7QQd5ibqutBO4GxLsUZ9RVXhFZGIBsWSA=
 github.com/phpdave11/gofpdf v1.4.2/go.mod h1:zpO6xFn9yxo3YLyMvW8HcKWVdbNqgIfOOp2dXMnm1mY=
@@ -2345,8 +2355,8 @@ golang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=
 golang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
 golang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
 golang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
-golang.org/x/sync v0.13.0 h1:AauUjRAJ9OSnvULf/ARrrVywoJDy0YS2AwQ98I37610=
-golang.org/x/sync v0.13.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
+golang.org/x/sync v0.14.0 h1:woo0S4Yywslg6hp4eUFjTVOyKt0RookbpAHG4c1HmhQ=
+golang.org/x/sync v0.14.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
 golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
@@ -2488,8 +2498,8 @@ golang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=
 golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
 golang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
 golang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=
-golang.org/x/text v0.24.0 h1:dd5Bzh4yt5KYA8f9CJHCP4FB4D51c2c6JvN37xJJkJ0=
-golang.org/x/text v0.24.0/go.mod h1:L8rBsPeo2pSS+xqN0d5u2ikmjtmoJbDBT1b7nHvFCdU=
+golang.org/x/text v0.25.0 h1:qVyWApTSYLk/drJRO5mDlNYskwQznZmkpV2c8q9zls4=
+golang.org/x/text v0.25.0/go.mod h1:WEdwpYrmk1qmdHvhkSTNPm3app7v4rsT8F2UD6+VHIA=
 golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
 golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
 golang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
diff --git a/uns_plugin/schema_validation/background_fetcher.go b/uns_plugin/schema_validation/background_fetcher.go
new file mode 100644
index 0000000..507213b
--- /dev/null
+++ b/uns_plugin/schema_validation/background_fetcher.go
@@ -0,0 +1,312 @@
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package schemavalidation
+
+import (
+	"encoding/json"
+	"fmt"
+	"io"
+	"net/http"
+	"strconv"
+	"strings"
+	"sync"
+	"time"
+)
+
+const (
+	maxFetchQueueSize = 10               // Maximum number of contracts to fetch
+	fetchInterval     = 5 * time.Second  // How often to check for new schemas
+	httpTimeout       = 30 * time.Second // HTTP request timeout
+)
+
+// BackgroundFetcher handles background schema fetching from the registry
+type BackgroundFetcher struct {
+	schemaRegistryURL string
+	httpClient        *http.Client
+	validator         *Validator
+
+	// Queue for contracts to fetch (limited to maxFetchQueueSize)
+	fetchQueue      map[string]bool // "contractName-v123" -> true
+	fetchQueueMutex sync.RWMutex
+
+	// Control
+	stopChan  chan struct{}
+	stopped   bool
+	stopMutex sync.RWMutex
+}
+
+// SchemaRegistrySubject represents a subject from the schema registry
+type SchemaRegistrySubject struct {
+	Subject string `json:"subject"`
+}
+
+// SchemaRegistryVersion represents a version response from the schema registry
+type SchemaRegistryVersion struct {
+	Version int    `json:"version"`
+	ID      int    `json:"id"`
+	Schema  string `json:"schema"`
+}
+
+// NewBackgroundFetcher creates a new background fetcher
+func NewBackgroundFetcher(schemaRegistryURL string, validator *Validator) *BackgroundFetcher {
+	return &BackgroundFetcher{
+		schemaRegistryURL: schemaRegistryURL,
+		httpClient: &http.Client{
+			Timeout: httpTimeout,
+		},
+		validator:  validator,
+		fetchQueue: make(map[string]bool),
+		stopChan:   make(chan struct{}),
+	}
+}
+
+// Start begins the background fetching goroutine
+func (bf *BackgroundFetcher) Start() {
+	go bf.fetchLoop()
+}
+
+// Stop stops the background fetching goroutine
+func (bf *BackgroundFetcher) Stop() {
+	bf.stopMutex.Lock()
+	defer bf.stopMutex.Unlock()
+
+	if !bf.stopped {
+		close(bf.stopChan)
+		bf.stopped = true
+	}
+}
+
+// QueueSchema adds a contract-version combination to the fetch queue
+func (bf *BackgroundFetcher) QueueSchema(contractName string, version uint64) {
+	bf.fetchQueueMutex.Lock()
+	defer bf.fetchQueueMutex.Unlock()
+
+	// Check if queue is full
+	if len(bf.fetchQueue) >= maxFetchQueueSize {
+		// Queue is full, ignore this request
+		return
+	}
+
+	key := fmt.Sprintf("%s-v%d", contractName, version)
+	bf.fetchQueue[key] = true
+}
+
+// fetchLoop is the main background fetching loop
+func (bf *BackgroundFetcher) fetchLoop() {
+	ticker := time.NewTicker(fetchInterval)
+	defer ticker.Stop()
+
+	for {
+		select {
+		case <-bf.stopChan:
+			return
+		case <-ticker.C:
+			bf.processFetchQueue()
+		}
+	}
+}
+
+// processFetchQueue processes all items in the fetch queue
+func (bf *BackgroundFetcher) processFetchQueue() {
+	bf.fetchQueueMutex.Lock()
+	currentQueue := make(map[string]bool)
+	for k, v := range bf.fetchQueue {
+		currentQueue[k] = v
+	}
+	// Clear the fetch queue
+	bf.fetchQueue = make(map[string]bool)
+	bf.fetchQueueMutex.Unlock()
+
+	if len(currentQueue) == 0 {
+		return
+	}
+
+	// Get all available subjects from the registry
+	subjects, err := bf.getAllSubjects()
+	if err != nil {
+		// Log error and re-queue all items
+		bf.fetchQueueMutex.Lock()
+		for k, v := range currentQueue {
+			if len(bf.fetchQueue) < maxFetchQueueSize {
+				bf.fetchQueue[k] = v
+			}
+		}
+		bf.fetchQueueMutex.Unlock()
+		return
+	}
+
+	// Process each item in the queue
+	for queueKey := range currentQueue {
+		bf.processQueueItem(queueKey, subjects)
+	}
+}
+
+// getAllSubjects fetches all subjects from the schema registry
+func (bf *BackgroundFetcher) getAllSubjects() ([]string, error) {
+	url := fmt.Sprintf("%s/subjects", bf.schemaRegistryURL)
+
+	resp, err := bf.httpClient.Get(url)
+	if err != nil {
+		return nil, fmt.Errorf("failed to fetch subjects from registry: %w", err)
+	}
+	defer resp.Body.Close()
+
+	if resp.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf("schema registry returned status %d when fetching subjects", resp.StatusCode)
+	}
+
+	body, err := io.ReadAll(resp.Body)
+	if err != nil {
+		return nil, fmt.Errorf("failed to read subjects response: %w", err)
+	}
+
+	var subjects []string
+	if err := json.Unmarshal(body, &subjects); err != nil {
+		return nil, fmt.Errorf("failed to unmarshal subjects response: %w", err)
+	}
+
+	return subjects, nil
+}
+
+// processQueueItem processes a single queue item
+func (bf *BackgroundFetcher) processQueueItem(queueKey string, subjects []string) {
+	// Parse the queue key to extract contract name and version
+	contractName, version, err := bf.parseQueueKey(queueKey)
+	if err != nil {
+		// Invalid queue key, skip
+		return
+	}
+
+	// Check if the contract exists in the subjects list
+	found := false
+	for _, subject := range subjects {
+		if subject == contractName {
+			found = true
+			break
+		}
+	}
+
+	if !found {
+		// Contract doesn't exist in registry, don't re-queue
+		return
+	}
+
+	// Check if the specific version exists
+	versionExists, err := bf.checkVersionExists(contractName, version)
+	if err != nil {
+		// Network error, re-queue the item
+		bf.reQueueItem(queueKey)
+		return
+	}
+
+	if !versionExists {
+		// Version doesn't exist, don't re-queue
+		return
+	}
+
+	// Fetch the schema
+	schema, err := bf.fetchSchema(contractName, version)
+	if err != nil {
+		// Error fetching schema, re-queue the item
+		bf.reQueueItem(queueKey)
+		return
+	}
+
+	// Load the schema into the validator
+	if err := bf.validator.LoadSchema(contractName, version, schema); err != nil {
+		// Schema loading failed, don't re-queue (likely a schema format issue)
+		return
+	}
+
+	// Success! Schema loaded, don't re-queue
+}
+
+// parseQueueKey parses a queue key like "contractName-v123" into name and version
+func (bf *BackgroundFetcher) parseQueueKey(queueKey string) (string, uint64, error) {
+	parts := strings.Split(queueKey, "-v")
+	if len(parts) != 2 {
+		return "", 0, fmt.Errorf("invalid queue key format: %s", queueKey)
+	}
+
+	contractName := parts[0]
+	version, err := strconv.ParseUint(parts[1], 10, 64)
+	if err != nil {
+		return "", 0, fmt.Errorf("invalid version in queue key %s: %w", queueKey, err)
+	}
+
+	return contractName, version, nil
+}
+
+// checkVersionExists checks if a specific version exists for a contract
+func (bf *BackgroundFetcher) checkVersionExists(contractName string, version uint64) (bool, error) {
+	url := fmt.Sprintf("%s/subjects/%s/versions/%d", bf.schemaRegistryURL, contractName, version)
+
+	resp, err := bf.httpClient.Get(url)
+	if err != nil {
+		return false, fmt.Errorf("failed to check version existence: %w", err)
+	}
+	defer resp.Body.Close()
+
+	if resp.StatusCode == http.StatusNotFound {
+		return false, nil
+	}
+
+	if resp.StatusCode != http.StatusOK {
+		return false, fmt.Errorf("schema registry returned status %d when checking version", resp.StatusCode)
+	}
+
+	return true, nil
+}
+
+// fetchSchema fetches the actual schema content
+func (bf *BackgroundFetcher) fetchSchema(contractName string, version uint64) ([]byte, error) {
+	url := fmt.Sprintf("%s/subjects/%s/versions/%d", bf.schemaRegistryURL, contractName, version)
+
+	resp, err := bf.httpClient.Get(url)
+	if err != nil {
+		return nil, fmt.Errorf("failed to fetch schema: %w", err)
+	}
+	defer resp.Body.Close()
+
+	if resp.StatusCode == http.StatusNotFound {
+		return nil, fmt.Errorf("schema not found for contract %s version %d", contractName, version)
+	}
+
+	if resp.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf("schema registry returned status %d when fetching schema", resp.StatusCode)
+	}
+
+	body, err := io.ReadAll(resp.Body)
+	if err != nil {
+		return nil, fmt.Errorf("failed to read schema response: %w", err)
+	}
+
+	var versionResp SchemaRegistryVersion
+	if err := json.Unmarshal(body, &versionResp); err != nil {
+		return nil, fmt.Errorf("failed to unmarshal schema response: %w", err)
+	}
+
+	return []byte(versionResp.Schema), nil
+}
+
+// reQueueItem re-adds an item to the fetch queue if there's space
+func (bf *BackgroundFetcher) reQueueItem(queueKey string) {
+	bf.fetchQueueMutex.Lock()
+	defer bf.fetchQueueMutex.Unlock()
+
+	if len(bf.fetchQueue) < maxFetchQueueSize {
+		bf.fetchQueue[queueKey] = true
+	}
+}
diff --git a/uns_plugin/schema_validation/background_fetcher_test.go b/uns_plugin/schema_validation/background_fetcher_test.go
new file mode 100644
index 0000000..39b239c
--- /dev/null
+++ b/uns_plugin/schema_validation/background_fetcher_test.go
@@ -0,0 +1,557 @@
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package schemavalidation
+
+import (
+	"time"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+	"github.com/united-manufacturing-hub/benthos-umh/pkg/umh/topic"
+)
+
+var _ = Describe("BackgroundFetcher", func() {
+	var (
+		fetcher      *BackgroundFetcher
+		validator    *Validator
+		mockRegistry *MockSchemaRegistry
+	)
+
+	BeforeEach(func() {
+		validator = NewValidator()
+		mockRegistry = NewMockSchemaRegistry()
+		mockRegistry.SetupTestSchemas()
+		fetcher = NewBackgroundFetcher(mockRegistry.URL(), validator)
+	})
+
+	AfterEach(func() {
+		if fetcher != nil {
+			fetcher.Stop()
+		}
+		if mockRegistry != nil {
+			mockRegistry.Close()
+		}
+	})
+
+	Context("when creating a new background fetcher", func() {
+		It("should initialize correctly", func() {
+			Expect(fetcher.schemaRegistryURL).To(Equal(mockRegistry.URL()))
+			Expect(fetcher.validator).To(Equal(validator))
+			Expect(fetcher.fetchQueue).NotTo(BeNil())
+			Expect(fetcher.httpClient).NotTo(BeNil())
+		})
+	})
+
+	Context("when queueing schemas", func() {
+		It("should add schema to queue", func() {
+			fetcher.QueueSchema("_test_contract", 1)
+
+			fetcher.fetchQueueMutex.RLock()
+			queueSize := len(fetcher.fetchQueue)
+			hasKey := fetcher.fetchQueue["_test_contract-v1"]
+			fetcher.fetchQueueMutex.RUnlock()
+
+			Expect(queueSize).To(Equal(1))
+			Expect(hasKey).To(BeTrue())
+		})
+
+		It("should respect maximum queue size", func() {
+			// Fill the queue beyond the maximum
+			for i := 0; i < maxFetchQueueSize+5; i++ {
+				fetcher.QueueSchema("_test_contract", uint64(i))
+			}
+
+			fetcher.fetchQueueMutex.RLock()
+			queueSize := len(fetcher.fetchQueue)
+			fetcher.fetchQueueMutex.RUnlock()
+
+			Expect(queueSize).To(Equal(maxFetchQueueSize))
+		})
+	})
+
+	Context("when parsing queue keys", func() {
+		It("should parse valid queue keys correctly", func() {
+			contractName, version, err := fetcher.parseQueueKey("_test_contract-v123")
+			Expect(err).To(BeNil())
+			Expect(contractName).To(Equal("_test_contract"))
+			Expect(version).To(Equal(uint64(123)))
+		})
+
+		It("should handle invalid queue keys", func() {
+			_, _, err := fetcher.parseQueueKey("invalid-key")
+			Expect(err).To(HaveOccurred())
+		})
+	})
+
+	Context("when starting and stopping", func() {
+		It("should start and stop without errors", func() {
+			fetcher.Start()
+			time.Sleep(100 * time.Millisecond) // Give it time to start
+
+			fetcher.Stop()
+
+			fetcher.stopMutex.RLock()
+			stopped := fetcher.stopped
+			fetcher.stopMutex.RUnlock()
+
+			Expect(stopped).To(BeTrue())
+		})
+	})
+
+	Context("when fetching schemas from registry", func() {
+		It("should fetch existing schemas successfully", func() {
+			// Queue a schema that exists in the mock registry
+			fetcher.QueueSchema("_sensor_data", 1)
+
+			// Process the queue manually
+			fetcher.processFetchQueue()
+
+			// Verify the schema was loaded into the validator
+			Expect(validator.HasSchema("_sensor_data", 1)).To(BeTrue())
+		})
+
+		It("should handle non-existent subjects", func() {
+			// Queue a schema for a subject that doesn't exist
+			fetcher.QueueSchema("_non_existent", 1)
+
+			// Process the queue manually
+			fetcher.processFetchQueue()
+
+			// Verify the schema was not loaded
+			Expect(validator.HasSchema("_non_existent", 1)).To(BeFalse())
+
+			// Verify the queue is empty (item was removed)
+			fetcher.fetchQueueMutex.RLock()
+			queueSize := len(fetcher.fetchQueue)
+			fetcher.fetchQueueMutex.RUnlock()
+			Expect(queueSize).To(Equal(0))
+		})
+
+		It("should handle non-existent versions", func() {
+			// Queue a schema for a version that doesn't exist
+			fetcher.QueueSchema("_sensor_data", 999)
+
+			// Process the queue manually
+			fetcher.processFetchQueue()
+
+			// Verify the schema was not loaded
+			Expect(validator.HasSchema("_sensor_data", 999)).To(BeFalse())
+
+			// Verify the queue is empty (item was removed)
+			fetcher.fetchQueueMutex.RLock()
+			queueSize := len(fetcher.fetchQueue)
+			fetcher.fetchQueueMutex.RUnlock()
+			Expect(queueSize).To(Equal(0))
+		})
+
+		It("should handle network errors gracefully", func() {
+			// Queue a valid schema first
+			fetcher.QueueSchema("_sensor_data", 1)
+
+			// Simulate network error
+			mockRegistry.SimulateNetworkError(true)
+
+			// Process the queue manually
+			fetcher.processFetchQueue()
+
+			// Verify the schema was not loaded due to network error
+			Expect(validator.HasSchema("_sensor_data", 1)).To(BeFalse())
+
+			// Verify the item was re-queued for retry
+			fetcher.fetchQueueMutex.RLock()
+			queueSize := len(fetcher.fetchQueue)
+			hasKey := fetcher.fetchQueue["_sensor_data-v1"]
+			fetcher.fetchQueueMutex.RUnlock()
+			Expect(queueSize).To(Equal(1))
+			Expect(hasKey).To(BeTrue())
+
+			// Restore network and try again
+			mockRegistry.SimulateNetworkError(false)
+			fetcher.processFetchQueue()
+
+			// Now it should succeed
+			Expect(validator.HasSchema("_sensor_data", 1)).To(BeTrue())
+		})
+
+		It("should fetch multiple schemas concurrently", func() {
+			// Queue multiple schemas
+			fetcher.QueueSchema("_sensor_data", 1)
+			fetcher.QueueSchema("_sensor_data", 2)
+			fetcher.QueueSchema("_pump_data", 1)
+			fetcher.QueueSchema("_motor_controller", 3)
+
+			// Process the queue manually
+			fetcher.processFetchQueue()
+
+			// Verify all schemas were loaded
+			Expect(validator.HasSchema("_sensor_data", 1)).To(BeTrue())
+			Expect(validator.HasSchema("_sensor_data", 2)).To(BeTrue())
+			Expect(validator.HasSchema("_pump_data", 1)).To(BeTrue())
+			Expect(validator.HasSchema("_motor_controller", 3)).To(BeTrue())
+		})
+	})
+
+	Context("when running in background", func() {
+		It("should automatically process queued items", func() {
+			// Start the background fetcher
+			fetcher.Start()
+
+			// Queue a schema
+			fetcher.QueueSchema("_sensor_data", 1)
+
+			// Wait for background processing (more than fetchInterval)
+			time.Sleep(6 * time.Second)
+
+			// Verify the schema was automatically loaded
+			Expect(validator.HasSchema("_sensor_data", 1)).To(BeTrue())
+
+			// Stop the fetcher
+			fetcher.Stop()
+		})
+	})
+})
+
+var _ = Describe("Validator with Background Fetcher", func() {
+	var validator *Validator
+
+	BeforeEach(func() {
+		validator = NewValidatorWithRegistry("http://localhost:8081")
+	})
+
+	AfterEach(func() {
+		if validator != nil {
+			validator.Close()
+		}
+	})
+
+	Context("when created with registry URL", func() {
+		It("should have a background fetcher", func() {
+			Expect(validator.backgroundFetcher).NotTo(BeNil())
+		})
+	})
+
+	Context("when created without registry URL", func() {
+		It("should not have a background fetcher", func() {
+			validatorWithoutRegistry := NewValidatorWithRegistry("")
+			Expect(validatorWithoutRegistry.backgroundFetcher).To(BeNil())
+		})
+	})
+})
+
+var _ = Describe("Integration: Mock Registry + Validator", func() {
+	var (
+		validator    *Validator
+		mockRegistry *MockSchemaRegistry
+	)
+
+	BeforeEach(func() {
+		// Set up mock registry with test schemas
+		mockRegistry = NewMockSchemaRegistry()
+		mockRegistry.SetupTestSchemas()
+
+		// Create validator with mock registry URL
+		validator = NewValidatorWithRegistry(mockRegistry.URL())
+	})
+
+	AfterEach(func() {
+		if validator != nil {
+			validator.Close()
+		}
+		if mockRegistry != nil {
+			mockRegistry.Close()
+		}
+	})
+
+	Context("when validating messages with existing schemas", func() {
+		It("should validate sensor data v1 successfully", func() {
+			// Load the schema first (simulating background fetch)
+			schemaVersion := mockRegistry.GetSchema("_sensor_data", 1)
+			Expect(schemaVersion).NotTo(BeNil())
+			err := validator.LoadSchema("_sensor_data", 1, []byte(schemaVersion.Schema))
+			Expect(err).To(BeNil())
+
+			// Create a valid UNS topic
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+
+			// Create valid payload
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			// Validate
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(BeNil())
+			Expect(result.ContractName).To(Equal("_sensor_data"))
+			Expect(result.ContractVersion).To(Equal(uint64(1)))
+		})
+
+		It("should reject sensor data v1 with invalid virtual path", func() {
+			// Load the schema first
+			schemaVersion := mockRegistry.GetSchema("_sensor_data", 1)
+			Expect(schemaVersion).NotTo(BeNil())
+			err := validator.LoadSchema("_sensor_data", 1, []byte(schemaVersion.Schema))
+			Expect(err).To(BeNil())
+
+			// Create UNS topic with invalid virtual path (humidity not allowed in v1)
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.humidity")
+			Expect(err).To(BeNil())
+
+			// Create valid payload
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 65.0}}`)
+
+			// Validate
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+			Expect(result.Error.Error()).To(ContainSubstring("schema validation failed"))
+		})
+
+		It("should validate sensor data v2 with expanded virtual paths", func() {
+			// Load the schema first
+			schemaVersion := mockRegistry.GetSchema("_sensor_data", 2)
+			Expect(schemaVersion).NotTo(BeNil())
+			err := validator.LoadSchema("_sensor_data", 2, []byte(schemaVersion.Schema))
+			Expect(err).To(BeNil())
+
+			// Test temperature (allowed in both v1 and v2)
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v2.temperature")
+			Expect(err).To(BeNil())
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.Error).To(BeNil())
+
+			// Test humidity (allowed in v2 but not v1)
+			unsTopic, err = topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v2.humidity")
+			Expect(err).To(BeNil())
+			payload = []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 65.0}}`)
+			result = validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.Error).To(BeNil())
+
+			// Test pressure (allowed in v2 but not v1)
+			unsTopic, err = topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v2.pressure")
+			Expect(err).To(BeNil())
+			payload = []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 1013.25}}`)
+			result = validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.Error).To(BeNil())
+		})
+
+		It("should validate pump data with complex virtual paths", func() {
+			// Load the schema first
+			schemaVersion := mockRegistry.GetSchema("_pump_data", 1)
+			Expect(schemaVersion).NotTo(BeNil())
+			err := validator.LoadSchema("_pump_data", 1, []byte(schemaVersion.Schema))
+			Expect(err).To(BeNil())
+
+			// Test vibration.x-axis
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._pump_data-v1.vibration.x-axis")
+			Expect(err).To(BeNil())
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 0.5}}`)
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.Error).To(BeNil())
+
+			// Test vibration.y-axis
+			unsTopic, err = topic.NewUnsTopic("umh.v1.enterprise.site.area._pump_data-v1.vibration.y-axis")
+			Expect(err).To(BeNil())
+			payload = []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 0.3}}`)
+			result = validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.Error).To(BeNil())
+
+			// Test count
+			unsTopic, err = topic.NewUnsTopic("umh.v1.enterprise.site.area._pump_data-v1.count")
+			Expect(err).To(BeNil())
+			payload = []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 1542}}`)
+			result = validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.Error).To(BeNil())
+		})
+
+		It("should validate string data types correctly", func() {
+			// Load the schema first
+			schemaVersion := mockRegistry.GetSchema("_string_data", 1)
+			Expect(schemaVersion).NotTo(BeNil())
+			err := validator.LoadSchema("_string_data", 1, []byte(schemaVersion.Schema))
+			Expect(err).To(BeNil())
+
+			// Test string value (serialNumber)
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._string_data-v1.serialNumber")
+			Expect(err).To(BeNil())
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": "SN123456789"}}`)
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.Error).To(BeNil())
+
+			// Test string value (status)
+			unsTopic, err = topic.NewUnsTopic("umh.v1.enterprise.site.area._string_data-v1.status")
+			Expect(err).To(BeNil())
+			payload = []byte(`{"value": {"timestamp_ms": 1719859200000, "value": "RUNNING"}}`)
+			result = validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.Error).To(BeNil())
+		})
+
+		It("should reject invalid payload formats", func() {
+			// Load the schema first
+			schemaVersion := mockRegistry.GetSchema("_sensor_data", 1)
+			Expect(schemaVersion).NotTo(BeNil())
+			err := validator.LoadSchema("_sensor_data", 1, []byte(schemaVersion.Schema))
+			Expect(err).To(BeNil())
+
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+
+			// Missing timestamp_ms
+			payload := []byte(`{"value": {"value": 25.5}}`)
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+
+			// Missing value
+			payload = []byte(`{"value": {"timestamp_ms": 1719859200000}}`)
+			result = validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+
+			// Wrong value type
+			payload = []byte(`{"value": {"timestamp_ms": 1719859200000, "value": "not_a_number"}}`)
+			result = validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+		})
+
+		It("should reject wrong data types for string fields", func() {
+			// Load the schema first
+			schemaVersion := mockRegistry.GetSchema("_string_data", 1)
+			Expect(schemaVersion).NotTo(BeNil())
+			err := validator.LoadSchema("_string_data", 1, []byte(schemaVersion.Schema))
+			Expect(err).To(BeNil())
+
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._string_data-v1.serialNumber")
+			Expect(err).To(BeNil())
+
+			// Provide number instead of string
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 12345}}`)
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+		})
+	})
+
+	Context("when testing background fetching integration", func() {
+		It("should queue and fetch schemas automatically", func() {
+			// Create topic that will trigger background fetch
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+
+			// Create valid payload
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			// First validation should bypass (schema not loaded yet)
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+			Expect(result.BypassReason).To(ContainSubstring("schema for contract '_sensor_data' version 1 not found"))
+
+			// Manual trigger of background fetch (in real scenario this would happen automatically)
+			if validator.backgroundFetcher != nil {
+				validator.backgroundFetcher.processFetchQueue()
+			}
+
+			// Now validation should pass
+			result = validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(BeNil())
+		})
+	})
+
+	Context("when handling unversioned contracts", func() {
+		It("should bypass validation for unversioned contracts", func() {
+			// Create topic with unversioned contract
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._unversioned_contract.temperature")
+			Expect(err).To(BeNil())
+
+			// Create valid payload
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			// Should bypass validation
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+			Expect(result.BypassReason).To(ContainSubstring("unversioned contract '_unversioned_contract' - bypassing validation (no latest fetching)"))
+			Expect(result.Error).To(BeNil())
+		})
+	})
+
+	Context("when handling missing schemas", func() {
+		It("should bypass validation for non-existent schemas", func() {
+			// Create topic with contract that doesn't exist in mock registry
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._non_existent_contract-v1.temperature")
+			Expect(err).To(BeNil())
+
+			// Create valid payload
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			// Should bypass validation
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+			Expect(result.BypassReason).To(ContainSubstring("schema for contract '_non_existent_contract' version 1 not found"))
+			Expect(result.Error).To(BeNil())
+		})
+	})
+
+	Context("when testing schema versioning", func() {
+		It("should handle different schema versions independently", func() {
+			// Load both v1 and v2 schemas
+			schemaV1 := mockRegistry.GetSchema("_sensor_data", 1)
+			Expect(schemaV1).NotTo(BeNil())
+			err := validator.LoadSchema("_sensor_data", 1, []byte(schemaV1.Schema))
+			Expect(err).To(BeNil())
+			schemaV2 := mockRegistry.GetSchema("_sensor_data", 2)
+			Expect(schemaV2).NotTo(BeNil())
+			err = validator.LoadSchema("_sensor_data", 2, []byte(schemaV2.Schema))
+			Expect(err).To(BeNil())
+
+			// Test v1 - should only allow temperature
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.ContractVersion).To(Equal(uint64(1)))
+
+			// Test v1 with humidity should fail
+			unsTopic, err = topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.humidity")
+			Expect(err).To(BeNil())
+			result = validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+
+			// Test v2 - should allow temperature, humidity, and pressure
+			unsTopic, err = topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v2.humidity")
+			Expect(err).To(BeNil())
+			result = validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.ContractVersion).To(Equal(uint64(2)))
+		})
+	})
+})
diff --git a/uns_plugin/schema_validation/mock_schema_registry.go b/uns_plugin/schema_validation/mock_schema_registry.go
new file mode 100644
index 0000000..c2cb944
--- /dev/null
+++ b/uns_plugin/schema_validation/mock_schema_registry.go
@@ -0,0 +1,379 @@
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package schemavalidation
+
+import (
+	"encoding/json"
+	"fmt"
+	"net/http"
+	"net/http/httptest"
+	"strconv"
+	"strings"
+)
+
+// MockSchemaRegistry simulates Redpanda's Schema Registry for testing
+type MockSchemaRegistry struct {
+	server  *httptest.Server
+	schemas map[string]map[int]*MockSchemaVersion // subject -> version -> schema
+}
+
+// MockSchemaVersion represents a schema version in the mock registry
+type MockSchemaVersion struct {
+	ID      int    `json:"id"`
+	Version int    `json:"version"`
+	Schema  string `json:"schema"`
+	Subject string `json:"subject"`
+}
+
+// NewMockSchemaRegistry creates a new mock schema registry server
+func NewMockSchemaRegistry() *MockSchemaRegistry {
+	mock := &MockSchemaRegistry{
+		schemas: make(map[string]map[int]*MockSchemaVersion),
+	}
+
+	// Create HTTP server with Redpanda-compatible API
+	mux := http.NewServeMux()
+	mux.HandleFunc("/subjects", mock.handleSubjects)
+	mux.HandleFunc("/subjects/", mock.handleSubjectVersions)
+
+	mock.server = httptest.NewServer(mux)
+	return mock
+}
+
+// URL returns the base URL of the mock server
+func (m *MockSchemaRegistry) URL() string {
+	return m.server.URL
+}
+
+// Close shuts down the mock server
+func (m *MockSchemaRegistry) Close() {
+	m.server.Close()
+}
+
+// AddSchema adds a schema to the mock registry
+func (m *MockSchemaRegistry) AddSchema(subject string, version int, schema string) {
+	if m.schemas[subject] == nil {
+		m.schemas[subject] = make(map[int]*MockSchemaVersion)
+	}
+
+	// Generate a unique ID (simple incrementing for mock)
+	id := len(m.schemas) + version*1000
+
+	m.schemas[subject][version] = &MockSchemaVersion{
+		ID:      id,
+		Version: version,
+		Schema:  schema,
+		Subject: subject,
+	}
+}
+
+// RemoveSchema removes a schema from the mock registry
+func (m *MockSchemaRegistry) RemoveSchema(subject string, version int) {
+	if versions, exists := m.schemas[subject]; exists {
+		delete(versions, version)
+		if len(versions) == 0 {
+			delete(m.schemas, subject)
+		}
+	}
+}
+
+// GetSchema gets a schema from the mock registry
+func (m *MockSchemaRegistry) GetSchema(subject string, version int) *MockSchemaVersion {
+	if versions, exists := m.schemas[subject]; exists {
+		return versions[version]
+	}
+	return nil
+}
+
+// handleSubjects handles GET /subjects - returns all available subjects
+func (m *MockSchemaRegistry) handleSubjects(w http.ResponseWriter, r *http.Request) {
+	if r.Method != http.MethodGet {
+		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
+		return
+	}
+
+	// Collect all subjects
+	var subjects []string
+	for subject := range m.schemas {
+		subjects = append(subjects, subject)
+	}
+
+	w.Header().Set("Content-Type", "application/json")
+	json.NewEncoder(w).Encode(subjects)
+}
+
+// handleSubjectVersions handles requests to /subjects/{subject}/versions/{version}
+func (m *MockSchemaRegistry) handleSubjectVersions(w http.ResponseWriter, r *http.Request) {
+	if r.Method != http.MethodGet {
+		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
+		return
+	}
+
+	// Parse the URL path: /subjects/{subject}/versions/{version}
+	path := strings.TrimPrefix(r.URL.Path, "/subjects/")
+	parts := strings.Split(path, "/")
+
+	if len(parts) < 3 || parts[1] != "versions" {
+		http.Error(w, "Invalid path", http.StatusBadRequest)
+		return
+	}
+
+	subject := parts[0]
+	versionStr := parts[2]
+
+	// Handle "latest" version request
+	if versionStr == "latest" {
+		m.handleLatestVersion(w, subject)
+		return
+	}
+
+	// Parse version number
+	version, err := strconv.Atoi(versionStr)
+	if err != nil {
+		http.Error(w, "Invalid version format", http.StatusBadRequest)
+		return
+	}
+
+	// Check if subject exists
+	versions, subjectExists := m.schemas[subject]
+	if !subjectExists {
+		http.Error(w, fmt.Sprintf(`{"error_code":40401,"message":"Subject '%s' not found."}`, subject), http.StatusNotFound)
+		return
+	}
+
+	// Check if version exists
+	schema, versionExists := versions[version]
+	if !versionExists {
+		http.Error(w, fmt.Sprintf(`{"error_code":40402,"message":"Version %d not found for subject '%s'."}`, version, subject), http.StatusNotFound)
+		return
+	}
+
+	// Return the schema version (Redpanda format)
+	w.Header().Set("Content-Type", "application/json")
+	json.NewEncoder(w).Encode(schema)
+}
+
+// handleLatestVersion handles requests for the latest version of a subject
+func (m *MockSchemaRegistry) handleLatestVersion(w http.ResponseWriter, subject string) {
+	versions, subjectExists := m.schemas[subject]
+	if !subjectExists {
+		http.Error(w, fmt.Sprintf(`{"error_code":40401,"message":"Subject '%s' not found."}`, subject), http.StatusNotFound)
+		return
+	}
+
+	// Find the latest version
+	var latestVersion int
+	var latestSchema *MockSchemaVersion
+	for version, schema := range versions {
+		if version > latestVersion {
+			latestVersion = version
+			latestSchema = schema
+		}
+	}
+
+	if latestSchema == nil {
+		http.Error(w, fmt.Sprintf(`{"error_code":40402,"message":"No versions found for subject '%s'."}`, subject), http.StatusNotFound)
+		return
+	}
+
+	w.Header().Set("Content-Type", "application/json")
+	json.NewEncoder(w).Encode(latestSchema)
+}
+
+// SetupTestSchemas adds common test schemas to the mock registry
+func (m *MockSchemaRegistry) SetupTestSchemas() {
+	// Add a sensor data contract v1 (temperature only)
+	sensorDataV1 := `{
+		"type": "object",
+		"properties": {
+			"virtual_path": {
+				"type": "string",
+				"enum": ["temperature"]
+			},
+			"fields": {
+				"type": "object",
+				"properties": {
+					"value": {
+						"type": "object",
+						"properties": {
+							"timestamp_ms": {"type": "number"},
+							"value": {"type": "number"}
+						},
+						"required": ["timestamp_ms", "value"],
+						"additionalProperties": false
+					}
+				},
+				"additionalProperties": false
+			}
+		},
+		"required": ["virtual_path", "fields"],
+		"additionalProperties": false
+	}`
+	m.AddSchema("_sensor_data", 1, sensorDataV1)
+
+	// Add a sensor data contract v2 with additional fields
+	sensorDataV2 := `{
+		"type": "object",
+		"properties": {
+			"virtual_path": {
+				"type": "string",
+				"enum": ["temperature", "humidity", "pressure"]
+			},
+			"fields": {
+				"type": "object",
+				"properties": {
+					"value": {
+						"type": "object",
+						"properties": {
+							"timestamp_ms": {"type": "number"},
+							"value": {"type": "number"}
+						},
+						"required": ["timestamp_ms", "value"],
+						"additionalProperties": false
+					}
+				},
+				"additionalProperties": false
+			}
+		},
+		"required": ["virtual_path", "fields"],
+		"additionalProperties": false
+	}`
+	m.AddSchema("_sensor_data", 2, sensorDataV2)
+
+	// Add a pump contract v1
+	pumpDataV1 := `{
+		"type": "object",
+		"properties": {
+			"virtual_path": {
+				"type": "string",
+				"enum": ["vibration.x-axis", "vibration.y-axis", "count"]
+			},
+			"fields": {
+				"type": "object",
+				"properties": {
+					"value": {
+						"type": "object",
+						"properties": {
+							"timestamp_ms": {"type": "number"},
+							"value": {"type": "number"}
+						},
+						"required": ["timestamp_ms", "value"],
+						"additionalProperties": false
+					}
+				},
+				"additionalProperties": false
+			}
+		},
+		"required": ["virtual_path", "fields"],
+		"additionalProperties": false
+	}`
+	m.AddSchema("_pump_data", 1, pumpDataV1)
+
+	// Add a motor contract v3 (skipping v1 and v2 to test version gaps)
+	motorDataV3 := `{
+		"type": "object",
+		"properties": {
+			"virtual_path": {
+				"type": "string",
+				"enum": ["rpm", "temperature", "status"]
+			},
+			"fields": {
+				"type": "object",
+				"properties": {
+					"value": {
+						"type": "object",
+						"properties": {
+							"timestamp_ms": {"type": "number"},
+							"value": {"type": "number"}
+						},
+						"required": ["timestamp_ms", "value"],
+						"additionalProperties": false
+					}
+				},
+				"additionalProperties": false
+			}
+		},
+		"required": ["virtual_path", "fields"],
+		"additionalProperties": false
+	}`
+	m.AddSchema("_motor_controller", 3, motorDataV3)
+
+	// Add a string value schema for testing different data types
+	stringDataV1 := `{
+		"type": "object",
+		"properties": {
+			"virtual_path": {
+				"type": "string",
+				"enum": ["serialNumber", "status"]
+			},
+			"fields": {
+				"type": "object",
+				"properties": {
+					"value": {
+						"type": "object",
+						"properties": {
+							"timestamp_ms": {"type": "number"},
+							"value": {"type": "string"}
+						},
+						"required": ["timestamp_ms", "value"],
+						"additionalProperties": false
+					}
+				},
+				"additionalProperties": false
+			}
+		},
+		"required": ["virtual_path", "fields"],
+		"additionalProperties": false
+	}`
+	m.AddSchema("_string_data", 1, stringDataV1)
+}
+
+// SimulateNetworkError makes the mock server return 500 errors for testing
+func (m *MockSchemaRegistry) SimulateNetworkError(enable bool) {
+	if enable {
+		// Replace handlers with error handlers
+		mux := http.NewServeMux()
+		mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
+			http.Error(w, "Internal Server Error", http.StatusInternalServerError)
+		})
+		m.server.Config.Handler = mux
+	} else {
+		// Restore normal handlers
+		mux := http.NewServeMux()
+		mux.HandleFunc("/subjects", m.handleSubjects)
+		mux.HandleFunc("/subjects/", m.handleSubjectVersions)
+		m.server.Config.Handler = mux
+	}
+}
+
+// GetRegisteredSubjects returns all subjects currently in the mock registry
+func (m *MockSchemaRegistry) GetRegisteredSubjects() []string {
+	var subjects []string
+	for subject := range m.schemas {
+		subjects = append(subjects, subject)
+	}
+	return subjects
+}
+
+// GetVersionsForSubject returns all versions for a given subject
+func (m *MockSchemaRegistry) GetVersionsForSubject(subject string) []int {
+	var versions []int
+	if subjectVersions, exists := m.schemas[subject]; exists {
+		for version := range subjectVersions {
+			versions = append(versions, version)
+		}
+	}
+	return versions
+}
diff --git a/uns_plugin/schema_validation/redpanda_integration_test.go b/uns_plugin/schema_validation/redpanda_integration_test.go
new file mode 100644
index 0000000..82db4c1
--- /dev/null
+++ b/uns_plugin/schema_validation/redpanda_integration_test.go
@@ -0,0 +1,728 @@
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package schemavalidation
+
+import (
+	"bytes"
+	"encoding/json"
+	"fmt"
+	"net/http"
+	"os/exec"
+	"sort"
+	"strings"
+	"time"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+	"github.com/united-manufacturing-hub/benthos-umh/pkg/umh/topic"
+)
+
+const (
+	redpandaContainerName      = "benthos-umh-test-redpanda"
+	redpandaSchemaRegistryURL  = "http://localhost:8081"
+	redpandaKafkaPort          = "9092"
+	redpandaSchemaRegistryPort = "8081"
+)
+
+// RedpandaTestSchemas contains the test schemas we'll load into Redpanda
+// We'll add a timestamp suffix to avoid conflicts between test runs
+var redpandaTestSchemas = map[string]map[int]string{
+	"_sensor_data": {
+		1: `{
+			"type": "object",
+			"properties": {
+				"virtual_path": {
+					"type": "string",
+					"enum": ["temperature"]
+				},
+				"fields": {
+					"type": "object",
+					"properties": {
+						"value": {
+							"type": "object",
+							"properties": {
+								"timestamp_ms": {"type": "number"},
+								"value": {"type": "number"}
+							},
+							"required": ["timestamp_ms", "value"],
+							"additionalProperties": false
+						}
+					},
+					"additionalProperties": false
+				}
+			},
+			"required": ["virtual_path", "fields"],
+			"additionalProperties": false
+		}`,
+		2: `{
+			"type": "object",
+			"properties": {
+				"virtual_path": {
+					"type": "string",
+					"enum": ["temperature", "humidity", "pressure"]
+				},
+				"fields": {
+					"type": "object",
+					"properties": {
+						"value": {
+							"type": "object",
+							"properties": {
+								"timestamp_ms": {"type": "number"},
+								"value": {"type": "number"}
+							},
+							"required": ["timestamp_ms", "value"],
+							"additionalProperties": false
+						}
+					},
+					"additionalProperties": false
+				}
+			},
+			"required": ["virtual_path", "fields"],
+			"additionalProperties": false
+		}`,
+	},
+	"_pump_data": {
+		1: `{
+			"type": "object",
+			"properties": {
+				"virtual_path": {
+					"type": "string",
+					"enum": ["vibration.x-axis", "vibration.y-axis", "count"]
+				},
+				"fields": {
+					"type": "object",
+					"properties": {
+						"value": {
+							"type": "object",
+							"properties": {
+								"timestamp_ms": {"type": "number"},
+								"value": {"type": "number"}
+							},
+							"required": ["timestamp_ms", "value"],
+							"additionalProperties": false
+						}
+					},
+					"additionalProperties": false
+				}
+			},
+			"required": ["virtual_path", "fields"],
+			"additionalProperties": false
+		}`,
+	},
+	"_string_data": {
+		1: `{
+			"type": "object",
+			"properties": {
+				"virtual_path": {
+					"type": "string",
+					"enum": ["serialNumber", "status"]
+				},
+				"fields": {
+					"type": "object",
+					"properties": {
+						"value": {
+							"type": "object",
+							"properties": {
+								"timestamp_ms": {"type": "number"},
+								"value": {"type": "string"}
+							},
+							"required": ["timestamp_ms", "value"],
+							"additionalProperties": false
+						}
+					},
+					"additionalProperties": false
+				}
+			},
+			"required": ["virtual_path", "fields"],
+			"additionalProperties": false
+		}`,
+	},
+}
+
+// RedpandaSchemaRegistryClient for interacting with real Redpanda schema registry
+type RedpandaSchemaRegistryClient struct {
+	baseURL    string
+	httpClient *http.Client
+}
+
+func NewRedpandaSchemaRegistryClient(baseURL string) *RedpandaSchemaRegistryClient {
+	return &RedpandaSchemaRegistryClient{
+		baseURL: baseURL,
+		httpClient: &http.Client{
+			Timeout: 30 * time.Second,
+		},
+	}
+}
+
+func (c *RedpandaSchemaRegistryClient) RegisterSchema(subject string, version int, schema string) error {
+	// Schema must be properly escaped as a JSON string
+	// Create the schema registration payload with properly escaped JSON
+	payload := map[string]interface{}{
+		"schema":     schema,
+		"schemaType": "JSON",
+	}
+
+	payloadBytes, err := json.Marshal(payload)
+	if err != nil {
+		return fmt.Errorf("failed to marshal schema payload: %w", err)
+	}
+
+	// Register the schema with a specific version
+	url := fmt.Sprintf("%s/subjects/%s/versions", c.baseURL, subject)
+	req, err := http.NewRequest("POST", url, bytes.NewBuffer(payloadBytes))
+	if err != nil {
+		return fmt.Errorf("failed to create request: %w", err)
+	}
+
+	req.Header.Set("Content-Type", "application/vnd.schemaregistry.v1+json")
+
+	resp, err := c.httpClient.Do(req)
+	if err != nil {
+		return fmt.Errorf("failed to register schema: %w", err)
+	}
+	defer resp.Body.Close()
+
+	if resp.StatusCode != 200 && resp.StatusCode != 201 {
+		// Read response body for debugging
+		bodyBytes := make([]byte, 1024)
+		resp.Body.Read(bodyBytes)
+		return fmt.Errorf("schema registration failed with status %d, body: %s", resp.StatusCode, string(bodyBytes))
+	}
+
+	return nil
+}
+
+func (c *RedpandaSchemaRegistryClient) WaitForReady() error {
+	ready := false
+	Eventually(func() bool {
+		resp, err := c.httpClient.Get(c.baseURL + "/subjects")
+		if err == nil && resp.StatusCode == 200 {
+			resp.Body.Close()
+			ready = true
+			return true
+		}
+		if resp != nil {
+			resp.Body.Close()
+		}
+		return false
+	}, "60s", "2s").Should(BeTrue(), "Schema registry should be ready")
+
+	if !ready {
+		return fmt.Errorf("schema registry not ready after timeout")
+	}
+	return nil
+}
+
+func (c *RedpandaSchemaRegistryClient) DeleteAllSubjects() error {
+	// Get all subjects
+	resp, err := c.httpClient.Get(c.baseURL + "/subjects")
+	if err != nil {
+		return fmt.Errorf("failed to get subjects: %w", err)
+	}
+	defer resp.Body.Close()
+
+	if resp.StatusCode != 200 {
+		return fmt.Errorf("failed to get subjects, status: %d", resp.StatusCode)
+	}
+
+	var subjects []string
+	if err := json.NewDecoder(resp.Body).Decode(&subjects); err != nil {
+		return fmt.Errorf("failed to decode subjects: %w", err)
+	}
+
+	// Delete each subject (hard delete)
+	for _, subject := range subjects {
+		// First do a soft delete
+		req, err := http.NewRequest("DELETE", c.baseURL+"/subjects/"+subject, nil)
+		if err != nil {
+			continue
+		}
+		resp, err := c.httpClient.Do(req)
+		if err != nil {
+			continue
+		}
+		resp.Body.Close()
+
+		// Then do a hard delete to permanently remove
+		req, err = http.NewRequest("DELETE", c.baseURL+"/subjects/"+subject+"?permanent=true", nil)
+		if err != nil {
+			continue
+		}
+		resp, err = c.httpClient.Do(req)
+		if err != nil {
+			continue
+		}
+		resp.Body.Close()
+	}
+
+	return nil
+}
+
+func cleanupRedpandaContainer() {
+	// Kill and remove any existing container with our name
+	exec.Command("docker", "kill", redpandaContainerName).Run()
+	exec.Command("docker", "rm", "-f", redpandaContainerName).Run()
+
+	// Wait for container to be removed completely
+	Eventually(func() bool {
+		cmd := exec.Command("docker", "ps", "-a", "-q", "--filter", fmt.Sprintf("name=%s", redpandaContainerName))
+		output, err := cmd.Output()
+		return err != nil || len(output) == 0
+	}, "15s", "1s").Should(BeTrue(), "Container should be removed completely")
+}
+
+func startRedpandaContainer() error {
+	// Clean up any existing container first
+	cleanupRedpandaContainer()
+
+	// Start Redpanda container
+	cmd := exec.Command("docker", "run", "-d",
+		"--name", redpandaContainerName,
+		"-p", fmt.Sprintf("%s:9092", redpandaKafkaPort),
+		"-p", fmt.Sprintf("%s:8081", redpandaSchemaRegistryPort),
+		"-p", "8082:8082",
+		"-p", "9644:9644",
+		"redpandadata/redpanda:latest",
+		"redpanda", "start",
+		"--overprovisioned",
+		"--smp", "1",
+		"--memory", "1G",
+		"--reserve-memory", "0M",
+		"--node-id", "0",
+		"--check=false")
+
+	output, err := cmd.CombinedOutput()
+	if err != nil {
+		return fmt.Errorf("failed to start Redpanda container: %w, output: %s", err, string(output))
+	}
+
+	// Wait for Redpanda to actually start up successfully
+	redpandaStarted := false
+	Eventually(func() bool {
+		// Check container logs for successful startup message
+		logsCmd := exec.Command("docker", "logs", redpandaContainerName)
+		logsOutput, err := logsCmd.CombinedOutput()
+		if err != nil {
+			return false
+		}
+
+		logsStr := string(logsOutput)
+		if strings.Contains(logsStr, "Successfully started Redpanda!") {
+			redpandaStarted = true
+			return true
+		}
+
+		return false
+	}, "60s", "2s").Should(BeTrue(), "Redpanda should start successfully")
+
+	if !redpandaStarted {
+		// On failure, dump full logs for debugging
+		logsCmd := exec.Command("docker", "logs", redpandaContainerName)
+		logsOutput, _ := logsCmd.CombinedOutput()
+		return fmt.Errorf("Redpanda failed to start within timeout. Full logs:\n%s", string(logsOutput))
+	}
+
+	return nil
+}
+
+func setupRedpandaSchemas() error {
+	client := NewRedpandaSchemaRegistryClient(redpandaSchemaRegistryURL)
+
+	// Wait for schema registry to be ready
+	if err := client.WaitForReady(); err != nil {
+		return fmt.Errorf("schema registry not ready: %w", err)
+	}
+
+	// Clean up any existing schemas first
+	if err := client.DeleteAllSubjects(); err != nil {
+		return fmt.Errorf("failed to cleanup existing schemas: %w", err)
+	}
+
+	// Wait for schemas to be fully removed
+	Eventually(func() bool {
+		resp, err := client.httpClient.Get(client.baseURL + "/subjects")
+		if err != nil {
+			return false
+		}
+		defer resp.Body.Close()
+
+		if resp.StatusCode != 200 {
+			return false
+		}
+
+		var subjects []string
+		if err := json.NewDecoder(resp.Body).Decode(&subjects); err != nil {
+			return false
+		}
+
+		return len(subjects) == 0
+	}, "10s", "500ms").Should(BeTrue(), "Schemas should be fully removed after cleanup")
+
+	// Register all test schemas in version order
+	for subject, versions := range redpandaTestSchemas {
+		// Get versions in sorted order to ensure consistent registration
+		var sortedVersions []int
+		for version := range versions {
+			sortedVersions = append(sortedVersions, version)
+		}
+
+		// Sort versions to ensure we register in ascending order
+		sort.Ints(sortedVersions)
+
+		for _, version := range sortedVersions {
+			schema := versions[version]
+			if err := client.RegisterSchema(subject, version, schema); err != nil {
+				return fmt.Errorf("failed to register schema %s v%d: %w", subject, version, err)
+			}
+		}
+	}
+
+	return nil
+}
+
+var _ = Describe("Real Redpanda Integration Tests", Ordered, Label("redpanda"), func() {
+	var validator *Validator
+
+	BeforeAll(func() {
+		// Skip if Docker is not available
+		if _, err := exec.LookPath("docker"); err != nil {
+			Skip("Docker not available, skipping Redpanda integration tests")
+		}
+
+		// Check if Docker daemon is running
+		if err := exec.Command("docker", "info").Run(); err != nil {
+			Skip("Docker daemon not running, skipping Redpanda integration tests")
+		}
+
+		By("Starting Redpanda container")
+		Expect(startRedpandaContainer()).To(Succeed())
+
+		By("Setting up test schemas in Redpanda")
+		Expect(setupRedpandaSchemas()).To(Succeed())
+
+		By("Creating validator with real schema registry")
+		validator = NewValidatorWithRegistry(redpandaSchemaRegistryURL)
+		Expect(validator).NotTo(BeNil())
+		Expect(validator.backgroundFetcher).NotTo(BeNil())
+	})
+
+	AfterAll(func() {
+		if validator != nil {
+			validator.Close()
+		}
+
+		By("Cleaning up Redpanda container")
+		cleanupRedpandaContainer()
+	})
+
+	Context("when validating against real Redpanda schema registry", Ordered, func() {
+		It("should successfully validate sensor data v1", func() {
+			// Create UNS topic with unique suffix
+			contractName := "_sensor_data"
+			unsTopic, err := topic.NewUnsTopic(fmt.Sprintf("umh.v1.enterprise.site.area.%s-v1.temperature", contractName))
+			Expect(err).To(BeNil())
+
+			// Create valid payload
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			// First validation should trigger background fetch
+			result := validator.Validate(unsTopic, payload)
+			GinkgoWriter.Printf("First validation result: SchemaCheckPassed=%v, SchemaCheckBypassed=%v, BypassReason=%s, Error=%v\n",
+				result.SchemaCheckPassed, result.SchemaCheckBypassed, result.BypassReason, result.Error)
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+			Expect(result.BypassReason).To(ContainSubstring(fmt.Sprintf("schema for contract '%s' version 1 not found", contractName)))
+
+			// Manually trigger background fetch to ensure it happens
+			if validator.backgroundFetcher != nil {
+				validator.backgroundFetcher.processFetchQueue()
+			}
+
+			// Wait for schema to be loaded and validation to pass
+			Eventually(func() bool {
+				result = validator.Validate(unsTopic, payload)
+				GinkgoWriter.Printf("Validation result: SchemaCheckPassed=%v, SchemaCheckBypassed=%v, BypassReason=%s, Error=%v\n",
+					result.SchemaCheckPassed, result.SchemaCheckBypassed, result.BypassReason, result.Error)
+				return result.SchemaCheckPassed && !result.SchemaCheckBypassed
+			}, "10s", "500ms").Should(BeTrue(), "Schema should be loaded and validation should pass")
+
+			// Check if schema was loaded
+			hasSchema := validator.HasSchema(contractName, 1)
+			GinkgoWriter.Printf("Has schema %s v1: %v\n", contractName, hasSchema)
+
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(BeNil())
+			Expect(result.ContractName).To(Equal(contractName))
+			Expect(result.ContractVersion).To(Equal(uint64(1)))
+		})
+
+		It("should reject invalid virtual path for sensor data v1", func() {
+			// Load schema first by validating a valid message
+			validTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+			validPayload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			// Trigger schema load if not already loaded
+			Eventually(func() bool {
+				result := validator.Validate(validTopic, validPayload)
+				return result.SchemaCheckPassed && !result.SchemaCheckBypassed
+			}, "10s", "500ms").Should(BeTrue(), "Schema should be loaded for valid topic")
+
+			// Get the result for further testing
+			result := validator.Validate(validTopic, validPayload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+
+			// Now test invalid virtual path
+			invalidTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.humidity")
+			Expect(err).To(BeNil())
+
+			result = validator.Validate(invalidTopic, validPayload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+			Expect(result.Error.Error()).To(ContainSubstring("schema validation failed"))
+		})
+
+		It("should validate sensor data v2 with expanded virtual paths", func() {
+			// Test temperature (allowed in both v1 and v2)
+			tempTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v2.temperature")
+			Expect(err).To(BeNil())
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			result := validator.Validate(tempTopic, payload)
+			GinkgoWriter.Printf("V2 temperature validation result: SchemaCheckPassed=%v, SchemaCheckBypassed=%v, BypassReason=%s, Error=%v\n",
+				result.SchemaCheckPassed, result.SchemaCheckBypassed, result.BypassReason, result.Error)
+
+			if result.SchemaCheckBypassed {
+				// Manually trigger background fetch to ensure it happens
+				if validator.backgroundFetcher != nil {
+					validator.backgroundFetcher.processFetchQueue()
+				}
+
+				// Wait for schema to be loaded
+				Eventually(func() bool {
+					result = validator.Validate(tempTopic, payload)
+					GinkgoWriter.Printf("V2 temperature validation result: SchemaCheckPassed=%v, SchemaCheckBypassed=%v, BypassReason=%s, Error=%v\n",
+						result.SchemaCheckPassed, result.SchemaCheckBypassed, result.BypassReason, result.Error)
+					return result.SchemaCheckPassed && !result.SchemaCheckBypassed
+				}, "10s", "500ms").Should(BeTrue(), "Schema v2 should be loaded and validation should pass")
+			}
+
+			// Check if schema was loaded
+			hasSchema := validator.HasSchema("_sensor_data", 2)
+			GinkgoWriter.Printf("Has schema _sensor_data v2: %v\n", hasSchema)
+
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.ContractVersion).To(Equal(uint64(2)))
+
+			// Test humidity (allowed in v2 but not v1)
+			humidityTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v2.humidity")
+			Expect(err).To(BeNil())
+
+			result = validator.Validate(humidityTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.ContractVersion).To(Equal(uint64(2)))
+
+			// Test pressure (allowed in v2 but not v1)
+			pressureTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v2.pressure")
+			Expect(err).To(BeNil())
+			pressurePayload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 1013.25}}`)
+
+			result = validator.Validate(pressureTopic, pressurePayload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.ContractVersion).To(Equal(uint64(2)))
+		})
+
+		It("should validate pump data with complex virtual paths", func() {
+			// Test vibration.x-axis
+			xAxisTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._pump_data-v1.vibration.x-axis")
+			Expect(err).To(BeNil())
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 0.5}}`)
+
+			result := validator.Validate(xAxisTopic, payload)
+			GinkgoWriter.Printf("First pump data validation result: SchemaCheckPassed=%v, SchemaCheckBypassed=%v, BypassReason=%s, Error=%v\n",
+				result.SchemaCheckPassed, result.SchemaCheckBypassed, result.BypassReason, result.Error)
+
+			if result.SchemaCheckBypassed {
+				// Manually trigger background fetch to ensure it happens
+				if validator.backgroundFetcher != nil {
+					validator.backgroundFetcher.processFetchQueue()
+				}
+
+				// Wait for schema to be loaded
+				Eventually(func() bool {
+					result = validator.Validate(xAxisTopic, payload)
+					GinkgoWriter.Printf("Pump data validation result: SchemaCheckPassed=%v, SchemaCheckBypassed=%v, BypassReason=%s, Error=%v\n",
+						result.SchemaCheckPassed, result.SchemaCheckBypassed, result.BypassReason, result.Error)
+					return result.SchemaCheckPassed && !result.SchemaCheckBypassed
+				}, "10s", "500ms").Should(BeTrue(), "Pump data schema should be loaded and validation should pass")
+			}
+
+			// Check if schema was loaded
+			hasSchema := validator.HasSchema("_pump_data", 1)
+			GinkgoWriter.Printf("Has schema _pump_data v1: %v\n", hasSchema)
+
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.ContractName).To(Equal("_pump_data"))
+
+			// Test vibration.y-axis
+			yAxisTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._pump_data-v1.vibration.y-axis")
+			Expect(err).To(BeNil())
+
+			result = validator.Validate(yAxisTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+
+			// Test count
+			countTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._pump_data-v1.count")
+			Expect(err).To(BeNil())
+			countPayload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 1542}}`)
+
+			result = validator.Validate(countTopic, countPayload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+		})
+
+		It("should validate string data types correctly", func() {
+			// Test serialNumber
+			serialTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._string_data-v1.serialNumber")
+			Expect(err).To(BeNil())
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": "SN123456789"}}`)
+
+			Eventually(func() bool {
+				result := validator.Validate(serialTopic, payload)
+				return result.SchemaCheckPassed && !result.SchemaCheckBypassed
+			}, "10s", "500ms").Should(BeTrue(), "String data schema should be loaded and validation should pass")
+
+			result := validator.Validate(serialTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.ContractName).To(Equal("_string_data"))
+
+			// Test status
+			statusTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._string_data-v1.status")
+			Expect(err).To(BeNil())
+			statusPayload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": "RUNNING"}}`)
+
+			result = validator.Validate(statusTopic, statusPayload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+		})
+
+		It("should reject invalid payload formats", func() {
+			// Load schema first
+			validTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+			validPayload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			Eventually(func() bool {
+				result := validator.Validate(validTopic, validPayload)
+				return result.SchemaCheckPassed && !result.SchemaCheckBypassed
+			}, "10s", "500ms").Should(BeTrue(), "Schema should be loaded for invalid payload test")
+
+			result := validator.Validate(validTopic, validPayload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+
+			// Test missing timestamp_ms
+			invalidPayload := []byte(`{"value": {"value": 25.5}}`)
+			result = validator.Validate(validTopic, invalidPayload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+
+			// Test wrong value type
+			invalidPayload = []byte(`{"value": {"timestamp_ms": 1719859200000, "value": "not_a_number"}}`)
+			result = validator.Validate(validTopic, invalidPayload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+		})
+
+		It("should reject wrong data types for string fields", func() {
+			// Load schema first
+			validTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._string_data-v1.serialNumber")
+			Expect(err).To(BeNil())
+			validPayload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": "SN123456789"}}`)
+
+			Eventually(func() bool {
+				result := validator.Validate(validTopic, validPayload)
+				return result.SchemaCheckPassed && !result.SchemaCheckBypassed
+			}, "10s", "500ms").Should(BeTrue(), "String data schema should be loaded for data type test")
+
+			result := validator.Validate(validTopic, validPayload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+
+			// Test providing number instead of string
+			invalidPayload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 12345}}`)
+			result = validator.Validate(validTopic, invalidPayload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+		})
+
+		It("should handle non-existent schemas gracefully", func() {
+			// Test with a contract that doesn't exist
+			nonExistentTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._non_existent_contract-v1.temperature")
+			Expect(err).To(BeNil())
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			result := validator.Validate(nonExistentTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+			Expect(result.BypassReason).To(ContainSubstring("schema for contract '_non_existent_contract' version 1 not found"))
+
+			// Wait for background fetch attempt and verify it still bypasses
+			Eventually(func() bool {
+				result = validator.Validate(nonExistentTopic, payload)
+				return result.SchemaCheckBypassed
+			}, "10s", "500ms").Should(BeTrue(), "Non-existent schema should still bypass after background fetch attempt")
+
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+		})
+
+		It("should handle unversioned contracts gracefully", func() {
+			// Test with an unversioned contract
+			unversionedTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._unversioned_contract.temperature")
+			Expect(err).To(BeNil())
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			result := validator.Validate(unversionedTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+			Expect(result.BypassReason).To(ContainSubstring("unversioned contract '_unversioned_contract' - bypassing validation (no latest fetching)"))
+			Expect(result.Error).To(BeNil())
+		})
+	})
+
+	Context("when testing background fetcher against real registry", func() {
+		It("should automatically fetch schemas in the background", func() {
+			// Create a fresh validator to test background fetching
+			freshValidator := NewValidatorWithRegistry(redpandaSchemaRegistryURL)
+			defer freshValidator.Close()
+
+			// Create topic that will trigger background fetch
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			// First validation should bypass and queue schema for fetch
+			result := freshValidator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+
+			// Wait for automatic background fetching (fetch interval is 5 seconds)
+			Eventually(func() bool {
+				result = freshValidator.Validate(unsTopic, payload)
+				return result.SchemaCheckPassed && !result.SchemaCheckBypassed
+			}, "15s", "1s").Should(BeTrue(), "Background fetcher should automatically fetch and validate schema")
+
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(BeNil())
+		})
+	})
+})
diff --git a/uns_plugin/schema_validation/schema.go b/uns_plugin/schema_validation/schema.go
new file mode 100644
index 0000000..f92536d
--- /dev/null
+++ b/uns_plugin/schema_validation/schema.go
@@ -0,0 +1,93 @@
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Package schemavalidation provides JSON schema validation functionality for UNS topics.
+// It manages schema compilation, versioning, and validation operations with thread-safe access.
+package schemavalidation
+
+import (
+	"fmt"
+	"sync"
+
+	"github.com/kaptinlin/jsonschema"
+)
+
+// Global schema compiler and mutex for thread-safe schema compilation.
+// These are shared across all schema instances to optimize compilation performance.
+var (
+	schemaCompiler      = jsonschema.NewCompiler()
+	schemaCompilerMutex sync.RWMutex
+)
+
+// SchemaVersion represents a compiled JSON schema for a specific version.
+type SchemaVersion struct {
+	JSONSchema *jsonschema.Schema
+}
+
+// SchemaVersions manages multiple versions of a schema.
+type SchemaVersions struct {
+	Versions map[uint64]SchemaVersion
+}
+
+// Schema represents a named schema with multiple versions.
+type Schema struct {
+	Name     string
+	Versions SchemaVersions
+}
+
+// NewSchema creates a new Schema with the given name and initializes an empty version map.
+func NewSchema(name string) *Schema {
+	return &Schema{
+		Name:     name,
+		Versions: SchemaVersions{Versions: make(map[uint64]SchemaVersion)},
+	}
+}
+
+// AddVersion compiles and adds a new schema version to this Schema.
+// It returns an error if schema compilation fails.
+func (s *Schema) AddVersion(version uint64, schema []byte) error {
+	schemaCompilerMutex.Lock()
+	defer schemaCompilerMutex.Unlock()
+
+	compiledSchema, err := schemaCompiler.Compile(schema)
+	if err != nil {
+		return fmt.Errorf("failed to compile schema for version %d: %w", version, err)
+	}
+
+	s.Versions.Versions[version] = SchemaVersion{
+		JSONSchema: compiledSchema,
+	}
+	return nil
+}
+
+// HasVersion checks if a specific version exists and has a valid compiled schema.
+func (s *Schema) HasVersion(version uint64) bool {
+	schemaCompilerMutex.RLock()
+	defer schemaCompilerMutex.RUnlock()
+
+	schemaVersion, exists := s.Versions.Versions[version]
+	return exists && schemaVersion.JSONSchema != nil
+}
+
+// GetVersion retrieves the compiled JSON schema for the specified version.
+// Returns nil if the version doesn't exist.
+func (s *Schema) GetVersion(version uint64) *jsonschema.Schema {
+	schemaCompilerMutex.RLock()
+	defer schemaCompilerMutex.RUnlock()
+
+	if schemaVersion, exists := s.Versions.Versions[version]; exists {
+		return schemaVersion.JSONSchema
+	}
+	return nil
+}
diff --git a/uns_plugin/schema_validation/schema_validation_suite_test.go b/uns_plugin/schema_validation/schema_validation_suite_test.go
new file mode 100644
index 0000000..69b8317
--- /dev/null
+++ b/uns_plugin/schema_validation/schema_validation_suite_test.go
@@ -0,0 +1,27 @@
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package schemavalidation_test
+
+import (
+	"testing"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+)
+
+func TestSchemaValidation(t *testing.T) {
+	RegisterFailHandler(Fail)
+	RunSpecs(t, "SchemaValidation Suite")
+}
diff --git a/uns_plugin/schema_validation/validator.go b/uns_plugin/schema_validation/validator.go
new file mode 100644
index 0000000..54f37b7
--- /dev/null
+++ b/uns_plugin/schema_validation/validator.go
@@ -0,0 +1,268 @@
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package schemavalidation
+
+import (
+	"fmt"
+	"regexp"
+	"strconv"
+	"strings"
+	"sync"
+
+	"github.com/united-manufacturing-hub/benthos-umh/pkg/umh/topic"
+)
+
+// schemaVersionRegex matches data contract names with version suffixes.
+// Expected format: "contractname-v123" where 123 is the version number.
+var schemaVersionRegex = regexp.MustCompile(`^(.+)-v(\d+)$`)
+
+// ValidationResult contains information about the validation result and the contract used.
+type ValidationResult struct {
+	// SchemaCheckPassed indicates whether the schema validation passed
+	SchemaCheckPassed bool
+	// SchemaCheckBypassed indicates whether the schema validation was bypassed
+	SchemaCheckBypassed bool
+	// ContractName is the name of the contract that was validated against
+	ContractName string
+	// ContractVersion is the version of the contract that was validated against
+	ContractVersion uint64
+	// BypassReason indicates why validation was bypassed (empty if not bypassed)
+	BypassReason string
+	// Error contains the validation error if validation failed
+	Error error
+}
+
+// Validator manages schema validation for UNS topics with thread-safe operations.
+type Validator struct {
+	schemas           map[string]*Schema
+	schemasMutex      sync.RWMutex
+	schemaRegistryURL string
+	backgroundFetcher *BackgroundFetcher
+}
+
+// NewValidator creates a new Validator instance with an empty schema registry.
+func NewValidator() *Validator {
+	return &Validator{
+		schemas: make(map[string]*Schema),
+	}
+}
+
+// NewValidatorWithRegistry creates a new Validator instance with the specified schema registry URL.
+func NewValidatorWithRegistry(schemaRegistryURL string) *Validator {
+	validator := &Validator{
+		schemas:           make(map[string]*Schema),
+		schemaRegistryURL: schemaRegistryURL,
+	}
+
+	// If a schema registry URL is provided, start the background fetcher
+	if schemaRegistryURL != "" {
+		validator.backgroundFetcher = NewBackgroundFetcher(schemaRegistryURL, validator)
+		validator.backgroundFetcher.Start()
+	}
+
+	return validator
+}
+
+// Validate validates the given UNS topic and payload against the registered schema.
+// It extracts the contract and version from the topic, finds the appropriate schema,
+// and validates the payload structure. Returns a ValidationResult with contract information.
+func (v *Validator) Validate(unsTopic *topic.UnsTopic, payload []byte) *ValidationResult {
+	if unsTopic == nil {
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: false,
+			Error:               fmt.Errorf("UNS topic cannot be nil"),
+		}
+	}
+
+	v.schemasMutex.RLock()
+	defer v.schemasMutex.RUnlock()
+
+	topicInfo := unsTopic.Info()
+	if topicInfo == nil {
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: false,
+			Error:               fmt.Errorf("topic info is nil"),
+		}
+	}
+
+	contract := topicInfo.DataContract
+	if contract == "" {
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: false,
+			Error:               fmt.Errorf("data contract is empty"),
+		}
+	}
+
+	contractName, version, err := v.ExtractSchemaVersionFromDataContract(contract)
+	if err != nil {
+		// For unversioned contracts, always bypass (no fetching of "latest")
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: true,
+			ContractName:        contract, // Use the original contract string as fallback
+			ContractVersion:     0,
+			BypassReason:        fmt.Sprintf("unversioned contract '%s' - bypassing validation (no latest fetching)", contract),
+			Error:               nil,
+		}
+	}
+
+	if !v.HasSchema(contractName, version) {
+		// Queue the schema for background fetching if we have a background fetcher
+		if v.backgroundFetcher != nil {
+			v.backgroundFetcher.QueueSchema(contractName, version)
+		}
+
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: true,
+			ContractName:        contractName,
+			ContractVersion:     version,
+			BypassReason:        fmt.Sprintf("schema for contract '%s' version %d not found, queued for background fetch", contractName, version),
+			Error:               nil,
+		}
+	}
+
+	schema := v.schemas[contractName].GetVersion(version)
+	if schema == nil {
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: true,
+			ContractName:        contractName,
+			ContractVersion:     version,
+			BypassReason:        fmt.Sprintf("schema for contract '%s' version %d is nil", contractName, version),
+			Error:               nil,
+		}
+	}
+
+	// Build the full path for validation
+	var fullPath strings.Builder
+	if topicInfo.VirtualPath != nil {
+		fullPath.WriteString(*topicInfo.VirtualPath)
+		fullPath.WriteString(".")
+	}
+	fullPath.WriteString(topicInfo.Name)
+
+	// Wrap the payload with fields and virtual_path for validation
+	wrappedPayload := []byte(fmt.Sprintf(`{"fields": %s, "virtual_path": "%s"}`,
+		string(payload), fullPath.String()))
+
+	validationResult := schema.ValidateJSON(wrappedPayload)
+	if validationResult == nil {
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: false,
+			ContractName:        contractName,
+			ContractVersion:     version,
+			Error:               fmt.Errorf("schema validation result is nil"),
+		}
+	}
+
+	if !validationResult.Valid {
+		var validationErrors []string
+		for _, validationErr := range validationResult.Errors {
+			validationErrors = append(validationErrors, validationErr.Error())
+		}
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: false,
+			ContractName:        contractName,
+			ContractVersion:     version,
+			Error: fmt.Errorf("schema validation failed for contract '%s' version %d: %s",
+				contractName, version, strings.Join(validationErrors, "; ")),
+		}
+	}
+
+	return &ValidationResult{
+		SchemaCheckPassed:   true,
+		SchemaCheckBypassed: false,
+		ContractName:        contractName,
+		ContractVersion:     version,
+		Error:               nil,
+	}
+}
+
+// ExtractSchemaVersionFromDataContract parses a data contract string to extract
+// the base contract name and version number.
+// Expected format: "contractname-v123" -> ("contractname", 123, nil)
+func (v *Validator) ExtractSchemaVersionFromDataContract(contract string) (contractName string, version uint64, err error) {
+	if contract == "" {
+		return "", 0, fmt.Errorf("contract string is empty")
+	}
+
+	matches := schemaVersionRegex.FindStringSubmatch(contract)
+	if len(matches) != 3 {
+		return "", 0, fmt.Errorf("invalid data contract format '%s', expected format: 'name-v123'", contract)
+	}
+
+	contractName = matches[1]
+	version, err = strconv.ParseUint(matches[2], 10, 64)
+	if err != nil {
+		return "", 0, fmt.Errorf("invalid version number '%s' in contract '%s': %w", matches[2], contract, err)
+	}
+
+	return contractName, version, nil
+}
+
+// LoadSchema loads and compiles a schema for the specified contract name and version.
+// The contract name must start with an underscore for easier topic matching.
+func (v *Validator) LoadSchema(contractName string, version uint64, schema []byte) error {
+	if contractName == "" {
+		return fmt.Errorf("contract name cannot be empty")
+	}
+
+	if !strings.HasPrefix(contractName, "_") {
+		return fmt.Errorf("contract name must start with an underscore, got: '%s'", contractName)
+	}
+
+	if len(schema) == 0 {
+		return fmt.Errorf("schema cannot be empty for contract '%s' version %d", contractName, version)
+	}
+
+	v.schemasMutex.Lock()
+	defer v.schemasMutex.Unlock()
+
+	if _, exists := v.schemas[contractName]; !exists {
+		v.schemas[contractName] = NewSchema(contractName)
+	}
+
+	if err := v.schemas[contractName].AddVersion(version, schema); err != nil {
+		return fmt.Errorf("failed to add schema version %d for contract '%s': %w", version, contractName, err)
+	}
+
+	return nil
+}
+
+// HasSchema checks if a schema exists for the given contract name and version.
+func (v *Validator) HasSchema(contractName string, version uint64) bool {
+	v.schemasMutex.RLock()
+	defer v.schemasMutex.RUnlock()
+
+	schema, exists := v.schemas[contractName]
+	if !exists {
+		return false
+	}
+
+	return schema.HasVersion(version)
+}
+
+// Close stops the background fetcher and cleans up resources.
+func (v *Validator) Close() {
+	if v.backgroundFetcher != nil {
+		v.backgroundFetcher.Stop()
+	}
+}
diff --git a/uns_plugin/schema_validation/validator_benchmark_test.go b/uns_plugin/schema_validation/validator_benchmark_test.go
new file mode 100644
index 0000000..aa1cdab
--- /dev/null
+++ b/uns_plugin/schema_validation/validator_benchmark_test.go
@@ -0,0 +1,410 @@
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*
+Package schemavalidation provides comprehensive benchmarks for UNS schema validation performance.
+
+## Benchmark Results
+
+Performance testing was conducted on Apple M3 Pro to ensure the validator meets the target of 1,000 validations per second.
+
+### Latest Results (Updated with ValidationResult structure and fail-open behavior):
+
+```
+goos: darwin
+goarch: arm64
+pkg: github.com/united-manufacturing-hub/benthos-umh/uns_plugin/schema_validation
+cpu: Apple M3 Pro
+BenchmarkValidation_SingleThread-11                       273523              4422 ns/op            5250 B/op        117 allocs/op
+BenchmarkValidation_Concurrent-11                         622438              1690 ns/op            5203 B/op        117 allocs/op
+BenchmarkValidation_HighThroughput-11                     637519              1631 ns/op            5187 B/op        117 allocs/op
+BenchmarkValidation_RealWorld-11                         1462032               806.9 ns/op          2467 B/op         53 allocs/op
+BenchmarkValidation_MemoryUsage-11                        255853              4479 ns/op            5252 B/op        118 allocs/op
+BenchmarkValidation_DifferentPayloadSizes/PayloadSize_57_bytes-11                 263476              4548 ns/op            5284 B/op        118 allocs/op
+BenchmarkValidation_DifferentPayloadSizes/PayloadSize_65_bytes-11                 261116              4578 ns/op            5298 B/op        118 allocs/op
+BenchmarkValidation_DifferentPayloadSizes/PayloadSize_67_bytes-11                 257691              4558 ns/op            5296 B/op        118 allocs/op
+BenchmarkConcurrentValidation_ScalabilityTest/Goroutines_1-11                     260972              4507 ns/op            5269 B/op        118 allocs/op
+BenchmarkConcurrentValidation_ScalabilityTest/Goroutines_2-11                     413632              2959 ns/op            5376 B/op        118 allocs/op
+BenchmarkConcurrentValidation_ScalabilityTest/Goroutines_4-11                     555212              2063 ns/op            5389 B/op        118 allocs/op
+BenchmarkConcurrentValidation_ScalabilityTest/Goroutines_8-11                     644684              1749 ns/op            5239 B/op        118 allocs/op
+BenchmarkConcurrentValidation_ScalabilityTest/Goroutines_16-11                    665073              1557 ns/op            5178 B/op        118 allocs/op
+BenchmarkConcurrentValidation_ScalabilityTest/Goroutines_32-11                    701659              1611 ns/op            5173 B/op        118 allocs/op
+```
+
+### Performance Analysis:
+
+**Target Achievement:** ✅ **All benchmarks significantly exceed the 1,000 validations/second target**
+
+- **Single-threaded**: 273,523 ops/sec (273x faster than target)
+- **Concurrent**: 622,438 ops/sec (622x faster than target)
+- **High-throughput**: 637,519 ops/sec (637x faster than target)
+- **Real-world mixed**: 1,462,032 ops/sec (1,462x faster than target)
+
+**Memory Efficiency:**
+- **Latency**: 0.81-4.58 μs per validation
+- **Memory**: ~5KB per operation, 117-118 allocations
+- **Scalability**: Excellent performance scaling up to 32 goroutines (2.8x improvement)
+
+**Payload Size Impact:**
+- **Minimal variance**: 4.55-4.58 μs regardless of payload size (57-67 bytes)
+- **Consistent memory**: ~5.3KB per operation across all payload sizes
+
+**Concurrent Scalability:**
+- **1 goroutine**: 4,507 ns/op (222k ops/sec)
+- **32 goroutines**: 1,611 ns/op (621k ops/sec)
+- **Scaling efficiency**: 2.8x improvement with 32x goroutines
+
+### Impact of ValidationResult Structure Changes:
+
+**Performance Impact**: ✅ **Minimal performance impact from fail-open behavior**
+- **Enhanced metadata**: `SchemaCheckPassed`, `SchemaCheckBypassed`, `BypassReason`
+- **Contract tracking**: Full contract name and version information
+- **Bypass tracking**: Detailed reasons for validation bypasses
+- **Fail-open behavior**: Messages pass through when schemas are missing
+
+**New Features:**
+- **Dual boolean flags**: Clear distinction between passed/failed vs bypassed validation
+- **Comprehensive error handling**: Detailed error messages for debugging
+- **Metadata enrichment**: Contract information available for downstream processing
+- **Operational resilience**: System continues operating when schemas are unavailable
+
+### Recommendations:
+
+1. **Production Ready**: Performance easily handles production loads with fail-open safety
+2. **Concurrent Usage**: Optimal performance with 16-32 goroutines
+3. **Memory Stable**: Consistent memory usage across scenarios
+4. **Payload Agnostic**: Performance independent of payload size variations
+5. **Reliable Operation**: Fail-open behavior ensures data continuity
+
+*/
+
+package schemavalidation
+
+import (
+	"fmt"
+	"sync"
+	"testing"
+
+	"github.com/united-manufacturing-hub/benthos-umh/pkg/umh/topic"
+)
+
+// setupBenchmarkValidator creates a validator with pre-loaded schemas for benchmarking
+func setupBenchmarkValidator() *Validator {
+	validator := NewValidator()
+
+	// Use the exact same schema format as validator_test.go
+	sensorSchema := []byte(`{
+		"type": "object",
+		"properties": {
+			"virtual_path": {
+				"type": "string",
+				"enum": ["vibration.x-axis", "temperature", "humidity", "pressure"]
+			},
+			"fields": {
+				"type": "object",
+				"properties": {
+					"value": {
+						"type": "object",
+						"properties": {
+							"timestamp_ms": {"type": "number"},
+							"value": {"type": "number"}
+						},
+						"required": ["timestamp_ms", "value"],
+						"additionalProperties": false
+					}
+				},
+				"additionalProperties": false
+			}
+		},
+		"required": ["virtual_path", "fields"],
+		"additionalProperties": false
+	}`)
+
+	// Load the schema
+	validator.LoadSchema("_sensor_data", 1, sensorSchema)
+
+	return validator
+}
+
+// Test payloads for benchmarking
+var (
+	validNumberPayload = []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+	validZeroPayload   = []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 0}}`)
+	validLargePayload  = []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 999999999.999}}`)
+)
+
+// BenchmarkValidation_SingleThread measures single-threaded validation performance
+func BenchmarkValidation_SingleThread(b *testing.B) {
+	validator := setupBenchmarkValidator()
+
+	topics := []string{
+		"umh.v1.enterprise.site.area._sensor_data-v1.vibration.x-axis",
+		"umh.v1.enterprise.site.area._sensor_data-v1.temperature",
+		"umh.v1.enterprise.site.area._sensor_data-v1.humidity",
+		"umh.v1.enterprise.site.area._sensor_data-v1.pressure",
+	}
+
+	payloads := [][]byte{validNumberPayload, validZeroPayload, validLargePayload}
+
+	// Pre-create topic objects to avoid topic parsing overhead in benchmark
+	topicObjects := make([]*topic.UnsTopic, len(topics))
+	for i, topicStr := range topics {
+		topicObj, err := topic.NewUnsTopic(topicStr)
+		if err != nil {
+			b.Fatalf("Failed to create topic %s: %v", topicStr, err)
+		}
+		topicObjects[i] = topicObj
+	}
+
+	b.ResetTimer()
+	b.ReportAllocs()
+
+	for i := 0; i < b.N; i++ {
+		topicObj := topicObjects[i%len(topicObjects)]
+		payload := payloads[i%len(payloads)]
+
+		result := validator.Validate(topicObj, payload)
+		if !result.SchemaCheckPassed && !result.SchemaCheckBypassed {
+			b.Fatalf("Validation failed: %v", result.Error)
+		}
+	}
+}
+
+// BenchmarkValidation_Concurrent measures concurrent validation performance
+func BenchmarkValidation_Concurrent(b *testing.B) {
+	validator := setupBenchmarkValidator()
+
+	topics := []string{
+		"umh.v1.enterprise.site.area._sensor_data-v1.vibration.x-axis",
+		"umh.v1.enterprise.site.area._sensor_data-v1.temperature",
+		"umh.v1.enterprise.site.area._sensor_data-v1.humidity",
+		"umh.v1.enterprise.site.area._sensor_data-v1.pressure",
+	}
+
+	payloads := [][]byte{validNumberPayload, validZeroPayload, validLargePayload}
+
+	// Pre-create topic objects
+	topicObjects := make([]*topic.UnsTopic, len(topics))
+	for i, topicStr := range topics {
+		topicObj, err := topic.NewUnsTopic(topicStr)
+		if err != nil {
+			b.Fatalf("Failed to create topic %s: %v", topicStr, err)
+		}
+		topicObjects[i] = topicObj
+	}
+
+	b.ResetTimer()
+	b.ReportAllocs()
+
+	b.RunParallel(func(pb *testing.PB) {
+		i := 0
+		for pb.Next() {
+			topicObj := topicObjects[i%len(topicObjects)]
+			payload := payloads[i%len(payloads)]
+
+			result := validator.Validate(topicObj, payload)
+			if !result.SchemaCheckPassed && !result.SchemaCheckBypassed {
+				b.Fatalf("Validation failed: %v", result.Error)
+			}
+			i++
+		}
+	})
+}
+
+// BenchmarkValidation_HighThroughput simulates high-throughput scenarios
+func BenchmarkValidation_HighThroughput(b *testing.B) {
+	validator := setupBenchmarkValidator()
+
+	// Create topic variety using only valid schema combinations
+	topics := make([]*topic.UnsTopic, 0, 20)
+	tagNames := []string{"vibration.x-axis", "temperature", "humidity", "pressure"}
+
+	for _, tagName := range tagNames {
+		topicStr := fmt.Sprintf("umh.v1.enterprise.site.area._sensor_data-v1.%s", tagName)
+		topicObj, err := topic.NewUnsTopic(topicStr)
+		if err == nil {
+			topics = append(topics, topicObj)
+		}
+	}
+
+	if len(topics) == 0 {
+		b.Fatal("No valid topics created")
+	}
+
+	payloads := [][]byte{validNumberPayload, validZeroPayload, validLargePayload}
+
+	b.ResetTimer()
+	b.ReportAllocs()
+
+	b.RunParallel(func(pb *testing.PB) {
+		i := 0
+		for pb.Next() {
+			topicObj := topics[i%len(topics)]
+			payload := payloads[i%len(payloads)]
+
+			validator.Validate(topicObj, payload) // Don't fail on validation errors in high throughput test
+			i++
+		}
+	})
+}
+
+// BenchmarkValidation_RealWorld simulates real-world mixed scenarios
+func BenchmarkValidation_RealWorld(b *testing.B) {
+	validator := setupBenchmarkValidator()
+
+	// Mix of valid and invalid scenarios (90% valid, 10% invalid)
+	scenarios := []struct {
+		topicStr string
+		payload  []byte
+		valid    bool
+	}{
+		// Valid scenarios (90%)
+		{"umh.v1.enterprise.site.area._sensor_data-v1.temperature", validNumberPayload, true},
+		{"umh.v1.enterprise.site.area._sensor_data-v1.humidity", validNumberPayload, true},
+		{"umh.v1.enterprise.site.area._sensor_data-v1.pressure", validNumberPayload, true},
+		{"umh.v1.enterprise.site.area._pump_data-v1.count", validNumberPayload, true},
+		{"umh.v1.enterprise.site.area._pump_data-v1.vibration.x-axis", validNumberPayload, true},
+		{"umh.v1.enterprise.site.area._pump_data-v1.vibration.y-axis", validNumberPayload, true},
+		{"umh.v1.enterprise.site.area._pump_data-v1.serialNumber", validNumberPayload, true},
+		{"umh.v1.enterprise.site.area._motor_data-v1.temperature", validNumberPayload, true},
+		{"umh.v1.enterprise.site.area._sensor_data-v2.temperature", validNumberPayload, true},
+		// Invalid scenarios (10%)
+		{"umh.v1.enterprise.site.area._sensor_data-v1.invalid_tag", validNumberPayload, false},
+	}
+
+	// Pre-create topic objects for valid scenarios
+	topicObjects := make([]*topic.UnsTopic, len(scenarios))
+	for i, scenario := range scenarios {
+		if scenario.valid {
+			topicObj, err := topic.NewUnsTopic(scenario.topicStr)
+			if err != nil {
+				b.Fatalf("Failed to create topic %s: %v", scenario.topicStr, err)
+			}
+			topicObjects[i] = topicObj
+		}
+	}
+
+	b.ResetTimer()
+	b.ReportAllocs()
+
+	b.RunParallel(func(pb *testing.PB) {
+		i := 0
+		for pb.Next() {
+			scenario := scenarios[i%len(scenarios)]
+
+			if scenario.valid {
+				topicObj := topicObjects[i%len(scenarios)]
+				if topicObj != nil {
+					validator.Validate(topicObj, scenario.payload)
+				}
+			} else {
+				// For invalid scenarios, create topic on-the-fly (performance penalty expected)
+				topicObj, err := topic.NewUnsTopic(scenario.topicStr)
+				if err == nil {
+					validator.Validate(topicObj, scenario.payload)
+				}
+			}
+			i++
+		}
+	})
+}
+
+// BenchmarkValidation_MemoryUsage measures memory allocations per validation
+func BenchmarkValidation_MemoryUsage(b *testing.B) {
+	validator := setupBenchmarkValidator()
+
+	topicObj, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+	if err != nil {
+		b.Fatalf("Failed to create topic: %v", err)
+	}
+
+	b.ResetTimer()
+	b.ReportAllocs()
+
+	for i := 0; i < b.N; i++ {
+		result := validator.Validate(topicObj, validNumberPayload)
+		if !result.SchemaCheckPassed && !result.SchemaCheckBypassed {
+			b.Fatalf("Validation failed: %v", result.Error)
+		}
+	}
+}
+
+// BenchmarkValidation_DifferentPayloadSizes tests with various payload sizes
+func BenchmarkValidation_DifferentPayloadSizes(b *testing.B) {
+	validator := setupBenchmarkValidator()
+
+	topicObj, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+	if err != nil {
+		b.Fatalf("Failed to create topic: %v", err)
+	}
+
+	// Different payload sizes
+	payloads := [][]byte{
+		// Small payload
+		[]byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`),
+		// Medium payload with more precision
+		[]byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.123456789}}`),
+		// Large payload with scientific notation
+		[]byte(`{"value": {"timestamp_ms": 1719859200000, "value": 1.23456789e+10}}`),
+	}
+
+	for _, payload := range payloads {
+		b.Run(fmt.Sprintf("PayloadSize_%d_bytes", len(payload)), func(b *testing.B) {
+			b.ResetTimer()
+			b.ReportAllocs()
+
+			for j := 0; j < b.N; j++ {
+				result := validator.Validate(topicObj, payload)
+				if !result.SchemaCheckPassed && !result.SchemaCheckBypassed {
+					b.Fatalf("Validation failed: %v", result.Error)
+				}
+			}
+		})
+	}
+}
+
+// BenchmarkConcurrentValidation_ScalabilityTest tests scalability with different goroutine counts
+func BenchmarkConcurrentValidation_ScalabilityTest(b *testing.B) {
+	validator := setupBenchmarkValidator()
+
+	topicObj, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+	if err != nil {
+		b.Fatalf("Failed to create topic: %v", err)
+	}
+
+	// Test with different numbers of goroutines
+	goroutineCounts := []int{1, 2, 4, 8, 16, 32}
+
+	for _, numGoroutines := range goroutineCounts {
+		b.Run(fmt.Sprintf("Goroutines_%d", numGoroutines), func(b *testing.B) {
+			b.ResetTimer()
+			b.ReportAllocs()
+
+			var wg sync.WaitGroup
+			validationsPerGoroutine := b.N / numGoroutines
+
+			for i := 0; i < numGoroutines; i++ {
+				wg.Add(1)
+				go func() {
+					defer wg.Done()
+					for j := 0; j < validationsPerGoroutine; j++ {
+						validator.Validate(topicObj, validNumberPayload)
+					}
+				}()
+			}
+
+			wg.Wait()
+		})
+	}
+}
diff --git a/uns_plugin/schema_validation/validator_test.go b/uns_plugin/schema_validation/validator_test.go
new file mode 100644
index 0000000..d2fdf3b
--- /dev/null
+++ b/uns_plugin/schema_validation/validator_test.go
@@ -0,0 +1,633 @@
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package schemavalidation
+
+import (
+	"fmt"
+	"sync"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+	"github.com/united-manufacturing-hub/benthos-umh/pkg/umh/topic"
+)
+
+var _ = Describe("Validator", func() {
+	Context("when validating basic data", func() {
+
+		schema := []byte(`
+		{
+   "type": "object",
+   "properties": {
+		"virtual_path": {
+          "type": "string",
+          "enum": ["vibration.x-axis"]
+       },
+      "fields": {
+         "type": "object",
+         "properties": {
+            "value": {
+               "type": "object",
+               "properties": {
+                  "timestamp_ms": {"type": "number"},
+                  "value": {"type": "number"}
+               },
+               "required": ["timestamp_ms", "value"],
+               "additionalProperties": false
+            }
+         },
+         "additionalProperties": false
+      }
+   },
+   "required": ["virtual_path", "fields"],
+   "additionalProperties": false
+}`)
+		var validator *Validator
+
+		BeforeEach(func() {
+			validator = NewValidator()
+			validator.LoadSchema("_sensor_data", 1, schema)
+			Expect(validator.HasSchema("_sensor_data", 1)).To(BeTrue())
+		})
+
+		/*
+			Test cases:
+			1. Valid data & valid virtual_path
+			2. Valid data & invalid virtual_path
+			3. Invalid data & valid virtual_path
+			4. Invalid data & invalid virtual_path
+			5. Invalid payload format
+		*/
+
+		It("should pass validation for valid data & valid virtual_path", func() {
+			topic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.vibration.x-axis")
+			Expect(err).To(BeNil())
+			result := validator.Validate(topic, []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 100}}`))
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(BeNil())
+			Expect(result.ContractName).To(Equal("_sensor_data"))
+			Expect(result.ContractVersion).To(Equal(uint64(1)))
+		})
+
+		It("should fail validation for valid data & invalid virtual_path", func() {
+			topic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.vibration.non-existing")
+			Expect(err).To(BeNil())
+			result := validator.Validate(topic, []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 100}}`))
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(Not(BeNil()))
+			Expect(result.ContractName).To(Equal("_sensor_data"))
+			Expect(result.ContractVersion).To(Equal(uint64(1)))
+		})
+
+		It("should fail validation for invalid data & valid virtual_path", func() {
+			topic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.vibration.x-axis")
+			Expect(err).To(BeNil())
+			result := validator.Validate(topic, []byte(`{"value": {"timestamp_ms": 1719859200000, "value": "not a number"}}`))
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(Not(BeNil()))
+			Expect(result.ContractName).To(Equal("_sensor_data"))
+			Expect(result.ContractVersion).To(Equal(uint64(1)))
+		})
+
+		It("should fail validation for invalid data & invalid virtual_path", func() {
+			topic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.vibration.non-existing")
+			Expect(err).To(BeNil())
+			result := validator.Validate(topic, []byte(`{"value": {"timestamp_ms": 1719859200000, "value": "not a number"}}`))
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(Not(BeNil()))
+			Expect(result.ContractName).To(Equal("_sensor_data"))
+			Expect(result.ContractVersion).To(Equal(uint64(1)))
+		})
+
+		It("should fail validation for invalid payload format", func() {
+			topic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.vibration.x-axis")
+			Expect(err).To(BeNil())
+			result := validator.Validate(topic, []byte(`{"value": {"value": 100}}`))
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(Not(BeNil()))
+			Expect(result.ContractName).To(Equal("_sensor_data"))
+			Expect(result.ContractVersion).To(Equal(uint64(1)))
+		})
+	})
+
+	Context("when parsing data contracts", func() {
+		var validator *Validator
+
+		BeforeEach(func() {
+			validator = NewValidator()
+		})
+
+		It("should parse valid contract with version", func() {
+			contractName, version, err := validator.ExtractSchemaVersionFromDataContract("_sensor_data-v1")
+			Expect(err).To(BeNil())
+			Expect(contractName).To(Equal("_sensor_data"))
+			Expect(version).To(Equal(uint64(1)))
+		})
+
+		It("should parse contract with multi-digit version", func() {
+			contractName, version, err := validator.ExtractSchemaVersionFromDataContract("_pump_data-v123")
+			Expect(err).To(BeNil())
+			Expect(contractName).To(Equal("_pump_data"))
+			Expect(version).To(Equal(uint64(123)))
+		})
+
+		It("should parse contract with complex name", func() {
+			contractName, version, err := validator.ExtractSchemaVersionFromDataContract("_complex_sensor_data_v2-v42")
+			Expect(err).To(BeNil())
+			Expect(contractName).To(Equal("_complex_sensor_data_v2"))
+			Expect(version).To(Equal(uint64(42)))
+		})
+
+		It("should fail for empty contract", func() {
+			_, _, err := validator.ExtractSchemaVersionFromDataContract("")
+			Expect(err).To(HaveOccurred())
+			Expect(err.Error()).To(ContainSubstring("contract string is empty"))
+		})
+
+		It("should fail for contract without version", func() {
+			_, _, err := validator.ExtractSchemaVersionFromDataContract("_sensor_data")
+			Expect(err).To(HaveOccurred())
+			Expect(err.Error()).To(ContainSubstring("invalid data contract format"))
+		})
+
+		It("should fail for contract with invalid version format", func() {
+			_, _, err := validator.ExtractSchemaVersionFromDataContract("_sensor_data-vabc")
+			Expect(err).To(HaveOccurred())
+			Expect(err.Error()).To(ContainSubstring("invalid data contract format"))
+		})
+
+		It("should fail for contract with non-numeric version", func() {
+			_, _, err := validator.ExtractSchemaVersionFromDataContract("_sensor_data-v1a2")
+			Expect(err).To(HaveOccurred())
+			Expect(err.Error()).To(ContainSubstring("invalid data contract format"))
+		})
+
+		It("should fail for contract with negative version", func() {
+			_, _, err := validator.ExtractSchemaVersionFromDataContract("_sensor_data-v-1")
+			Expect(err).To(HaveOccurred())
+			Expect(err.Error()).To(ContainSubstring("invalid data contract format"))
+		})
+	})
+
+	Context("when loading schemas", func() {
+		var validator *Validator
+		validSchema := []byte(`{"type": "object", "properties": {"test": {"type": "string"}}}`)
+
+		BeforeEach(func() {
+			validator = NewValidator()
+		})
+
+		It("should load valid schema successfully", func() {
+			err := validator.LoadSchema("_test_contract", 1, validSchema)
+			Expect(err).To(BeNil())
+			Expect(validator.HasSchema("_test_contract", 1)).To(BeTrue())
+		})
+
+		It("should load multiple versions of same contract", func() {
+			schema1 := []byte(`{"type": "object", "properties": {"test1": {"type": "string"}}}`)
+			schema2 := []byte(`{"type": "object", "properties": {"test2": {"type": "number"}}}`)
+
+			err := validator.LoadSchema("_test_contract", 1, schema1)
+			Expect(err).To(BeNil())
+
+			err = validator.LoadSchema("_test_contract", 2, schema2)
+			Expect(err).To(BeNil())
+
+			Expect(validator.HasSchema("_test_contract", 1)).To(BeTrue())
+			Expect(validator.HasSchema("_test_contract", 2)).To(BeTrue())
+		})
+
+		It("should load multiple contracts", func() {
+			err := validator.LoadSchema("_contract1", 1, validSchema)
+			Expect(err).To(BeNil())
+
+			err = validator.LoadSchema("_contract2", 1, validSchema)
+			Expect(err).To(BeNil())
+
+			Expect(validator.HasSchema("_contract1", 1)).To(BeTrue())
+			Expect(validator.HasSchema("_contract2", 1)).To(BeTrue())
+		})
+
+		It("should fail for empty contract name", func() {
+			err := validator.LoadSchema("", 1, validSchema)
+			Expect(err).To(HaveOccurred())
+			Expect(err.Error()).To(ContainSubstring("contract name cannot be empty"))
+		})
+
+		It("should fail for contract name without underscore prefix", func() {
+			err := validator.LoadSchema("test_contract", 1, validSchema)
+			Expect(err).To(HaveOccurred())
+			Expect(err.Error()).To(ContainSubstring("contract name must start with an underscore"))
+		})
+
+		It("should fail for empty schema", func() {
+			err := validator.LoadSchema("_test_contract", 1, []byte{})
+			Expect(err).To(HaveOccurred())
+			Expect(err.Error()).To(ContainSubstring("schema cannot be empty"))
+		})
+
+		It("should fail for nil schema", func() {
+			err := validator.LoadSchema("_test_contract", 1, nil)
+			Expect(err).To(HaveOccurred())
+			Expect(err.Error()).To(ContainSubstring("schema cannot be empty"))
+		})
+
+		It("should fail for invalid JSON schema", func() {
+			// Use completely invalid JSON syntax
+			invalidSchema := []byte(`{"type": "object", "invalid": syntax}`)
+			err := validator.LoadSchema("_test_contract", 1, invalidSchema)
+			Expect(err).To(HaveOccurred())
+			Expect(err.Error()).To(ContainSubstring("failed to add schema version"))
+		})
+
+		It("should fail for malformed JSON", func() {
+			malformedSchema := []byte(`{"type": "object", "properties":`)
+			err := validator.LoadSchema("_test_contract", 1, malformedSchema)
+			Expect(err).To(HaveOccurred())
+			Expect(err.Error()).To(ContainSubstring("failed to add schema version"))
+		})
+
+		It("should overwrite existing schema version", func() {
+			schema1 := []byte(`{"type": "object", "properties": {"test1": {"type": "string"}}}`)
+			schema2 := []byte(`{"type": "object", "properties": {"test2": {"type": "number"}}}`)
+
+			err := validator.LoadSchema("_test_contract", 1, schema1)
+			Expect(err).To(BeNil())
+
+			// Load different schema with same version - should overwrite
+			err = validator.LoadSchema("_test_contract", 1, schema2)
+			Expect(err).To(BeNil())
+
+			Expect(validator.HasSchema("_test_contract", 1)).To(BeTrue())
+		})
+	})
+
+	Context("when checking schema existence", func() {
+		var validator *Validator
+		validSchema := []byte(`{"type": "object", "properties": {"test": {"type": "string"}}}`)
+
+		BeforeEach(func() {
+			validator = NewValidator()
+			validator.LoadSchema("_existing_contract", 1, validSchema)
+		})
+
+		It("should return true for existing contract and version", func() {
+			Expect(validator.HasSchema("_existing_contract", 1)).To(BeTrue())
+		})
+
+		It("should return false for non-existing contract", func() {
+			Expect(validator.HasSchema("_non_existing_contract", 1)).To(BeFalse())
+		})
+
+		It("should return false for existing contract with non-existing version", func() {
+			Expect(validator.HasSchema("_existing_contract", 2)).To(BeFalse())
+		})
+
+		It("should return false for empty contract name", func() {
+			Expect(validator.HasSchema("", 1)).To(BeFalse())
+		})
+	})
+
+	Context("when validating with edge cases", func() {
+		var validator *Validator
+		validSchema := []byte(`
+		{
+			"type": "object",
+			"properties": {
+				"virtual_path": {
+					"type": "string",
+					"enum": ["temperature", "humidity"]
+				},
+				"fields": {
+					"type": "object",
+					"properties": {
+						"value": {
+							"type": "object",
+							"properties": {
+								"timestamp_ms": {"type": "number"},
+								"value": {"type": "number"}
+							},
+							"required": ["timestamp_ms", "value"],
+							"additionalProperties": false
+						}
+					},
+					"additionalProperties": false
+				}
+			},
+			"required": ["virtual_path", "fields"],
+			"additionalProperties": false
+		}`)
+
+		BeforeEach(func() {
+			validator = NewValidator()
+			validator.LoadSchema("_sensor_data", 1, validSchema)
+		})
+
+		It("should fail for nil topic", func() {
+			result := validator.Validate(nil, []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 100}}`))
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+			Expect(result.Error.Error()).To(ContainSubstring("UNS topic cannot be nil"))
+		})
+
+		It("should fail for topic with empty contract", func() {
+			// This would require mocking the topic.Info() to return empty contract
+			// For now, we'll test the contract extraction directly
+			_, _, err := validator.ExtractSchemaVersionFromDataContract("")
+			Expect(err).To(HaveOccurred())
+		})
+
+		It("should bypass validation for non-existing schema", func() {
+			topic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._non_existing_contract-v1.temperature")
+			Expect(err).To(BeNil())
+			result := validator.Validate(topic, []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 100}}`))
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+			Expect(result.Error).To(BeNil())
+			Expect(result.BypassReason).To(ContainSubstring("schema for contract '_non_existing_contract' version 1 not found"))
+			Expect(result.ContractName).To(Equal("_non_existing_contract"))
+			Expect(result.ContractVersion).To(Equal(uint64(1)))
+		})
+
+		It("should bypass validation when version extraction fails", func() {
+			// Create a topic with malformed version format (unversioned contract)
+			topic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._malformed_contract.temperature")
+			Expect(err).To(BeNil())
+			result := validator.Validate(topic, []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 100}}`))
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+			Expect(result.Error).To(BeNil())
+			Expect(result.BypassReason).To(ContainSubstring("unversioned contract '_malformed_contract' - bypassing validation (no latest fetching)"))
+			Expect(result.ContractName).To(Equal("_malformed_contract"))
+			Expect(result.ContractVersion).To(Equal(uint64(0)))
+		})
+
+		It("should fail for empty JSON payload", func() {
+			topic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+			result := validator.Validate(topic, []byte(``))
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+			Expect(result.Error.Error()).To(ContainSubstring("schema validation failed"))
+		})
+
+		It("should fail for invalid JSON payload", func() {
+			topic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+			result := validator.Validate(topic, []byte(`{"invalid": json}`))
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+			Expect(result.Error.Error()).To(ContainSubstring("schema validation failed"))
+		})
+
+		It("should handle topic with nil virtual path", func() {
+			topic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+			result := validator.Validate(topic, []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 100}}`))
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(BeNil())
+		})
+
+		It("should handle topic with virtual path", func() {
+			// This would require a topic with virtual path - depends on topic implementation
+			topic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.some.path.temperature")
+			Expect(err).To(BeNil())
+			result := validator.Validate(topic, []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 100}}`))
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+			Expect(result.Error.Error()).To(ContainSubstring("schema validation failed"))
+		})
+
+		It("should provide descriptive error messages", func() {
+			topic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+			result := validator.Validate(topic, []byte(`{"value": {"timestamp_ms": "not_a_number", "value": 100}}`))
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+			Expect(result.Error.Error()).To(ContainSubstring("schema validation failed"))
+			Expect(result.Error.Error()).To(ContainSubstring("_sensor_data"))
+			Expect(result.Error.Error()).To(ContainSubstring("version 1"))
+		})
+
+		It("should validate with different data types", func() {
+			// Test with zero values
+			topic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+			result := validator.Validate(topic, []byte(`{"value": {"timestamp_ms": 0, "value": 0}}`))
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(BeNil())
+
+			// Test with negative values
+			result = validator.Validate(topic, []byte(`{"value": {"timestamp_ms": 1719859200000, "value": -25.5}}`))
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(BeNil())
+
+			// Test with large numbers
+			result = validator.Validate(topic, []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 999999999.999}}`))
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(BeNil())
+		})
+	})
+
+	Context("when handling concurrent operations", func() {
+		var validator *Validator
+		validSchema := []byte(`{"type": "object", "properties": {"test": {"type": "string"}}}`)
+
+		BeforeEach(func() {
+			validator = NewValidator()
+		})
+
+		It("should handle concurrent schema loading", func() {
+			var wg sync.WaitGroup
+			numGoroutines := 10
+
+			for i := 0; i < numGoroutines; i++ {
+				wg.Add(1)
+				go func(index int) {
+					defer wg.Done()
+					contractName := fmt.Sprintf("_test_contract_%d", index)
+					err := validator.LoadSchema(contractName, 1, validSchema)
+					Expect(err).To(BeNil())
+				}(i)
+			}
+
+			wg.Wait()
+
+			// Verify all schemas were loaded
+			for i := 0; i < numGoroutines; i++ {
+				contractName := fmt.Sprintf("_test_contract_%d", i)
+				Expect(validator.HasSchema(contractName, 1)).To(BeTrue())
+			}
+		})
+
+		It("should handle concurrent validation", func() {
+			// Load a schema first
+			err := validator.LoadSchema("_test_contract", 1, []byte(`
+			{
+				"type": "object",
+				"properties": {
+					"virtual_path": {
+						"type": "string",
+						"enum": ["test"]
+					},
+					"fields": {
+						"type": "object",
+						"properties": {
+							"value": {
+								"type": "object",
+								"properties": {
+									"timestamp_ms": {"type": "number"},
+									"value": {"type": "number"}
+								},
+								"required": ["timestamp_ms", "value"]
+							}
+						}
+					}
+				},
+				"required": ["virtual_path", "fields"]
+			}`))
+			Expect(err).To(BeNil())
+
+			var wg sync.WaitGroup
+			numGoroutines := 10
+
+			for i := 0; i < numGoroutines; i++ {
+				wg.Add(1)
+				go func() {
+					defer wg.Done()
+					topic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._test_contract-v1.test")
+					Expect(err).To(BeNil())
+					result := validator.Validate(topic, []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 100}}`))
+					Expect(result.SchemaCheckPassed).To(BeTrue())
+					Expect(result.SchemaCheckBypassed).To(BeFalse())
+					Expect(result.Error).To(BeNil())
+				}()
+			}
+
+			wg.Wait()
+		})
+
+		It("should handle concurrent schema loading and validation", func() {
+			var wg sync.WaitGroup
+			numGoroutines := 5
+
+			// Load schemas concurrently
+			for i := 0; i < numGoroutines; i++ {
+				wg.Add(1)
+				go func(index int) {
+					defer wg.Done()
+					contractName := fmt.Sprintf("_concurrent_test_%d", index)
+					schema := []byte(fmt.Sprintf(`
+					{
+						"type": "object",
+						"properties": {
+							"virtual_path": {
+								"type": "string",
+								"enum": ["test_%d"]
+							},
+							"fields": {
+								"type": "object",
+								"properties": {
+									"value": {
+										"type": "object",
+										"properties": {
+											"timestamp_ms": {"type": "number"},
+											"value": {"type": "number"}
+										},
+										"required": ["timestamp_ms", "value"]
+									}
+								}
+							}
+						},
+						"required": ["virtual_path", "fields"]
+					}`, index))
+					err := validator.LoadSchema(contractName, 1, schema)
+					Expect(err).To(BeNil())
+				}(i)
+			}
+
+			wg.Wait()
+
+			// Validate with each schema concurrently
+			for i := 0; i < numGoroutines; i++ {
+				wg.Add(1)
+				go func(index int) {
+					defer wg.Done()
+					contractName := fmt.Sprintf("_concurrent_test_%d", index)
+					topicString := fmt.Sprintf("umh.v1.enterprise.site.area.%s-v1.test_%d", contractName, index)
+					topic, err := topic.NewUnsTopic(topicString)
+					Expect(err).To(BeNil())
+					result := validator.Validate(topic, []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 100}}`))
+					Expect(result.SchemaCheckPassed).To(BeTrue())
+					Expect(result.SchemaCheckBypassed).To(BeFalse())
+					Expect(result.Error).To(BeNil())
+				}(i)
+			}
+
+			wg.Wait()
+		})
+	})
+
+	Context("when handling schema versions", func() {
+		var validator *Validator
+
+		BeforeEach(func() {
+			validator = NewValidator()
+		})
+
+		It("should handle version zero", func() {
+			schema := []byte(`{"type": "object", "properties": {"test": {"type": "string"}}}`)
+			err := validator.LoadSchema("_test_contract", 0, schema)
+			Expect(err).To(BeNil())
+			Expect(validator.HasSchema("_test_contract", 0)).To(BeTrue())
+		})
+
+		It("should handle large version numbers", func() {
+			schema := []byte(`{"type": "object", "properties": {"test": {"type": "string"}}}`)
+			largeVersion := uint64(18446744073709551615) // max uint64
+			err := validator.LoadSchema("_test_contract", largeVersion, schema)
+			Expect(err).To(BeNil())
+			Expect(validator.HasSchema("_test_contract", largeVersion)).To(BeTrue())
+		})
+
+		It("should maintain separate versions independently", func() {
+			schema1 := []byte(`{"type": "object", "properties": {"v1_field": {"type": "string"}}}`)
+			schema2 := []byte(`{"type": "object", "properties": {"v2_field": {"type": "number"}}}`)
+
+			err := validator.LoadSchema("_versioned_contract", 1, schema1)
+			Expect(err).To(BeNil())
+
+			err = validator.LoadSchema("_versioned_contract", 2, schema2)
+			Expect(err).To(BeNil())
+
+			Expect(validator.HasSchema("_versioned_contract", 1)).To(BeTrue())
+			Expect(validator.HasSchema("_versioned_contract", 2)).To(BeTrue())
+			Expect(validator.HasSchema("_versioned_contract", 3)).To(BeFalse())
+		})
+	})
+})
diff --git a/uns_plugin/uns_output.go b/uns_plugin/uns_output.go
index 70ae9a4..0881d4a 100644
--- a/uns_plugin/uns_output.go
+++ b/uns_plugin/uns_output.go
@@ -17,12 +17,14 @@ package uns_plugin
 import (
 	"context"
 	"fmt"
+	"strconv"
 	"strings"
 	"time"
 
 	"github.com/redpanda-data/benthos/v4/public/service"
 	"github.com/twmb/franz-go/pkg/kgo"
 	"github.com/united-manufacturing-hub/benthos-umh/pkg/umh/topic"
+	schemavalidation "github.com/united-manufacturing-hub/benthos-umh/uns_plugin/schema_validation"
 )
 
 // init registers the "uns" batch output plugin with Benthos using its configuration and constructor.
@@ -34,6 +36,7 @@ const (
 	defaultOutputTopic               = "umh.messages" // by the current state, the output topic must not be changed for this plugin
 	defaultOutputTopicPartitionCount = 1
 	defaultBrokerAddress             = "localhost:9092"
+	defaultSchemaRegistryPort        = "8081"
 	defaultClientID                  = "umh_core"
 	defaultUMHTopic                  = "${! meta(\"umh_topic\") }"
 )
@@ -112,20 +115,67 @@ Traceability header.  Defaults to 'umh-core' but is automatically
 overwritten by UMH Core when the container runs as a protocol-converter:
 'protocol-converter-<INSTANCE>-<NAME>'.
 `).
-			Default(defaultClientID))
+			Default(defaultClientID)).
+		Field(service.NewStringField("schema_registry_url").
+			Description(`
+Schema registry URL for data contract validation.  If not provided, it
+will be automatically derived from the first broker in the broker_address
+list by changing the port to 8081.
+
+Example: If broker_address is "localhost:9092", the schema registry URL
+will be "http://localhost:8081".
+`).
+			Example("http://localhost:8081").
+			Example("https://schema-registry.example.com:8081").
+			Optional())
 }
 
 // Config holds the configuration for the UNS output plugin
 type unsOutputConfig struct {
-	umh_topic     *service.InterpolatedString
-	brokerAddress string
-	bridgedBy     string
+	umh_topic         *service.InterpolatedString
+	brokerAddress     string
+	bridgedBy         string
+	schemaRegistryURL string
 }
 
 type unsOutput struct {
-	config unsOutputConfig
-	client MessagePublisher
-	log    *service.Logger
+	config    unsOutputConfig
+	client    MessagePublisher
+	log       *service.Logger
+	validator *schemavalidation.Validator
+}
+
+// deriveSchemaRegistryURL derives a schema registry URL from the broker address
+// Takes the first broker from a comma-separated list and converts the port to 8081
+func deriveSchemaRegistryURL(brokerAddress string) string {
+	// Split by comma to handle multiple brokers
+	brokers := strings.Split(brokerAddress, ",")
+	if len(brokers) == 0 {
+		return ""
+	}
+
+	// Take the first broker and trim any whitespace
+	firstBroker := strings.TrimSpace(brokers[0])
+
+	// Check if the first broker is empty
+	if firstBroker == "" {
+		return ""
+	}
+
+	// Split by colon to separate host and port
+	parts := strings.Split(firstBroker, ":")
+	if len(parts) != 2 {
+		// If no port specified, assume default and add schema registry port
+		return fmt.Sprintf("http://%s:%s", firstBroker, defaultSchemaRegistryPort)
+	}
+
+	// Replace the port with schema registry port
+	host := parts[0]
+	// Check if host is empty
+	if host == "" {
+		return ""
+	}
+	return fmt.Sprintf("http://%s:%s", host, defaultSchemaRegistryPort)
 }
 
 // newUnsOutput creates a new unsOutput instance by parsing configuration fields for umh_topic, broker address, and bridge name, returning the output, batch policy, max in-flight count, and any error encountered during parsing.
@@ -173,15 +223,31 @@ func newUnsOutput(conf *service.ParsedConfig, mgr *service.Resources) (service.B
 		}
 	}
 
-	return newUnsOutputWithClient(NewClient(), config, mgr.Logger()), batchPolicy, maxInFlight, nil
+	// Parse schema_registry_url if provided, otherwise derive from broker_address
+	if conf.Contains("schema_registry_url") {
+		schemaRegistryURL, err := conf.FieldString("schema_registry_url")
+		if err != nil {
+			return nil, batchPolicy, 0, fmt.Errorf("error while parsing schema_registry_url field from the config: %v", err)
+		}
+		config.schemaRegistryURL = schemaRegistryURL
+	} else {
+		// Derive schema registry URL from broker address
+		config.schemaRegistryURL = deriveSchemaRegistryURL(config.brokerAddress)
+	}
+
+	// Initialize the validator with schema registry URL
+	validator := schemavalidation.NewValidatorWithRegistry(config.schemaRegistryURL)
+
+	return newUnsOutputWithClient(NewClient(), config, mgr.Logger(), validator), batchPolicy, maxInFlight, nil
 }
 
 // Testable constructor that accepts client
-func newUnsOutputWithClient(client MessagePublisher, config unsOutputConfig, logger *service.Logger) service.BatchOutput {
+func newUnsOutputWithClient(client MessagePublisher, config unsOutputConfig, logger *service.Logger, validator *schemavalidation.Validator) service.BatchOutput {
 	return &unsOutput{
-		client: client,
-		config: config,
-		log:    logger,
+		client:    client,
+		config:    config,
+		log:       logger,
+		validator: validator,
 	}
 }
 
@@ -192,6 +258,9 @@ func (o *unsOutput) Close(ctx context.Context) error {
 		o.client.Close()
 		o.client = nil
 	}
+	if o.validator != nil {
+		o.validator.Close()
+	}
 	o.log.Infof("uns kafka client closed successfully")
 	return nil
 }
@@ -199,6 +268,7 @@ func (o *unsOutput) Close(ctx context.Context) error {
 // Connect initializes the kafka client
 func (o *unsOutput) Connect(ctx context.Context) error {
 	o.log.Infof("Connecting to uns plugin kafka broker: %v", o.config.brokerAddress)
+	o.log.Infof("Using schema registry URL: %v", o.config.schemaRegistryURL)
 
 	if o.client == nil {
 		o.client = NewClient()
@@ -300,21 +370,36 @@ func (o *unsOutput) WriteBatch(ctx context.Context, msgs service.MessageBatch) e
 		}
 
 		// Validate the UMH topic using the centralized topic library
-		_, err = topic.NewUnsTopic(key)
+		unsTopic, err := topic.NewUnsTopic(key)
 		if err != nil {
 			return fmt.Errorf("error validating message key in message %d: invalid UMH topic '%s': %v", i, key, err)
 		}
 
-		headers, err := o.extractHeaders(msg)
-		if err != nil {
-			return fmt.Errorf("error processing message %d: %v", i, err)
-		}
-
 		msgAsBytes, err := msg.AsBytes()
 		if err != nil {
 			return fmt.Errorf("error getting content of message %d: %v", i, err)
 		}
 
+		// Validate the payload against the schema
+		validationResult := o.validator.Validate(unsTopic, msgAsBytes)
+		if !validationResult.SchemaCheckPassed && !validationResult.SchemaCheckBypassed {
+			return fmt.Errorf("error validating message payload in message %d: %v", i, validationResult.Error)
+		}
+		if validationResult.SchemaCheckPassed {
+			// Add the contract name and version to the headers
+			msg.MetaSet("data_contract_name", validationResult.ContractName)
+			msg.MetaSet("data_contract_version", strconv.FormatUint(validationResult.ContractVersion, 10))
+		} else if validationResult.SchemaCheckBypassed {
+			// Add bypass information if validation was bypassed
+			msg.MetaSet("data_contract_bypassed", "true")
+			msg.MetaSet("data_contract_bypass_reason", validationResult.BypassReason)
+		}
+
+		headers, err := o.extractHeaders(msg)
+		if err != nil {
+			return fmt.Errorf("error processing message %d: %v", i, err)
+		}
+
 		record := Record{
 			Topic:   defaultOutputTopic,
 			Key:     []byte(key),
diff --git a/uns_plugin/uns_output_test.go b/uns_plugin/uns_output_test.go
index 84285d6..dc4e92d 100644
--- a/uns_plugin/uns_output_test.go
+++ b/uns_plugin/uns_output_test.go
@@ -24,6 +24,7 @@ import (
 	"github.com/redpanda-data/benthos/v4/public/service"
 	"github.com/twmb/franz-go/pkg/kgo"
 	"github.com/united-manufacturing-hub/benthos-umh/pkg/umh/topic"
+	schemavalidation "github.com/united-manufacturing-hub/benthos-umh/uns_plugin/schema_validation"
 )
 
 type TestMessagePublisher interface {
@@ -152,7 +153,9 @@ var _ = Describe("Initializing uns output plugin", func() {
 		}
 		umh_topic, _ := service.NewInterpolatedString("${! meta(\"umh_topic\") }")
 		unsConf.umh_topic = umh_topic
-		outputPlugin = newUnsOutputWithClient(mockClient, unsConf, nil)
+		// Initialize the validator
+		validator := schemavalidation.NewValidator()
+		outputPlugin = newUnsOutputWithClient(mockClient, unsConf, nil, validator)
 		unsClient = outputPlugin.(*unsOutput)
 		ctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)
 	})
