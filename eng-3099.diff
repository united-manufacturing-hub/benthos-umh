diff --git c/.gitignore w/.gitignore
index a27241b..defeaaa 100644
--- c/.gitignore
+++ w/.gitignore
@@ -203,6 +203,7 @@ dist
 
 # Cover.profile
 *.profile
+*.profile.*
 benthos-umh
 benthos
 
diff --git c/Makefile w/Makefile
index 09e585e..a40a78a 100644
--- c/Makefile
+++ w/Makefile
@@ -79,7 +79,11 @@ test-opc:
 
 .PHONY: test-uns
 test-uns:
-	@$(GINKGO_CMD) $(GINKGO_FLAGS) ./uns_plugin/...
+	@$(GINKGO_CMD) $(GINKGO_FLAGS) --label-filter='!redpanda' ./uns_plugin/...
+
+.PHONY: test-uns-redpanda
+test-uns-redpanda:
+	@$(GINKGO_CMD) $(GINKGO_FLAGS)  ./uns_plugin/...
 
 .PHONY: test-s7comm
 test-s7comm:
diff --git c/eng-3099.diff w/eng-3099.diff
new file mode 100644
index 0000000..e69de29
diff --git c/go.mod w/go.mod
index c78ef0b..e77ab98 100644
--- c/go.mod
+++ w/go.mod
@@ -37,6 +37,7 @@ require (
 	github.com/gopcua/opcua v0.5.3
 	github.com/grid-x/modbus v0.0.0-20250312115347-d1d8b421f52b
 	github.com/hashicorp/golang-lru v0.5.4
+	github.com/kaptinlin/jsonschema v0.4.6
 	github.com/pierrec/lz4/v4 v4.1.22
 	github.com/redpanda-data/benthos/v4 v4.49.0
 	github.com/redpanda-data/connect/public/bundle/free/v4 v4.49.1
@@ -200,6 +201,7 @@ require (
 	github.com/go-sourcemap/sourcemap v2.1.4+incompatible // indirect
 	github.com/go-sql-driver/mysql v1.9.0 // indirect
 	github.com/go-task/slim-sprig/v3 v3.0.0 // indirect
+	github.com/goccy/go-yaml v1.18.0 // indirect
 	github.com/gocql/gocql v1.7.0 // indirect
 	github.com/godbus/dbus v0.0.0-20190726142602-4481cbc300e2 // indirect
 	github.com/gofrs/uuid v4.4.0+incompatible // indirect
@@ -226,6 +228,8 @@ require (
 	github.com/gorilla/websocket v1.5.3 // indirect
 	github.com/gosimple/slug v1.15.0 // indirect
 	github.com/gosimple/unidecode v1.0.1 // indirect
+	github.com/gotnospirit/makeplural v0.0.0-20180622080156-a5f48d94d976 // indirect
+	github.com/gotnospirit/messageformat v0.0.0-20221001023931-dfe49f1eb092 // indirect
 	github.com/govalues/decimal v0.1.36 // indirect
 	github.com/grid-x/serial v0.0.0-20211107191517-583c7356b3aa // indirect
 	github.com/grpc-ecosystem/go-grpc-middleware v1.4.0 // indirect
@@ -262,6 +266,7 @@ require (
 	github.com/josharian/intern v1.0.0 // indirect
 	github.com/json-iterator/go v1.1.12 // indirect
 	github.com/jzelinskie/stringz v0.0.3 // indirect
+	github.com/kaptinlin/go-i18n v0.1.4 // indirect
 	github.com/klauspost/compress v1.18.0 // indirect
 	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
 	github.com/klauspost/pgzip v1.2.6 // indirect
@@ -385,10 +390,10 @@ require (
 	golang.org/x/mod v0.24.0 // indirect
 	golang.org/x/net v0.39.0 // indirect
 	golang.org/x/oauth2 v0.29.0 // indirect
-	golang.org/x/sync v0.13.0 // indirect
+	golang.org/x/sync v0.14.0 // indirect
 	golang.org/x/sys v0.32.0 // indirect
 	golang.org/x/term v0.31.0 // indirect
-	golang.org/x/text v0.24.0 // indirect
+	golang.org/x/text v0.25.0 // indirect
 	golang.org/x/tools v0.32.0 // indirect
 	golang.org/x/xerrors v0.0.0-20240903120638-7835f813f4da // indirect
 	google.golang.org/api v0.226.0 // indirect
diff --git c/go.sum w/go.sum
index 130726c..661a088 100644
--- c/go.sum
+++ w/go.sum
@@ -1220,6 +1220,8 @@ github.com/gobwas/ws v1.0.2/go.mod h1:szmBTxLgaFppYjEmNtny/v3w89xOydFnnZMcgRRu/E
 github.com/goccy/go-json v0.9.11/go.mod h1:6MelG93GURQebXPDq3khkgXZkazVtN9CRI+MGFi0w8I=
 github.com/goccy/go-json v0.10.5 h1:Fq85nIqj+gXn/S5ahsiTlK3TmC85qgirsdTP/+DeaC4=
 github.com/goccy/go-json v0.10.5/go.mod h1:oq7eo15ShAhp70Anwd5lgX2pLfOS3QCiwU/PULtXL6M=
+github.com/goccy/go-yaml v1.18.0 h1:8W7wMFS12Pcas7KU+VVkaiCng+kG8QiFeFwzFb+rwuw=
+github.com/goccy/go-yaml v1.18.0/go.mod h1:XBurs7gK8ATbW4ZPGKgcbrY1Br56PdM69F7LkFRi1kA=
 github.com/gocql/gocql v1.7.0 h1:O+7U7/1gSN7QTEAaMEsJc1Oq2QHXvCWoF3DFK9HDHus=
 github.com/gocql/gocql v1.7.0/go.mod h1:vnlvXyFZeLBF0Wy+RS8hrOdbn0UWsWtdg07XJnFxZ+4=
 github.com/godbus/dbus v0.0.0-20190726142602-4481cbc300e2 h1:ZpnhV/YsD2/4cESfV5+Hoeu/iUR3ruzNvZ+yQfO03a0=
@@ -1412,6 +1414,10 @@ github.com/gosimple/slug v1.15.0 h1:wRZHsRrRcs6b0XnxMUBM6WK1U1Vg5B0R7VkIf1Xzobo=
 github.com/gosimple/slug v1.15.0/go.mod h1:UiRaFH+GEilHstLUmcBgWcI42viBN7mAb818JrYOeFQ=
 github.com/gosimple/unidecode v1.0.1 h1:hZzFTMMqSswvf0LBJZCZgThIZrpDHFXux9KeGmn6T/o=
 github.com/gosimple/unidecode v1.0.1/go.mod h1:CP0Cr1Y1kogOtx0bJblKzsVWrqYaqfNOnHzpgWw4Awc=
+github.com/gotnospirit/makeplural v0.0.0-20180622080156-a5f48d94d976 h1:b70jEaX2iaJSPZULSUxKtm73LBfsCrMsIlYCUgNGSIs=
+github.com/gotnospirit/makeplural v0.0.0-20180622080156-a5f48d94d976/go.mod h1:ZGQeOwybjD8lkCjIyJfqR5LD2wMVHJ31d6GdPxoTsWY=
+github.com/gotnospirit/messageformat v0.0.0-20221001023931-dfe49f1eb092 h1:c7gcNWTSr1gtLp6PyYi3wzvFCEcHJ4YRobDgqmIgf7Q=
+github.com/gotnospirit/messageformat v0.0.0-20221001023931-dfe49f1eb092/go.mod h1:ZZAN4fkkful3l1lpJwF8JbW41ZiG9TwJ2ZlqzQovBNU=
 github.com/govalues/decimal v0.1.36 h1:dojDpsSvrk0ndAx8+saW5h9WDIHdWpIwrH/yhl9olyU=
 github.com/govalues/decimal v0.1.36/go.mod h1:Ee7eI3Llf7hfqDZtpj8Q6NCIgJy1iY3kH1pSwDrNqlM=
 github.com/grid-x/modbus v0.0.0-20250312115347-d1d8b421f52b h1:12LFb/Ga2TH5SK1sog0EC8VCrOf2XMynjOM/dxF/qYY=
@@ -1574,6 +1580,10 @@ github.com/jung-kurt/gofpdf v1.0.0/go.mod h1:7Id9E/uU8ce6rXgefFLlgrJj/GYY22cpxn+
 github.com/jung-kurt/gofpdf v1.0.3-0.20190309125859-24315acbbda5/go.mod h1:7Id9E/uU8ce6rXgefFLlgrJj/GYY22cpxn+r32jIOes=
 github.com/jzelinskie/stringz v0.0.3 h1:0GhG3lVMYrYtIvRbxvQI6zqRTT1P1xyQlpa0FhfUXas=
 github.com/jzelinskie/stringz v0.0.3/go.mod h1:hHYbgxJuNLRw91CmpuFsYEOyQqpDVFg8pvEh23vy4P0=
+github.com/kaptinlin/go-i18n v0.1.4 h1:wCiwAn1LOcvymvWIVAM4m5dUAMiHunTdEubLDk4hTGs=
+github.com/kaptinlin/go-i18n v0.1.4/go.mod h1:g1fn1GvTgT4CiLE8/fFE1hboHWJ6erivrDpiDtCcFKg=
+github.com/kaptinlin/jsonschema v0.4.6 h1:vOSFg5tjmfkOdKg+D6Oo4fVOM/pActWu/ntkPsI1T64=
+github.com/kaptinlin/jsonschema v0.4.6/go.mod h1:1DUd7r5SdyB2ZnMtyB7uLv64dE3zTFTiYytDCd+AEL0=
 github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51/go.mod h1:CzGEWj7cYgsdH8dAjBGEr58BoE7ScuLd+fwFZ44+/x8=
 github.com/keybase/go-keychain v0.0.0-20231219164618-57a3676c3af6 h1:IsMZxCuZqKuao2vNdfD82fjjgPLfyHLpR41Z88viRWs=
 github.com/keybase/go-keychain v0.0.0-20231219164618-57a3676c3af6/go.mod h1:3VeWNIJaW+O5xpRQbPp0Ybqu1vJd/pm7s2F473HRrkw=
@@ -1775,8 +1785,8 @@ github.com/pborman/getopt v0.0.0-20180729010549-6fdd0a2c7117/go.mod h1:85jBQOZwp
 github.com/pebbe/zmq4 v1.3.0 h1:iBbv/Ugiw26/BVf1NXtYOCwUL0kefCwzgnypYBQj8iM=
 github.com/pebbe/zmq4 v1.3.0/go.mod h1:nqnPueOapVhE2wItZ0uOErngczsJdLOGkebMxaO8r48=
 github.com/pelletier/go-toml v1.9.5 h1:4yBQzkHv+7BHq2PQUZF3Mx0IYxG7LsP222s7Agd3ve8=
-github.com/pelletier/go-toml/v2 v2.2.3 h1:YmeHyLY8mFWbdkNWwpr+qIL2bEqT0o95WSdkNHvL12M=
-github.com/pelletier/go-toml/v2 v2.2.3/go.mod h1:MfCQTFTvCcUyyvvwm1+G6H/jORL20Xlb6rzQu9GuUkc=
+github.com/pelletier/go-toml/v2 v2.2.4 h1:mye9XuhQ6gvn5h28+VilKrrPoQVanw5PMw/TB0t5Ec4=
+github.com/pelletier/go-toml/v2 v2.2.4/go.mod h1:2gIqNv+qfxSVS7cM2xJQKtLSTLUE9V8t9Stt+h56mCY=
 github.com/pgvector/pgvector-go v0.3.0 h1:Ij+Yt78R//uYqs3Zk35evZFvr+G0blW0OUN+Q2D1RWc=
 github.com/pgvector/pgvector-go v0.3.0/go.mod h1:duFy+PXWfW7QQd5ibqutBO4GxLsUZ9RVXhFZGIBsWSA=
 github.com/phpdave11/gofpdf v1.4.2/go.mod h1:zpO6xFn9yxo3YLyMvW8HcKWVdbNqgIfOOp2dXMnm1mY=
@@ -2345,8 +2355,8 @@ golang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=
 golang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
 golang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
 golang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
-golang.org/x/sync v0.13.0 h1:AauUjRAJ9OSnvULf/ARrrVywoJDy0YS2AwQ98I37610=
-golang.org/x/sync v0.13.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
+golang.org/x/sync v0.14.0 h1:woo0S4Yywslg6hp4eUFjTVOyKt0RookbpAHG4c1HmhQ=
+golang.org/x/sync v0.14.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
 golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
@@ -2488,8 +2498,8 @@ golang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=
 golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
 golang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
 golang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=
-golang.org/x/text v0.24.0 h1:dd5Bzh4yt5KYA8f9CJHCP4FB4D51c2c6JvN37xJJkJ0=
-golang.org/x/text v0.24.0/go.mod h1:L8rBsPeo2pSS+xqN0d5u2ikmjtmoJbDBT1b7nHvFCdU=
+golang.org/x/text v0.25.0 h1:qVyWApTSYLk/drJRO5mDlNYskwQznZmkpV2c8q9zls4=
+golang.org/x/text v0.25.0/go.mod h1:WEdwpYrmk1qmdHvhkSTNPm3app7v4rsT8F2UD6+VHIA=
 golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
 golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
 golang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
diff --git c/uns_plugin/schema_validation/mock_schema_registry.go w/uns_plugin/schema_validation/mock_schema_registry.go
new file mode 100644
index 0000000..c2cb944
--- /dev/null
+++ w/uns_plugin/schema_validation/mock_schema_registry.go
@@ -0,0 +1,379 @@
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package schemavalidation
+
+import (
+	"encoding/json"
+	"fmt"
+	"net/http"
+	"net/http/httptest"
+	"strconv"
+	"strings"
+)
+
+// MockSchemaRegistry simulates Redpanda's Schema Registry for testing
+type MockSchemaRegistry struct {
+	server  *httptest.Server
+	schemas map[string]map[int]*MockSchemaVersion // subject -> version -> schema
+}
+
+// MockSchemaVersion represents a schema version in the mock registry
+type MockSchemaVersion struct {
+	ID      int    `json:"id"`
+	Version int    `json:"version"`
+	Schema  string `json:"schema"`
+	Subject string `json:"subject"`
+}
+
+// NewMockSchemaRegistry creates a new mock schema registry server
+func NewMockSchemaRegistry() *MockSchemaRegistry {
+	mock := &MockSchemaRegistry{
+		schemas: make(map[string]map[int]*MockSchemaVersion),
+	}
+
+	// Create HTTP server with Redpanda-compatible API
+	mux := http.NewServeMux()
+	mux.HandleFunc("/subjects", mock.handleSubjects)
+	mux.HandleFunc("/subjects/", mock.handleSubjectVersions)
+
+	mock.server = httptest.NewServer(mux)
+	return mock
+}
+
+// URL returns the base URL of the mock server
+func (m *MockSchemaRegistry) URL() string {
+	return m.server.URL
+}
+
+// Close shuts down the mock server
+func (m *MockSchemaRegistry) Close() {
+	m.server.Close()
+}
+
+// AddSchema adds a schema to the mock registry
+func (m *MockSchemaRegistry) AddSchema(subject string, version int, schema string) {
+	if m.schemas[subject] == nil {
+		m.schemas[subject] = make(map[int]*MockSchemaVersion)
+	}
+
+	// Generate a unique ID (simple incrementing for mock)
+	id := len(m.schemas) + version*1000
+
+	m.schemas[subject][version] = &MockSchemaVersion{
+		ID:      id,
+		Version: version,
+		Schema:  schema,
+		Subject: subject,
+	}
+}
+
+// RemoveSchema removes a schema from the mock registry
+func (m *MockSchemaRegistry) RemoveSchema(subject string, version int) {
+	if versions, exists := m.schemas[subject]; exists {
+		delete(versions, version)
+		if len(versions) == 0 {
+			delete(m.schemas, subject)
+		}
+	}
+}
+
+// GetSchema gets a schema from the mock registry
+func (m *MockSchemaRegistry) GetSchema(subject string, version int) *MockSchemaVersion {
+	if versions, exists := m.schemas[subject]; exists {
+		return versions[version]
+	}
+	return nil
+}
+
+// handleSubjects handles GET /subjects - returns all available subjects
+func (m *MockSchemaRegistry) handleSubjects(w http.ResponseWriter, r *http.Request) {
+	if r.Method != http.MethodGet {
+		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
+		return
+	}
+
+	// Collect all subjects
+	var subjects []string
+	for subject := range m.schemas {
+		subjects = append(subjects, subject)
+	}
+
+	w.Header().Set("Content-Type", "application/json")
+	json.NewEncoder(w).Encode(subjects)
+}
+
+// handleSubjectVersions handles requests to /subjects/{subject}/versions/{version}
+func (m *MockSchemaRegistry) handleSubjectVersions(w http.ResponseWriter, r *http.Request) {
+	if r.Method != http.MethodGet {
+		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
+		return
+	}
+
+	// Parse the URL path: /subjects/{subject}/versions/{version}
+	path := strings.TrimPrefix(r.URL.Path, "/subjects/")
+	parts := strings.Split(path, "/")
+
+	if len(parts) < 3 || parts[1] != "versions" {
+		http.Error(w, "Invalid path", http.StatusBadRequest)
+		return
+	}
+
+	subject := parts[0]
+	versionStr := parts[2]
+
+	// Handle "latest" version request
+	if versionStr == "latest" {
+		m.handleLatestVersion(w, subject)
+		return
+	}
+
+	// Parse version number
+	version, err := strconv.Atoi(versionStr)
+	if err != nil {
+		http.Error(w, "Invalid version format", http.StatusBadRequest)
+		return
+	}
+
+	// Check if subject exists
+	versions, subjectExists := m.schemas[subject]
+	if !subjectExists {
+		http.Error(w, fmt.Sprintf(`{"error_code":40401,"message":"Subject '%s' not found."}`, subject), http.StatusNotFound)
+		return
+	}
+
+	// Check if version exists
+	schema, versionExists := versions[version]
+	if !versionExists {
+		http.Error(w, fmt.Sprintf(`{"error_code":40402,"message":"Version %d not found for subject '%s'."}`, version, subject), http.StatusNotFound)
+		return
+	}
+
+	// Return the schema version (Redpanda format)
+	w.Header().Set("Content-Type", "application/json")
+	json.NewEncoder(w).Encode(schema)
+}
+
+// handleLatestVersion handles requests for the latest version of a subject
+func (m *MockSchemaRegistry) handleLatestVersion(w http.ResponseWriter, subject string) {
+	versions, subjectExists := m.schemas[subject]
+	if !subjectExists {
+		http.Error(w, fmt.Sprintf(`{"error_code":40401,"message":"Subject '%s' not found."}`, subject), http.StatusNotFound)
+		return
+	}
+
+	// Find the latest version
+	var latestVersion int
+	var latestSchema *MockSchemaVersion
+	for version, schema := range versions {
+		if version > latestVersion {
+			latestVersion = version
+			latestSchema = schema
+		}
+	}
+
+	if latestSchema == nil {
+		http.Error(w, fmt.Sprintf(`{"error_code":40402,"message":"No versions found for subject '%s'."}`, subject), http.StatusNotFound)
+		return
+	}
+
+	w.Header().Set("Content-Type", "application/json")
+	json.NewEncoder(w).Encode(latestSchema)
+}
+
+// SetupTestSchemas adds common test schemas to the mock registry
+func (m *MockSchemaRegistry) SetupTestSchemas() {
+	// Add a sensor data contract v1 (temperature only)
+	sensorDataV1 := `{
+		"type": "object",
+		"properties": {
+			"virtual_path": {
+				"type": "string",
+				"enum": ["temperature"]
+			},
+			"fields": {
+				"type": "object",
+				"properties": {
+					"value": {
+						"type": "object",
+						"properties": {
+							"timestamp_ms": {"type": "number"},
+							"value": {"type": "number"}
+						},
+						"required": ["timestamp_ms", "value"],
+						"additionalProperties": false
+					}
+				},
+				"additionalProperties": false
+			}
+		},
+		"required": ["virtual_path", "fields"],
+		"additionalProperties": false
+	}`
+	m.AddSchema("_sensor_data", 1, sensorDataV1)
+
+	// Add a sensor data contract v2 with additional fields
+	sensorDataV2 := `{
+		"type": "object",
+		"properties": {
+			"virtual_path": {
+				"type": "string",
+				"enum": ["temperature", "humidity", "pressure"]
+			},
+			"fields": {
+				"type": "object",
+				"properties": {
+					"value": {
+						"type": "object",
+						"properties": {
+							"timestamp_ms": {"type": "number"},
+							"value": {"type": "number"}
+						},
+						"required": ["timestamp_ms", "value"],
+						"additionalProperties": false
+					}
+				},
+				"additionalProperties": false
+			}
+		},
+		"required": ["virtual_path", "fields"],
+		"additionalProperties": false
+	}`
+	m.AddSchema("_sensor_data", 2, sensorDataV2)
+
+	// Add a pump contract v1
+	pumpDataV1 := `{
+		"type": "object",
+		"properties": {
+			"virtual_path": {
+				"type": "string",
+				"enum": ["vibration.x-axis", "vibration.y-axis", "count"]
+			},
+			"fields": {
+				"type": "object",
+				"properties": {
+					"value": {
+						"type": "object",
+						"properties": {
+							"timestamp_ms": {"type": "number"},
+							"value": {"type": "number"}
+						},
+						"required": ["timestamp_ms", "value"],
+						"additionalProperties": false
+					}
+				},
+				"additionalProperties": false
+			}
+		},
+		"required": ["virtual_path", "fields"],
+		"additionalProperties": false
+	}`
+	m.AddSchema("_pump_data", 1, pumpDataV1)
+
+	// Add a motor contract v3 (skipping v1 and v2 to test version gaps)
+	motorDataV3 := `{
+		"type": "object",
+		"properties": {
+			"virtual_path": {
+				"type": "string",
+				"enum": ["rpm", "temperature", "status"]
+			},
+			"fields": {
+				"type": "object",
+				"properties": {
+					"value": {
+						"type": "object",
+						"properties": {
+							"timestamp_ms": {"type": "number"},
+							"value": {"type": "number"}
+						},
+						"required": ["timestamp_ms", "value"],
+						"additionalProperties": false
+					}
+				},
+				"additionalProperties": false
+			}
+		},
+		"required": ["virtual_path", "fields"],
+		"additionalProperties": false
+	}`
+	m.AddSchema("_motor_controller", 3, motorDataV3)
+
+	// Add a string value schema for testing different data types
+	stringDataV1 := `{
+		"type": "object",
+		"properties": {
+			"virtual_path": {
+				"type": "string",
+				"enum": ["serialNumber", "status"]
+			},
+			"fields": {
+				"type": "object",
+				"properties": {
+					"value": {
+						"type": "object",
+						"properties": {
+							"timestamp_ms": {"type": "number"},
+							"value": {"type": "string"}
+						},
+						"required": ["timestamp_ms", "value"],
+						"additionalProperties": false
+					}
+				},
+				"additionalProperties": false
+			}
+		},
+		"required": ["virtual_path", "fields"],
+		"additionalProperties": false
+	}`
+	m.AddSchema("_string_data", 1, stringDataV1)
+}
+
+// SimulateNetworkError makes the mock server return 500 errors for testing
+func (m *MockSchemaRegistry) SimulateNetworkError(enable bool) {
+	if enable {
+		// Replace handlers with error handlers
+		mux := http.NewServeMux()
+		mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
+			http.Error(w, "Internal Server Error", http.StatusInternalServerError)
+		})
+		m.server.Config.Handler = mux
+	} else {
+		// Restore normal handlers
+		mux := http.NewServeMux()
+		mux.HandleFunc("/subjects", m.handleSubjects)
+		mux.HandleFunc("/subjects/", m.handleSubjectVersions)
+		m.server.Config.Handler = mux
+	}
+}
+
+// GetRegisteredSubjects returns all subjects currently in the mock registry
+func (m *MockSchemaRegistry) GetRegisteredSubjects() []string {
+	var subjects []string
+	for subject := range m.schemas {
+		subjects = append(subjects, subject)
+	}
+	return subjects
+}
+
+// GetVersionsForSubject returns all versions for a given subject
+func (m *MockSchemaRegistry) GetVersionsForSubject(subject string) []int {
+	var versions []int
+	if subjectVersions, exists := m.schemas[subject]; exists {
+		for version := range subjectVersions {
+			versions = append(versions, version)
+		}
+	}
+	return versions
+}
diff --git c/uns_plugin/schema_validation/redpanda_integration_test.go w/uns_plugin/schema_validation/redpanda_integration_test.go
new file mode 100644
index 0000000..47d6325
--- /dev/null
+++ w/uns_plugin/schema_validation/redpanda_integration_test.go
@@ -0,0 +1,682 @@
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package schemavalidation
+
+import (
+	"bytes"
+	"encoding/json"
+	"fmt"
+	"net/http"
+	"os/exec"
+	"sort"
+	"strings"
+	"time"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+	"github.com/united-manufacturing-hub/benthos-umh/pkg/umh/topic"
+)
+
+const (
+	redpandaContainerName      = "benthos-umh-test-redpanda"
+	redpandaSchemaRegistryURL  = "http://localhost:8081"
+	redpandaKafkaPort          = "9092"
+	redpandaSchemaRegistryPort = "8081"
+)
+
+// RedpandaTestSchemas contains the test schemas we'll load into Redpanda
+// We'll add a timestamp suffix to avoid conflicts between test runs
+var redpandaTestSchemas = map[string]map[int]string{
+	"_sensor_data": {
+		1: `{
+			"type": "object",
+			"properties": {
+				"virtual_path": {
+					"type": "string",
+					"enum": ["temperature"]
+				},
+				"fields": {
+					"type": "object",
+					"properties": {
+						"value": {
+							"type": "object",
+							"properties": {
+								"timestamp_ms": {"type": "number"},
+								"value": {"type": "number"}
+							},
+							"required": ["timestamp_ms", "value"],
+							"additionalProperties": false
+						}
+					},
+					"additionalProperties": false
+				}
+			},
+			"required": ["virtual_path", "fields"],
+			"additionalProperties": false
+		}`,
+		2: `{
+			"type": "object",
+			"properties": {
+				"virtual_path": {
+					"type": "string",
+					"enum": ["temperature", "humidity", "pressure"]
+				},
+				"fields": {
+					"type": "object",
+					"properties": {
+						"value": {
+							"type": "object",
+							"properties": {
+								"timestamp_ms": {"type": "number"},
+								"value": {"type": "number"}
+							},
+							"required": ["timestamp_ms", "value"],
+							"additionalProperties": false
+						}
+					},
+					"additionalProperties": false
+				}
+			},
+			"required": ["virtual_path", "fields"],
+			"additionalProperties": false
+		}`,
+	},
+	"_pump_data": {
+		1: `{
+			"type": "object",
+			"properties": {
+				"virtual_path": {
+					"type": "string",
+					"enum": ["vibration.x-axis", "vibration.y-axis", "count"]
+				},
+				"fields": {
+					"type": "object",
+					"properties": {
+						"value": {
+							"type": "object",
+							"properties": {
+								"timestamp_ms": {"type": "number"},
+								"value": {"type": "number"}
+							},
+							"required": ["timestamp_ms", "value"],
+							"additionalProperties": false
+						}
+					},
+					"additionalProperties": false
+				}
+			},
+			"required": ["virtual_path", "fields"],
+			"additionalProperties": false
+		}`,
+	},
+	"_string_data": {
+		1: `{
+			"type": "object",
+			"properties": {
+				"virtual_path": {
+					"type": "string",
+					"enum": ["serialNumber", "status"]
+				},
+				"fields": {
+					"type": "object",
+					"properties": {
+						"value": {
+							"type": "object",
+							"properties": {
+								"timestamp_ms": {"type": "number"},
+								"value": {"type": "string"}
+							},
+							"required": ["timestamp_ms", "value"],
+							"additionalProperties": false
+						}
+					},
+					"additionalProperties": false
+				}
+			},
+			"required": ["virtual_path", "fields"],
+			"additionalProperties": false
+		}`,
+	},
+}
+
+// RedpandaSchemaRegistryClient for interacting with real Redpanda schema registry
+type RedpandaSchemaRegistryClient struct {
+	baseURL    string
+	httpClient *http.Client
+}
+
+func NewRedpandaSchemaRegistryClient(baseURL string) *RedpandaSchemaRegistryClient {
+	return &RedpandaSchemaRegistryClient{
+		baseURL: baseURL,
+		httpClient: &http.Client{
+			Timeout: 30 * time.Second,
+		},
+	}
+}
+
+func (c *RedpandaSchemaRegistryClient) RegisterSchema(subject string, version int, schema string) error {
+	// Schema must be properly escaped as a JSON string
+	// Create the schema registration payload with properly escaped JSON
+	payload := map[string]interface{}{
+		"schema":     schema,
+		"schemaType": "JSON",
+	}
+
+	payloadBytes, err := json.Marshal(payload)
+	if err != nil {
+		return fmt.Errorf("failed to marshal schema payload: %w", err)
+	}
+
+	// Register the schema with a specific version
+	url := fmt.Sprintf("%s/subjects/%s/versions", c.baseURL, subject)
+	req, err := http.NewRequest("POST", url, bytes.NewBuffer(payloadBytes))
+	if err != nil {
+		return fmt.Errorf("failed to create request: %w", err)
+	}
+
+	req.Header.Set("Content-Type", "application/vnd.schemaregistry.v1+json")
+
+	resp, err := c.httpClient.Do(req)
+	if err != nil {
+		return fmt.Errorf("failed to register schema: %w", err)
+	}
+	defer resp.Body.Close()
+
+	if resp.StatusCode != 200 && resp.StatusCode != 201 {
+		// Read response body for debugging
+		bodyBytes := make([]byte, 1024)
+		resp.Body.Read(bodyBytes)
+		return fmt.Errorf("schema registration failed with status %d, body: %s", resp.StatusCode, string(bodyBytes))
+	}
+
+	return nil
+}
+
+func (c *RedpandaSchemaRegistryClient) WaitForReady() error {
+	ready := false
+	Eventually(func() bool {
+		resp, err := c.httpClient.Get(c.baseURL + "/subjects")
+		if err == nil && resp.StatusCode == 200 {
+			resp.Body.Close()
+			ready = true
+			return true
+		}
+		if resp != nil {
+			resp.Body.Close()
+		}
+		return false
+	}, "60s", "2s").Should(BeTrue(), "Schema registry should be ready")
+
+	if !ready {
+		return fmt.Errorf("schema registry not ready after timeout")
+	}
+	return nil
+}
+
+func (c *RedpandaSchemaRegistryClient) DeleteAllSubjects() error {
+	// Get all subjects
+	resp, err := c.httpClient.Get(c.baseURL + "/subjects")
+	if err != nil {
+		return fmt.Errorf("failed to get subjects: %w", err)
+	}
+	defer resp.Body.Close()
+
+	if resp.StatusCode != 200 {
+		return fmt.Errorf("failed to get subjects, status: %d", resp.StatusCode)
+	}
+
+	var subjects []string
+	if err := json.NewDecoder(resp.Body).Decode(&subjects); err != nil {
+		return fmt.Errorf("failed to decode subjects: %w", err)
+	}
+
+	// Delete each subject (hard delete)
+	for _, subject := range subjects {
+		// First do a soft delete
+		req, err := http.NewRequest("DELETE", c.baseURL+"/subjects/"+subject, nil)
+		if err != nil {
+			continue
+		}
+		resp, err := c.httpClient.Do(req)
+		if err != nil {
+			continue
+		}
+		resp.Body.Close()
+
+		// Then do a hard delete to permanently remove
+		req, err = http.NewRequest("DELETE", c.baseURL+"/subjects/"+subject+"?permanent=true", nil)
+		if err != nil {
+			continue
+		}
+		resp, err = c.httpClient.Do(req)
+		if err != nil {
+			continue
+		}
+		resp.Body.Close()
+	}
+
+	return nil
+}
+
+func cleanupRedpandaContainer() {
+	// Kill and remove any existing container with our name
+	exec.Command("docker", "kill", redpandaContainerName).Run()
+	exec.Command("docker", "rm", "-f", redpandaContainerName).Run()
+
+	// Wait for container to be removed completely
+	Eventually(func() bool {
+		cmd := exec.Command("docker", "ps", "-a", "-q", "--filter", fmt.Sprintf("name=%s", redpandaContainerName))
+		output, err := cmd.Output()
+		return err != nil || len(output) == 0
+	}, "15s", "1s").Should(BeTrue(), "Container should be removed completely")
+}
+
+func startRedpandaContainer() error {
+	// Clean up any existing container first
+	cleanupRedpandaContainer()
+
+	// Start Redpanda container
+	cmd := exec.Command("docker", "run", "-d",
+		"--name", redpandaContainerName,
+		"-p", fmt.Sprintf("%s:9092", redpandaKafkaPort),
+		"-p", fmt.Sprintf("%s:8081", redpandaSchemaRegistryPort),
+		"-p", "8082:8082",
+		"-p", "9644:9644",
+		"redpandadata/redpanda:latest",
+		"redpanda", "start",
+		"--overprovisioned",
+		"--smp", "1",
+		"--memory", "1G",
+		"--reserve-memory", "0M",
+		"--node-id", "0",
+		"--check=false")
+
+	output, err := cmd.CombinedOutput()
+	if err != nil {
+		return fmt.Errorf("failed to start Redpanda container: %w, output: %s", err, string(output))
+	}
+
+	// Wait for Redpanda to actually start up successfully
+	redpandaStarted := false
+	Eventually(func() bool {
+		// Check container logs for successful startup message
+		logsCmd := exec.Command("docker", "logs", redpandaContainerName)
+		logsOutput, err := logsCmd.CombinedOutput()
+		if err != nil {
+			return false
+		}
+
+		logsStr := string(logsOutput)
+		if strings.Contains(logsStr, "Successfully started Redpanda!") {
+			redpandaStarted = true
+			return true
+		}
+
+		return false
+	}, "60s", "2s").Should(BeTrue(), "Redpanda should start successfully")
+
+	if !redpandaStarted {
+		// On failure, dump full logs for debugging
+		logsCmd := exec.Command("docker", "logs", redpandaContainerName)
+		logsOutput, _ := logsCmd.CombinedOutput()
+		return fmt.Errorf("Redpanda failed to start within timeout. Full logs:\n%s", string(logsOutput))
+	}
+
+	return nil
+}
+
+func setupRedpandaSchemas() error {
+	client := NewRedpandaSchemaRegistryClient(redpandaSchemaRegistryURL)
+
+	// Wait for schema registry to be ready
+	if err := client.WaitForReady(); err != nil {
+		return fmt.Errorf("schema registry not ready: %w", err)
+	}
+
+	// Clean up any existing schemas first
+	if err := client.DeleteAllSubjects(); err != nil {
+		return fmt.Errorf("failed to cleanup existing schemas: %w", err)
+	}
+
+	// Wait for schemas to be fully removed
+	Eventually(func() bool {
+		resp, err := client.httpClient.Get(client.baseURL + "/subjects")
+		if err != nil {
+			return false
+		}
+		defer resp.Body.Close()
+
+		if resp.StatusCode != 200 {
+			return false
+		}
+
+		var subjects []string
+		if err := json.NewDecoder(resp.Body).Decode(&subjects); err != nil {
+			return false
+		}
+
+		return len(subjects) == 0
+	}, "10s", "500ms").Should(BeTrue(), "Schemas should be fully removed after cleanup")
+
+	// Register all test schemas in version order
+	for subject, versions := range redpandaTestSchemas {
+		// Get versions in sorted order to ensure consistent registration
+		var sortedVersions []int
+		for version := range versions {
+			sortedVersions = append(sortedVersions, version)
+		}
+
+		// Sort versions to ensure we register in ascending order
+		sort.Ints(sortedVersions)
+
+		for _, version := range sortedVersions {
+			schema := versions[version]
+			if err := client.RegisterSchema(subject, version, schema); err != nil {
+				return fmt.Errorf("failed to register schema %s v%d: %w", subject, version, err)
+			}
+		}
+	}
+
+	return nil
+}
+
+var _ = Describe("Real Redpanda Integration Tests", Ordered, Label("redpanda"), func() {
+	var validator *Validator
+
+	BeforeAll(func() {
+		// Skip if Docker is not available
+		if _, err := exec.LookPath("docker"); err != nil {
+			Skip("Docker not available, skipping Redpanda integration tests")
+		}
+
+		// Check if Docker daemon is running
+		if err := exec.Command("docker", "info").Run(); err != nil {
+			Skip("Docker daemon not running, skipping Redpanda integration tests")
+		}
+
+		By("Starting Redpanda container")
+		Expect(startRedpandaContainer()).To(Succeed())
+
+		By("Setting up test schemas in Redpanda")
+		Expect(setupRedpandaSchemas()).To(Succeed())
+
+		By("Creating validator with real schema registry")
+		validator = NewValidatorWithRegistry(redpandaSchemaRegistryURL)
+		Expect(validator).NotTo(BeNil())
+	})
+
+	AfterAll(func() {
+		if validator != nil {
+			validator.Close()
+		}
+
+		By("Cleaning up Redpanda container")
+		cleanupRedpandaContainer()
+	})
+
+	Context("when validating against real Redpanda schema registry", Ordered, func() {
+		It("should successfully validate sensor data v1", func() {
+			// Create UNS topic with unique suffix
+			contractName := "_sensor_data"
+			unsTopic, err := topic.NewUnsTopic(fmt.Sprintf("umh.v1.enterprise.site.area.%s-v1.temperature", contractName))
+			Expect(err).To(BeNil())
+
+			// Create valid payload
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			// With synchronous fetching, schema should be loaded immediately
+			result := validator.Validate(unsTopic, payload)
+			GinkgoWriter.Printf("Validation result: SchemaCheckPassed=%v, SchemaCheckBypassed=%v, BypassReason=%s, Error=%v\n",
+				result.SchemaCheckPassed, result.SchemaCheckBypassed, result.BypassReason, result.Error)
+
+			// Check if schema was loaded
+			hasSchema := validator.HasSchema(contractName, 1)
+			GinkgoWriter.Printf("Has schema %s v1: %v\n", contractName, hasSchema)
+
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(BeNil())
+			Expect(result.ContractName).To(Equal(contractName))
+			Expect(result.ContractVersion).To(Equal(uint64(1)))
+		})
+
+		It("should reject invalid virtual path for sensor data v1", func() {
+			// Load schema first by validating a valid message
+			validTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+			validPayload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			// Trigger schema load if not already loaded
+			Eventually(func() bool {
+				result := validator.Validate(validTopic, validPayload)
+				return result.SchemaCheckPassed && !result.SchemaCheckBypassed
+			}, "10s", "500ms").Should(BeTrue(), "Schema should be loaded for valid topic")
+
+			// Get the result for further testing
+			result := validator.Validate(validTopic, validPayload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+
+			// Now test invalid virtual path
+			invalidTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.humidity")
+			Expect(err).To(BeNil())
+
+			result = validator.Validate(invalidTopic, validPayload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+			Expect(result.Error.Error()).To(ContainSubstring("schema validation failed"))
+		})
+
+		It("should validate sensor data v2 with expanded virtual paths", func() {
+			// Test temperature (allowed in both v1 and v2)
+			tempTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v2.temperature")
+			Expect(err).To(BeNil())
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			result := validator.Validate(tempTopic, payload)
+			GinkgoWriter.Printf("V2 temperature validation result: SchemaCheckPassed=%v, SchemaCheckBypassed=%v, BypassReason=%s, Error=%v\n",
+				result.SchemaCheckPassed, result.SchemaCheckBypassed, result.BypassReason, result.Error)
+
+			// With synchronous fetching, schema should be loaded immediately on first validation
+			if result.SchemaCheckBypassed {
+				Fail(fmt.Sprintf("Schema validation was bypassed unexpectedly: %s", result.BypassReason))
+			}
+
+			// Check if schema was loaded
+			hasSchema := validator.HasSchema("_sensor_data", 2)
+			GinkgoWriter.Printf("Has schema _sensor_data v2: %v\n", hasSchema)
+
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.ContractVersion).To(Equal(uint64(2)))
+
+			// Test humidity (allowed in v2 but not v1)
+			humidityTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v2.humidity")
+			Expect(err).To(BeNil())
+
+			result = validator.Validate(humidityTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.ContractVersion).To(Equal(uint64(2)))
+
+			// Test pressure (allowed in v2 but not v1)
+			pressureTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v2.pressure")
+			Expect(err).To(BeNil())
+			pressurePayload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 1013.25}}`)
+
+			result = validator.Validate(pressureTopic, pressurePayload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.ContractVersion).To(Equal(uint64(2)))
+		})
+
+		It("should validate pump data with complex virtual paths", func() {
+			// Test vibration.x-axis
+			xAxisTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._pump_data-v1.vibration.x-axis")
+			Expect(err).To(BeNil())
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 0.5}}`)
+
+			result := validator.Validate(xAxisTopic, payload)
+			GinkgoWriter.Printf("First pump data validation result: SchemaCheckPassed=%v, SchemaCheckBypassed=%v, BypassReason=%s, Error=%v\n",
+				result.SchemaCheckPassed, result.SchemaCheckBypassed, result.BypassReason, result.Error)
+
+			// With synchronous fetching, schema should be loaded immediately on first validation
+			if result.SchemaCheckBypassed {
+				Fail(fmt.Sprintf("Schema validation was bypassed unexpectedly: %s", result.BypassReason))
+			}
+
+			// Check if schema was loaded
+			hasSchema := validator.HasSchema("_pump_data", 1)
+			GinkgoWriter.Printf("Has schema _pump_data v1: %v\n", hasSchema)
+
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.ContractName).To(Equal("_pump_data"))
+
+			// Test vibration.y-axis
+			yAxisTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._pump_data-v1.vibration.y-axis")
+			Expect(err).To(BeNil())
+
+			result = validator.Validate(yAxisTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+
+			// Test count
+			countTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._pump_data-v1.count")
+			Expect(err).To(BeNil())
+			countPayload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 1542}}`)
+
+			result = validator.Validate(countTopic, countPayload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+		})
+
+		It("should validate string data types correctly", func() {
+			// Test serialNumber
+			serialTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._string_data-v1.serialNumber")
+			Expect(err).To(BeNil())
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": "SN123456789"}}`)
+
+			Eventually(func() bool {
+				result := validator.Validate(serialTopic, payload)
+				return result.SchemaCheckPassed && !result.SchemaCheckBypassed
+			}, "10s", "500ms").Should(BeTrue(), "String data schema should be loaded and validation should pass")
+
+			result := validator.Validate(serialTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.ContractName).To(Equal("_string_data"))
+
+			// Test status
+			statusTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._string_data-v1.status")
+			Expect(err).To(BeNil())
+			statusPayload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": "RUNNING"}}`)
+
+			result = validator.Validate(statusTopic, statusPayload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+		})
+
+		It("should reject invalid payload formats", func() {
+			// Load schema first
+			validTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+			validPayload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			Eventually(func() bool {
+				result := validator.Validate(validTopic, validPayload)
+				return result.SchemaCheckPassed && !result.SchemaCheckBypassed
+			}, "10s", "500ms").Should(BeTrue(), "Schema should be loaded for invalid payload test")
+
+			result := validator.Validate(validTopic, validPayload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+
+			// Test missing timestamp_ms
+			invalidPayload := []byte(`{"value": {"value": 25.5}}`)
+			result = validator.Validate(validTopic, invalidPayload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+
+			// Test wrong value type
+			invalidPayload = []byte(`{"value": {"timestamp_ms": 1719859200000, "value": "not_a_number"}}`)
+			result = validator.Validate(validTopic, invalidPayload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+		})
+
+		It("should reject wrong data types for string fields", func() {
+			// Load schema first
+			validTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._string_data-v1.serialNumber")
+			Expect(err).To(BeNil())
+			validPayload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": "SN123456789"}}`)
+
+			Eventually(func() bool {
+				result := validator.Validate(validTopic, validPayload)
+				return result.SchemaCheckPassed && !result.SchemaCheckBypassed
+			}, "10s", "500ms").Should(BeTrue(), "String data schema should be loaded for data type test")
+
+			result := validator.Validate(validTopic, validPayload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+
+			// Test providing number instead of string
+			invalidPayload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 12345}}`)
+			result = validator.Validate(validTopic, invalidPayload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+		})
+
+		It("should handle non-existent schemas gracefully", func() {
+			// Test with a contract that doesn't exist
+			nonExistentTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._non_existent_contract-v1.temperature")
+			Expect(err).To(BeNil())
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			result := validator.Validate(nonExistentTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+			Expect(result.BypassReason).To(ContainSubstring("schema for contract '_non_existent_contract' version 1 does not exist in registry"))
+
+			// Wait for background fetch attempt and verify it still bypasses
+			Eventually(func() bool {
+				result = validator.Validate(nonExistentTopic, payload)
+				return result.SchemaCheckBypassed
+			}, "10s", "500ms").Should(BeTrue(), "Non-existent schema should still bypass after background fetch attempt")
+
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+		})
+
+		It("should handle unversioned contracts gracefully", func() {
+			// Test with an unversioned contract
+			unversionedTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._unversioned_contract.temperature")
+			Expect(err).To(BeNil())
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			result := validator.Validate(unversionedTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+			Expect(result.BypassReason).To(ContainSubstring("unversioned contract '_unversioned_contract' - bypassing validation (no latest fetching)"))
+			Expect(result.Error).To(BeNil())
+		})
+	})
+
+	Context("when testing foreground fetcher against real registry", func() {
+		It("should automatically fetch schemas in the foreground", func() {
+			// Create a fresh validator to test foreground fetching
+			freshValidator := NewValidatorWithRegistry(redpandaSchemaRegistryURL)
+			defer freshValidator.Close()
+
+			// Create topic that will trigger foreground fetch
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			// First validation should not bypass
+			result := freshValidator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+		})
+	})
+})
diff --git c/uns_plugin/schema_validation/schema.go w/uns_plugin/schema_validation/schema.go
new file mode 100644
index 0000000..f92536d
--- /dev/null
+++ w/uns_plugin/schema_validation/schema.go
@@ -0,0 +1,93 @@
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Package schemavalidation provides JSON schema validation functionality for UNS topics.
+// It manages schema compilation, versioning, and validation operations with thread-safe access.
+package schemavalidation
+
+import (
+	"fmt"
+	"sync"
+
+	"github.com/kaptinlin/jsonschema"
+)
+
+// Global schema compiler and mutex for thread-safe schema compilation.
+// These are shared across all schema instances to optimize compilation performance.
+var (
+	schemaCompiler      = jsonschema.NewCompiler()
+	schemaCompilerMutex sync.RWMutex
+)
+
+// SchemaVersion represents a compiled JSON schema for a specific version.
+type SchemaVersion struct {
+	JSONSchema *jsonschema.Schema
+}
+
+// SchemaVersions manages multiple versions of a schema.
+type SchemaVersions struct {
+	Versions map[uint64]SchemaVersion
+}
+
+// Schema represents a named schema with multiple versions.
+type Schema struct {
+	Name     string
+	Versions SchemaVersions
+}
+
+// NewSchema creates a new Schema with the given name and initializes an empty version map.
+func NewSchema(name string) *Schema {
+	return &Schema{
+		Name:     name,
+		Versions: SchemaVersions{Versions: make(map[uint64]SchemaVersion)},
+	}
+}
+
+// AddVersion compiles and adds a new schema version to this Schema.
+// It returns an error if schema compilation fails.
+func (s *Schema) AddVersion(version uint64, schema []byte) error {
+	schemaCompilerMutex.Lock()
+	defer schemaCompilerMutex.Unlock()
+
+	compiledSchema, err := schemaCompiler.Compile(schema)
+	if err != nil {
+		return fmt.Errorf("failed to compile schema for version %d: %w", version, err)
+	}
+
+	s.Versions.Versions[version] = SchemaVersion{
+		JSONSchema: compiledSchema,
+	}
+	return nil
+}
+
+// HasVersion checks if a specific version exists and has a valid compiled schema.
+func (s *Schema) HasVersion(version uint64) bool {
+	schemaCompilerMutex.RLock()
+	defer schemaCompilerMutex.RUnlock()
+
+	schemaVersion, exists := s.Versions.Versions[version]
+	return exists && schemaVersion.JSONSchema != nil
+}
+
+// GetVersion retrieves the compiled JSON schema for the specified version.
+// Returns nil if the version doesn't exist.
+func (s *Schema) GetVersion(version uint64) *jsonschema.Schema {
+	schemaCompilerMutex.RLock()
+	defer schemaCompilerMutex.RUnlock()
+
+	if schemaVersion, exists := s.Versions.Versions[version]; exists {
+		return schemaVersion.JSONSchema
+	}
+	return nil
+}
diff --git c/uns_plugin/schema_validation/schema_validation_suite_test.go w/uns_plugin/schema_validation/schema_validation_suite_test.go
new file mode 100644
index 0000000..69b8317
--- /dev/null
+++ w/uns_plugin/schema_validation/schema_validation_suite_test.go
@@ -0,0 +1,27 @@
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package schemavalidation_test
+
+import (
+	"testing"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+)
+
+func TestSchemaValidation(t *testing.T) {
+	RegisterFailHandler(Fail)
+	RunSpecs(t, "SchemaValidation Suite")
+}
diff --git c/uns_plugin/schema_validation/validator.go w/uns_plugin/schema_validation/validator.go
new file mode 100644
index 0000000..5e7f1bf
--- /dev/null
+++ w/uns_plugin/schema_validation/validator.go
@@ -0,0 +1,455 @@
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package schemavalidation
+
+import (
+	"encoding/json"
+	"fmt"
+	"io"
+	"net/http"
+	"regexp"
+	"strconv"
+	"strings"
+	"sync"
+	"time"
+
+	"github.com/united-manufacturing-hub/benthos-umh/pkg/umh/topic"
+)
+
+const (
+	cacheHitTTL  = 0                // Cache successful schema fetches forever (schemas are immutable)
+	cacheMissTTL = 10 * time.Minute // Cache misses for 10 minutes to retry sooner
+	httpTimeout  = 30 * time.Second
+)
+
+// schemaVersionRegex matches data contract names with version suffixes.
+// Expected format: "contractname-v123" where 123 is the version number.
+var schemaVersionRegex = regexp.MustCompile(`^(.+)-v(\d+)$`)
+
+// ValidationResult contains information about the validation result and the contract used.
+type ValidationResult struct {
+	// SchemaCheckPassed indicates whether the schema validation passed
+	SchemaCheckPassed bool
+	// SchemaCheckBypassed indicates whether the schema validation was bypassed
+	SchemaCheckBypassed bool
+	// ContractName is the name of the contract that was validated against
+	ContractName string
+	// ContractVersion is the version of the contract that was validated against
+	ContractVersion uint64
+	// BypassReason indicates why validation was bypassed (empty if not bypassed)
+	BypassReason string
+	// Error contains the validation error if validation failed
+	Error error
+}
+
+// CacheEntry represents a cached schema entry with TTL
+type CacheEntry struct {
+	// Schema holds the actual schema if it exists, nil if schema doesn't exist
+	Schema *Schema
+	// SchemaExists indicates whether the schema exists in the registry
+	SchemaExists bool
+	// CachedAt is when this entry was cached
+	CachedAt time.Time
+	// ExpiredAt is when this entry expires
+	ExpiresAt time.Time
+}
+
+// IsExpired checks if the cache entry has expired
+func (ce *CacheEntry) IsExpired() bool {
+	// Zero time means never expires (for immutable schema hits)
+	if ce.ExpiresAt.IsZero() {
+		return false
+	}
+	return time.Now().After(ce.ExpiresAt)
+}
+
+// SchemaRegistryVersion represents a version response from the schema registry
+type SchemaRegistryVersion struct {
+	Version int    `json:"version"`
+	ID      int    `json:"id"`
+	Schema  string `json:"schema"`
+}
+
+// Validator manages schema validation for UNS topics with TTL-based caching.
+type Validator struct {
+	// Cache maps "contractName-v123" to CacheEntry
+	schemaCache       map[string]*CacheEntry
+	cacheMutex        sync.RWMutex
+	schemaRegistryURL string
+	httpClient        *http.Client
+}
+
+// NewValidator creates a new Validator instance with empty cache.
+func NewValidator() *Validator {
+	return &Validator{
+		schemaCache: make(map[string]*CacheEntry),
+		httpClient: &http.Client{
+			Timeout: httpTimeout,
+		},
+	}
+}
+
+// NewValidatorWithRegistry creates a new Validator instance with the specified schema registry URL.
+func NewValidatorWithRegistry(schemaRegistryURL string) *Validator {
+	return &Validator{
+		schemaCache:       make(map[string]*CacheEntry),
+		schemaRegistryURL: schemaRegistryURL,
+		httpClient: &http.Client{
+			Timeout: httpTimeout,
+		},
+	}
+}
+
+// Validate validates the given UNS topic and payload against the registered schema.
+// It extracts the contract and version from the topic, finds the appropriate schema,
+// and validates the payload structure. Returns a ValidationResult with contract information.
+func (v *Validator) Validate(unsTopic *topic.UnsTopic, payload []byte) *ValidationResult {
+	if unsTopic == nil {
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: false,
+			Error:               fmt.Errorf("UNS topic cannot be nil"),
+		}
+	}
+
+	topicInfo := unsTopic.Info()
+	if topicInfo == nil {
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: false,
+			Error:               fmt.Errorf("topic info is nil"),
+		}
+	}
+
+	contract := topicInfo.DataContract
+	if contract == "" {
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: false,
+			Error:               fmt.Errorf("data contract is empty"),
+		}
+	}
+
+	contractName, version, err := v.ExtractSchemaVersionFromDataContract(contract)
+	if err != nil {
+		// For unversioned contracts, always bypass (no fetching of "latest")
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: true,
+			ContractName:        contract, // Use the original contract string as fallback
+			ContractVersion:     0,
+			BypassReason:        fmt.Sprintf("unversioned contract '%s' - bypassing validation (no latest fetching)", contract),
+			Error:               nil,
+		}
+	}
+
+	// Get schema from cache or fetch synchronously
+	schema, schemaExists, err := v.getSchemaWithCache(contractName, version)
+	if err != nil {
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: true,
+			ContractName:        contractName,
+			ContractVersion:     version,
+			BypassReason:        fmt.Sprintf("failed to fetch schema: %v", err),
+			Error:               nil,
+		}
+	}
+
+	if !schemaExists {
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: true,
+			ContractName:        contractName,
+			ContractVersion:     version,
+			BypassReason:        fmt.Sprintf("schema for contract '%s' version %d does not exist in registry", contractName, version),
+			Error:               nil,
+		}
+	}
+
+	if schema == nil {
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: true,
+			ContractName:        contractName,
+			ContractVersion:     version,
+			BypassReason:        fmt.Sprintf("schema for contract '%s' version %d is nil", contractName, version),
+			Error:               nil,
+		}
+	}
+
+	jsonSchema := schema.GetVersion(version)
+	if jsonSchema == nil {
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: true,
+			ContractName:        contractName,
+			ContractVersion:     version,
+			BypassReason:        fmt.Sprintf("compiled schema for contract '%s' version %d is nil", contractName, version),
+			Error:               nil,
+		}
+	}
+
+	// Build the full path for validation
+	var fullPath strings.Builder
+	if topicInfo.VirtualPath != nil {
+		fullPath.WriteString(*topicInfo.VirtualPath)
+		fullPath.WriteString(".")
+	}
+	fullPath.WriteString(topicInfo.Name)
+
+	// Wrap the payload with fields and virtual_path for validation
+	wrappedPayload := []byte(fmt.Sprintf(`{"fields": %s, "virtual_path": "%s"}`,
+		string(payload), fullPath.String()))
+
+	validationResult := jsonSchema.ValidateJSON(wrappedPayload)
+	if validationResult == nil {
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: false,
+			ContractName:        contractName,
+			ContractVersion:     version,
+			Error:               fmt.Errorf("schema validation result is nil"),
+		}
+	}
+
+	if !validationResult.Valid {
+		var validationErrors []string
+		for _, validationErr := range validationResult.Errors {
+			validationErrors = append(validationErrors, validationErr.Error())
+		}
+		return &ValidationResult{
+			SchemaCheckPassed:   false,
+			SchemaCheckBypassed: false,
+			ContractName:        contractName,
+			ContractVersion:     version,
+			Error: fmt.Errorf("schema validation failed for contract '%s' version %d: %s",
+				contractName, version, strings.Join(validationErrors, "; ")),
+		}
+	}
+
+	return &ValidationResult{
+		SchemaCheckPassed:   true,
+		SchemaCheckBypassed: false,
+		ContractName:        contractName,
+		ContractVersion:     version,
+		Error:               nil,
+	}
+}
+
+// getSchemaWithCache retrieves schema from cache or fetches it synchronously
+func (v *Validator) getSchemaWithCache(contractName string, version uint64) (*Schema, bool, error) {
+	cacheKey := fmt.Sprintf("%s-v%d", contractName, version)
+
+	// Check cache first
+	v.cacheMutex.RLock()
+	entry, exists := v.schemaCache[cacheKey]
+	v.cacheMutex.RUnlock()
+
+	if exists && !entry.IsExpired() {
+		// Cache hit and not expired
+		return entry.Schema, entry.SchemaExists, nil
+	}
+
+	// Cache miss or expired, fetch synchronously
+	return v.fetchSchemaSync(contractName, version)
+}
+
+// fetchSchemaSync fetches schema synchronously and updates cache
+func (v *Validator) fetchSchemaSync(contractName string, version uint64) (*Schema, bool, error) {
+	cacheKey := fmt.Sprintf("%s-v%d", contractName, version)
+
+	// Double-check locking pattern
+	v.cacheMutex.Lock()
+	defer v.cacheMutex.Unlock()
+
+	// Check if another goroutine already fetched it
+	if entry, exists := v.schemaCache[cacheKey]; exists && !entry.IsExpired() {
+		return entry.Schema, entry.SchemaExists, nil
+	}
+
+	// Fetch from registry
+	schemaBytes, schemaExists, err := v.fetchSchemaFromRegistry(contractName, version)
+	if err != nil {
+		// Cache the error result (schema doesn't exist or fetch failed)
+		v.schemaCache[cacheKey] = &CacheEntry{
+			Schema:       nil,
+			SchemaExists: false,
+			CachedAt:     time.Now(),
+			ExpiresAt:    time.Now().Add(cacheMissTTL),
+		}
+		return nil, false, err
+	}
+
+	if !schemaExists {
+		// Cache the fact that schema doesn't exist
+		v.schemaCache[cacheKey] = &CacheEntry{
+			Schema:       nil,
+			SchemaExists: false,
+			CachedAt:     time.Now(),
+			ExpiresAt:    time.Now().Add(cacheMissTTL),
+		}
+		return nil, false, nil
+	}
+
+	// Compile the schema
+	schema := NewSchema(contractName)
+	if err := schema.AddVersion(version, schemaBytes); err != nil {
+		// Cache the compilation error
+		v.schemaCache[cacheKey] = &CacheEntry{
+			Schema:       nil,
+			SchemaExists: false,
+			CachedAt:     time.Now(),
+			ExpiresAt:    time.Now().Add(cacheMissTTL),
+		}
+		return nil, false, fmt.Errorf("failed to compile schema: %w", err)
+	}
+
+	// Cache the successful result - forever since schemas are immutable
+	expiresAt := time.Time{} // Zero time means never expires
+	if cacheHitTTL > 0 {
+		expiresAt = time.Now().Add(cacheHitTTL)
+	}
+	v.schemaCache[cacheKey] = &CacheEntry{
+		Schema:       schema,
+		SchemaExists: true,
+		CachedAt:     time.Now(),
+		ExpiresAt:    expiresAt,
+	}
+
+	return schema, true, nil
+}
+
+// fetchSchemaFromRegistry fetches schema from the registry
+func (v *Validator) fetchSchemaFromRegistry(contractName string, version uint64) ([]byte, bool, error) {
+	if v.schemaRegistryURL == "" {
+		return nil, false, fmt.Errorf("schema registry URL is not configured")
+	}
+
+	url := fmt.Sprintf("%s/subjects/%s/versions/%d", v.schemaRegistryURL, contractName, version)
+
+	resp, err := v.httpClient.Get(url)
+	if err != nil {
+		return nil, false, fmt.Errorf("failed to fetch schema from registry: %w", err)
+	}
+	defer resp.Body.Close()
+
+	if resp.StatusCode == http.StatusNotFound {
+		return nil, false, nil // Schema doesn't exist
+	}
+
+	if resp.StatusCode != http.StatusOK {
+		return nil, false, fmt.Errorf("schema registry returned status %d", resp.StatusCode)
+	}
+
+	body, err := io.ReadAll(resp.Body)
+	if err != nil {
+		return nil, false, fmt.Errorf("failed to read schema response: %w", err)
+	}
+
+	var versionResp SchemaRegistryVersion
+	if err := json.Unmarshal(body, &versionResp); err != nil {
+		return nil, false, fmt.Errorf("failed to unmarshal schema response: %w", err)
+	}
+
+	return []byte(versionResp.Schema), true, nil
+}
+
+// ExtractSchemaVersionFromDataContract parses a data contract string to extract
+// the base contract name and version number.
+// Expected format: "contractname-v123" -> ("contractname", 123, nil)
+func (v *Validator) ExtractSchemaVersionFromDataContract(contract string) (contractName string, version uint64, err error) {
+	if contract == "" {
+		return "", 0, fmt.Errorf("contract string is empty")
+	}
+
+	matches := schemaVersionRegex.FindStringSubmatch(contract)
+	if len(matches) != 3 {
+		return "", 0, fmt.Errorf("invalid data contract format '%s', expected format: 'name-v123'", contract)
+	}
+
+	contractName = matches[1]
+	version, err = strconv.ParseUint(matches[2], 10, 64)
+	if err != nil {
+		return "", 0, fmt.Errorf("invalid version number '%s' in contract '%s': %w", matches[2], contract, err)
+	}
+
+	return contractName, version, nil
+}
+
+// LoadSchema loads and compiles a schema for the specified contract name and version.
+// The contract name must start with an underscore for easier topic matching.
+func (v *Validator) LoadSchema(contractName string, version uint64, schema []byte) error {
+	if contractName == "" {
+		return fmt.Errorf("contract name cannot be empty")
+	}
+
+	if !strings.HasPrefix(contractName, "_") {
+		return fmt.Errorf("contract name must start with an underscore, got: '%s'", contractName)
+	}
+
+	if len(schema) == 0 {
+		return fmt.Errorf("schema cannot be empty for contract '%s' version %d", contractName, version)
+	}
+
+	cacheKey := fmt.Sprintf("%s-v%d", contractName, version)
+
+	v.cacheMutex.Lock()
+	defer v.cacheMutex.Unlock()
+
+	// Create and compile the schema
+	schemaObj := NewSchema(contractName)
+	if err := schemaObj.AddVersion(version, schema); err != nil {
+		return fmt.Errorf("failed to add schema version %d for contract '%s': %w", version, contractName, err)
+	}
+
+	// Cache the schema - forever since schemas are immutable
+	expiresAt := time.Time{} // Zero time means never expires
+	if cacheHitTTL > 0 {
+		expiresAt = time.Now().Add(cacheHitTTL)
+	}
+	v.schemaCache[cacheKey] = &CacheEntry{
+		Schema:       schemaObj,
+		SchemaExists: true,
+		CachedAt:     time.Now(),
+		ExpiresAt:    expiresAt,
+	}
+
+	return nil
+}
+
+// HasSchema checks if a schema exists for the given contract name and version.
+func (v *Validator) HasSchema(contractName string, version uint64) bool {
+	cacheKey := fmt.Sprintf("%s-v%d", contractName, version)
+
+	v.cacheMutex.RLock()
+	defer v.cacheMutex.RUnlock()
+
+	entry, exists := v.schemaCache[cacheKey]
+	if !exists || entry.IsExpired() {
+		return false
+	}
+
+	return entry.SchemaExists && entry.Schema != nil && entry.Schema.HasVersion(version)
+}
+
+// Close cleans up resources (no background processes to stop anymore)
+func (v *Validator) Close() {
+	// No background processes to stop, just clear the cache
+	v.cacheMutex.Lock()
+	defer v.cacheMutex.Unlock()
+
+	v.schemaCache = make(map[string]*CacheEntry)
+}
diff --git c/uns_plugin/schema_validation/validator_benchmark_test.go w/uns_plugin/schema_validation/validator_benchmark_test.go
new file mode 100644
index 0000000..aa1cdab
--- /dev/null
+++ w/uns_plugin/schema_validation/validator_benchmark_test.go
@@ -0,0 +1,410 @@
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*
+Package schemavalidation provides comprehensive benchmarks for UNS schema validation performance.
+
+## Benchmark Results
+
+Performance testing was conducted on Apple M3 Pro to ensure the validator meets the target of 1,000 validations per second.
+
+### Latest Results (Updated with ValidationResult structure and fail-open behavior):
+
+```
+goos: darwin
+goarch: arm64
+pkg: github.com/united-manufacturing-hub/benthos-umh/uns_plugin/schema_validation
+cpu: Apple M3 Pro
+BenchmarkValidation_SingleThread-11                       273523              4422 ns/op            5250 B/op        117 allocs/op
+BenchmarkValidation_Concurrent-11                         622438              1690 ns/op            5203 B/op        117 allocs/op
+BenchmarkValidation_HighThroughput-11                     637519              1631 ns/op            5187 B/op        117 allocs/op
+BenchmarkValidation_RealWorld-11                         1462032               806.9 ns/op          2467 B/op         53 allocs/op
+BenchmarkValidation_MemoryUsage-11                        255853              4479 ns/op            5252 B/op        118 allocs/op
+BenchmarkValidation_DifferentPayloadSizes/PayloadSize_57_bytes-11                 263476              4548 ns/op            5284 B/op        118 allocs/op
+BenchmarkValidation_DifferentPayloadSizes/PayloadSize_65_bytes-11                 261116              4578 ns/op            5298 B/op        118 allocs/op
+BenchmarkValidation_DifferentPayloadSizes/PayloadSize_67_bytes-11                 257691              4558 ns/op            5296 B/op        118 allocs/op
+BenchmarkConcurrentValidation_ScalabilityTest/Goroutines_1-11                     260972              4507 ns/op            5269 B/op        118 allocs/op
+BenchmarkConcurrentValidation_ScalabilityTest/Goroutines_2-11                     413632              2959 ns/op            5376 B/op        118 allocs/op
+BenchmarkConcurrentValidation_ScalabilityTest/Goroutines_4-11                     555212              2063 ns/op            5389 B/op        118 allocs/op
+BenchmarkConcurrentValidation_ScalabilityTest/Goroutines_8-11                     644684              1749 ns/op            5239 B/op        118 allocs/op
+BenchmarkConcurrentValidation_ScalabilityTest/Goroutines_16-11                    665073              1557 ns/op            5178 B/op        118 allocs/op
+BenchmarkConcurrentValidation_ScalabilityTest/Goroutines_32-11                    701659              1611 ns/op            5173 B/op        118 allocs/op
+```
+
+### Performance Analysis:
+
+**Target Achievement:** ✅ **All benchmarks significantly exceed the 1,000 validations/second target**
+
+- **Single-threaded**: 273,523 ops/sec (273x faster than target)
+- **Concurrent**: 622,438 ops/sec (622x faster than target)
+- **High-throughput**: 637,519 ops/sec (637x faster than target)
+- **Real-world mixed**: 1,462,032 ops/sec (1,462x faster than target)
+
+**Memory Efficiency:**
+- **Latency**: 0.81-4.58 μs per validation
+- **Memory**: ~5KB per operation, 117-118 allocations
+- **Scalability**: Excellent performance scaling up to 32 goroutines (2.8x improvement)
+
+**Payload Size Impact:**
+- **Minimal variance**: 4.55-4.58 μs regardless of payload size (57-67 bytes)
+- **Consistent memory**: ~5.3KB per operation across all payload sizes
+
+**Concurrent Scalability:**
+- **1 goroutine**: 4,507 ns/op (222k ops/sec)
+- **32 goroutines**: 1,611 ns/op (621k ops/sec)
+- **Scaling efficiency**: 2.8x improvement with 32x goroutines
+
+### Impact of ValidationResult Structure Changes:
+
+**Performance Impact**: ✅ **Minimal performance impact from fail-open behavior**
+- **Enhanced metadata**: `SchemaCheckPassed`, `SchemaCheckBypassed`, `BypassReason`
+- **Contract tracking**: Full contract name and version information
+- **Bypass tracking**: Detailed reasons for validation bypasses
+- **Fail-open behavior**: Messages pass through when schemas are missing
+
+**New Features:**
+- **Dual boolean flags**: Clear distinction between passed/failed vs bypassed validation
+- **Comprehensive error handling**: Detailed error messages for debugging
+- **Metadata enrichment**: Contract information available for downstream processing
+- **Operational resilience**: System continues operating when schemas are unavailable
+
+### Recommendations:
+
+1. **Production Ready**: Performance easily handles production loads with fail-open safety
+2. **Concurrent Usage**: Optimal performance with 16-32 goroutines
+3. **Memory Stable**: Consistent memory usage across scenarios
+4. **Payload Agnostic**: Performance independent of payload size variations
+5. **Reliable Operation**: Fail-open behavior ensures data continuity
+
+*/
+
+package schemavalidation
+
+import (
+	"fmt"
+	"sync"
+	"testing"
+
+	"github.com/united-manufacturing-hub/benthos-umh/pkg/umh/topic"
+)
+
+// setupBenchmarkValidator creates a validator with pre-loaded schemas for benchmarking
+func setupBenchmarkValidator() *Validator {
+	validator := NewValidator()
+
+	// Use the exact same schema format as validator_test.go
+	sensorSchema := []byte(`{
+		"type": "object",
+		"properties": {
+			"virtual_path": {
+				"type": "string",
+				"enum": ["vibration.x-axis", "temperature", "humidity", "pressure"]
+			},
+			"fields": {
+				"type": "object",
+				"properties": {
+					"value": {
+						"type": "object",
+						"properties": {
+							"timestamp_ms": {"type": "number"},
+							"value": {"type": "number"}
+						},
+						"required": ["timestamp_ms", "value"],
+						"additionalProperties": false
+					}
+				},
+				"additionalProperties": false
+			}
+		},
+		"required": ["virtual_path", "fields"],
+		"additionalProperties": false
+	}`)
+
+	// Load the schema
+	validator.LoadSchema("_sensor_data", 1, sensorSchema)
+
+	return validator
+}
+
+// Test payloads for benchmarking
+var (
+	validNumberPayload = []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+	validZeroPayload   = []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 0}}`)
+	validLargePayload  = []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 999999999.999}}`)
+)
+
+// BenchmarkValidation_SingleThread measures single-threaded validation performance
+func BenchmarkValidation_SingleThread(b *testing.B) {
+	validator := setupBenchmarkValidator()
+
+	topics := []string{
+		"umh.v1.enterprise.site.area._sensor_data-v1.vibration.x-axis",
+		"umh.v1.enterprise.site.area._sensor_data-v1.temperature",
+		"umh.v1.enterprise.site.area._sensor_data-v1.humidity",
+		"umh.v1.enterprise.site.area._sensor_data-v1.pressure",
+	}
+
+	payloads := [][]byte{validNumberPayload, validZeroPayload, validLargePayload}
+
+	// Pre-create topic objects to avoid topic parsing overhead in benchmark
+	topicObjects := make([]*topic.UnsTopic, len(topics))
+	for i, topicStr := range topics {
+		topicObj, err := topic.NewUnsTopic(topicStr)
+		if err != nil {
+			b.Fatalf("Failed to create topic %s: %v", topicStr, err)
+		}
+		topicObjects[i] = topicObj
+	}
+
+	b.ResetTimer()
+	b.ReportAllocs()
+
+	for i := 0; i < b.N; i++ {
+		topicObj := topicObjects[i%len(topicObjects)]
+		payload := payloads[i%len(payloads)]
+
+		result := validator.Validate(topicObj, payload)
+		if !result.SchemaCheckPassed && !result.SchemaCheckBypassed {
+			b.Fatalf("Validation failed: %v", result.Error)
+		}
+	}
+}
+
+// BenchmarkValidation_Concurrent measures concurrent validation performance
+func BenchmarkValidation_Concurrent(b *testing.B) {
+	validator := setupBenchmarkValidator()
+
+	topics := []string{
+		"umh.v1.enterprise.site.area._sensor_data-v1.vibration.x-axis",
+		"umh.v1.enterprise.site.area._sensor_data-v1.temperature",
+		"umh.v1.enterprise.site.area._sensor_data-v1.humidity",
+		"umh.v1.enterprise.site.area._sensor_data-v1.pressure",
+	}
+
+	payloads := [][]byte{validNumberPayload, validZeroPayload, validLargePayload}
+
+	// Pre-create topic objects
+	topicObjects := make([]*topic.UnsTopic, len(topics))
+	for i, topicStr := range topics {
+		topicObj, err := topic.NewUnsTopic(topicStr)
+		if err != nil {
+			b.Fatalf("Failed to create topic %s: %v", topicStr, err)
+		}
+		topicObjects[i] = topicObj
+	}
+
+	b.ResetTimer()
+	b.ReportAllocs()
+
+	b.RunParallel(func(pb *testing.PB) {
+		i := 0
+		for pb.Next() {
+			topicObj := topicObjects[i%len(topicObjects)]
+			payload := payloads[i%len(payloads)]
+
+			result := validator.Validate(topicObj, payload)
+			if !result.SchemaCheckPassed && !result.SchemaCheckBypassed {
+				b.Fatalf("Validation failed: %v", result.Error)
+			}
+			i++
+		}
+	})
+}
+
+// BenchmarkValidation_HighThroughput simulates high-throughput scenarios
+func BenchmarkValidation_HighThroughput(b *testing.B) {
+	validator := setupBenchmarkValidator()
+
+	// Create topic variety using only valid schema combinations
+	topics := make([]*topic.UnsTopic, 0, 20)
+	tagNames := []string{"vibration.x-axis", "temperature", "humidity", "pressure"}
+
+	for _, tagName := range tagNames {
+		topicStr := fmt.Sprintf("umh.v1.enterprise.site.area._sensor_data-v1.%s", tagName)
+		topicObj, err := topic.NewUnsTopic(topicStr)
+		if err == nil {
+			topics = append(topics, topicObj)
+		}
+	}
+
+	if len(topics) == 0 {
+		b.Fatal("No valid topics created")
+	}
+
+	payloads := [][]byte{validNumberPayload, validZeroPayload, validLargePayload}
+
+	b.ResetTimer()
+	b.ReportAllocs()
+
+	b.RunParallel(func(pb *testing.PB) {
+		i := 0
+		for pb.Next() {
+			topicObj := topics[i%len(topics)]
+			payload := payloads[i%len(payloads)]
+
+			validator.Validate(topicObj, payload) // Don't fail on validation errors in high throughput test
+			i++
+		}
+	})
+}
+
+// BenchmarkValidation_RealWorld simulates real-world mixed scenarios
+func BenchmarkValidation_RealWorld(b *testing.B) {
+	validator := setupBenchmarkValidator()
+
+	// Mix of valid and invalid scenarios (90% valid, 10% invalid)
+	scenarios := []struct {
+		topicStr string
+		payload  []byte
+		valid    bool
+	}{
+		// Valid scenarios (90%)
+		{"umh.v1.enterprise.site.area._sensor_data-v1.temperature", validNumberPayload, true},
+		{"umh.v1.enterprise.site.area._sensor_data-v1.humidity", validNumberPayload, true},
+		{"umh.v1.enterprise.site.area._sensor_data-v1.pressure", validNumberPayload, true},
+		{"umh.v1.enterprise.site.area._pump_data-v1.count", validNumberPayload, true},
+		{"umh.v1.enterprise.site.area._pump_data-v1.vibration.x-axis", validNumberPayload, true},
+		{"umh.v1.enterprise.site.area._pump_data-v1.vibration.y-axis", validNumberPayload, true},
+		{"umh.v1.enterprise.site.area._pump_data-v1.serialNumber", validNumberPayload, true},
+		{"umh.v1.enterprise.site.area._motor_data-v1.temperature", validNumberPayload, true},
+		{"umh.v1.enterprise.site.area._sensor_data-v2.temperature", validNumberPayload, true},
+		// Invalid scenarios (10%)
+		{"umh.v1.enterprise.site.area._sensor_data-v1.invalid_tag", validNumberPayload, false},
+	}
+
+	// Pre-create topic objects for valid scenarios
+	topicObjects := make([]*topic.UnsTopic, len(scenarios))
+	for i, scenario := range scenarios {
+		if scenario.valid {
+			topicObj, err := topic.NewUnsTopic(scenario.topicStr)
+			if err != nil {
+				b.Fatalf("Failed to create topic %s: %v", scenario.topicStr, err)
+			}
+			topicObjects[i] = topicObj
+		}
+	}
+
+	b.ResetTimer()
+	b.ReportAllocs()
+
+	b.RunParallel(func(pb *testing.PB) {
+		i := 0
+		for pb.Next() {
+			scenario := scenarios[i%len(scenarios)]
+
+			if scenario.valid {
+				topicObj := topicObjects[i%len(scenarios)]
+				if topicObj != nil {
+					validator.Validate(topicObj, scenario.payload)
+				}
+			} else {
+				// For invalid scenarios, create topic on-the-fly (performance penalty expected)
+				topicObj, err := topic.NewUnsTopic(scenario.topicStr)
+				if err == nil {
+					validator.Validate(topicObj, scenario.payload)
+				}
+			}
+			i++
+		}
+	})
+}
+
+// BenchmarkValidation_MemoryUsage measures memory allocations per validation
+func BenchmarkValidation_MemoryUsage(b *testing.B) {
+	validator := setupBenchmarkValidator()
+
+	topicObj, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+	if err != nil {
+		b.Fatalf("Failed to create topic: %v", err)
+	}
+
+	b.ResetTimer()
+	b.ReportAllocs()
+
+	for i := 0; i < b.N; i++ {
+		result := validator.Validate(topicObj, validNumberPayload)
+		if !result.SchemaCheckPassed && !result.SchemaCheckBypassed {
+			b.Fatalf("Validation failed: %v", result.Error)
+		}
+	}
+}
+
+// BenchmarkValidation_DifferentPayloadSizes tests with various payload sizes
+func BenchmarkValidation_DifferentPayloadSizes(b *testing.B) {
+	validator := setupBenchmarkValidator()
+
+	topicObj, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+	if err != nil {
+		b.Fatalf("Failed to create topic: %v", err)
+	}
+
+	// Different payload sizes
+	payloads := [][]byte{
+		// Small payload
+		[]byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`),
+		// Medium payload with more precision
+		[]byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.123456789}}`),
+		// Large payload with scientific notation
+		[]byte(`{"value": {"timestamp_ms": 1719859200000, "value": 1.23456789e+10}}`),
+	}
+
+	for _, payload := range payloads {
+		b.Run(fmt.Sprintf("PayloadSize_%d_bytes", len(payload)), func(b *testing.B) {
+			b.ResetTimer()
+			b.ReportAllocs()
+
+			for j := 0; j < b.N; j++ {
+				result := validator.Validate(topicObj, payload)
+				if !result.SchemaCheckPassed && !result.SchemaCheckBypassed {
+					b.Fatalf("Validation failed: %v", result.Error)
+				}
+			}
+		})
+	}
+}
+
+// BenchmarkConcurrentValidation_ScalabilityTest tests scalability with different goroutine counts
+func BenchmarkConcurrentValidation_ScalabilityTest(b *testing.B) {
+	validator := setupBenchmarkValidator()
+
+	topicObj, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+	if err != nil {
+		b.Fatalf("Failed to create topic: %v", err)
+	}
+
+	// Test with different numbers of goroutines
+	goroutineCounts := []int{1, 2, 4, 8, 16, 32}
+
+	for _, numGoroutines := range goroutineCounts {
+		b.Run(fmt.Sprintf("Goroutines_%d", numGoroutines), func(b *testing.B) {
+			b.ResetTimer()
+			b.ReportAllocs()
+
+			var wg sync.WaitGroup
+			validationsPerGoroutine := b.N / numGoroutines
+
+			for i := 0; i < numGoroutines; i++ {
+				wg.Add(1)
+				go func() {
+					defer wg.Done()
+					for j := 0; j < validationsPerGoroutine; j++ {
+						validator.Validate(topicObj, validNumberPayload)
+					}
+				}()
+			}
+
+			wg.Wait()
+		})
+	}
+}
diff --git c/uns_plugin/schema_validation/validator_test.go w/uns_plugin/schema_validation/validator_test.go
new file mode 100644
index 0000000..c3dacb7
--- /dev/null
+++ w/uns_plugin/schema_validation/validator_test.go
@@ -0,0 +1,353 @@
+// Copyright 2025 UMH Systems GmbH
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package schemavalidation
+
+import (
+	"time"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+	"github.com/united-manufacturing-hub/benthos-umh/pkg/umh/topic"
+)
+
+var _ = Describe("Validator", func() {
+	var (
+		validator    *Validator
+		mockRegistry *MockSchemaRegistry
+	)
+
+	BeforeEach(func() {
+		mockRegistry = NewMockSchemaRegistry()
+		mockRegistry.SetupTestSchemas()
+		validator = NewValidatorWithRegistry(mockRegistry.URL())
+	})
+
+	AfterEach(func() {
+		if validator != nil {
+			validator.Close()
+		}
+		if mockRegistry != nil {
+			mockRegistry.Close()
+		}
+	})
+
+	Context("when creating a new validator", func() {
+		It("should initialize correctly without registry", func() {
+			validator := NewValidator()
+			Expect(validator.schemaCache).NotTo(BeNil())
+			Expect(validator.httpClient).NotTo(BeNil())
+			Expect(validator.schemaRegistryURL).To(BeEmpty())
+		})
+
+		It("should initialize correctly with registry", func() {
+			validator := NewValidatorWithRegistry("http://localhost:8081")
+			Expect(validator.schemaCache).NotTo(BeNil())
+			Expect(validator.httpClient).NotTo(BeNil())
+			Expect(validator.schemaRegistryURL).To(Equal("http://localhost:8081"))
+		})
+	})
+
+	Context("when validating with versioned contracts", func() {
+		It("should successfully validate sensor data v1", func() {
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(BeNil())
+			Expect(result.ContractName).To(Equal("_sensor_data"))
+			Expect(result.ContractVersion).To(Equal(uint64(1)))
+		})
+
+		It("should successfully validate sensor data v2", func() {
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v2.temperature")
+			Expect(err).To(BeNil())
+
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(BeNil())
+			Expect(result.ContractName).To(Equal("_sensor_data"))
+			Expect(result.ContractVersion).To(Equal(uint64(2)))
+		})
+
+		It("should reject invalid virtual path", func() {
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.invalid_path")
+			Expect(err).To(BeNil())
+
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+			Expect(result.Error.Error()).To(ContainSubstring("schema validation failed"))
+		})
+
+		It("should reject invalid payload structure", func() {
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+
+			payload := []byte(`{"value": {"timestamp_ms": "invalid", "value": 25.5}}`)
+
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeFalse())
+			Expect(result.Error).To(HaveOccurred())
+			Expect(result.Error.Error()).To(ContainSubstring("schema validation failed"))
+		})
+	})
+
+	Context("when handling non-existent schemas", func() {
+		It("should bypass validation for non-existent contract", func() {
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._non_existent-v1.temperature")
+			Expect(err).To(BeNil())
+
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+			Expect(result.BypassReason).To(ContainSubstring("does not exist in registry"))
+			Expect(result.ContractName).To(Equal("_non_existent"))
+			Expect(result.ContractVersion).To(Equal(uint64(1)))
+		})
+
+		It("should bypass validation for non-existent version", func() {
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v999.temperature")
+			Expect(err).To(BeNil())
+
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+			Expect(result.BypassReason).To(ContainSubstring("does not exist in registry"))
+			Expect(result.ContractName).To(Equal("_sensor_data"))
+			Expect(result.ContractVersion).To(Equal(uint64(999)))
+		})
+	})
+
+	Context("when handling unversioned contracts", func() {
+		It("should bypass validation for unversioned contracts", func() {
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data.temperature")
+			Expect(err).To(BeNil())
+
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+			Expect(result.BypassReason).To(ContainSubstring("unversioned contract"))
+			Expect(result.ContractName).To(Equal("_sensor_data"))
+		})
+	})
+
+	Context("when testing cache behavior", func() {
+		It("should cache successful schema fetches", func() {
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			// First validation should fetch and cache the schema
+			result1 := validator.Validate(unsTopic, payload)
+			Expect(result1.SchemaCheckPassed).To(BeTrue())
+
+			// Verify schema is cached
+			Expect(validator.HasSchema("_sensor_data", 1)).To(BeTrue())
+
+			// Second validation should use cached schema
+			result2 := validator.Validate(unsTopic, payload)
+			Expect(result2.SchemaCheckPassed).To(BeTrue())
+			Expect(result2.ContractName).To(Equal("_sensor_data"))
+			Expect(result2.ContractVersion).To(Equal(uint64(1)))
+		})
+
+		It("should cache negative results (schema not found)", func() {
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._non_existent-v1.temperature")
+			Expect(err).To(BeNil())
+
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			// First validation should fetch and cache the negative result
+			result1 := validator.Validate(unsTopic, payload)
+			Expect(result1.SchemaCheckBypassed).To(BeTrue())
+			Expect(result1.BypassReason).To(ContainSubstring("does not exist in registry"))
+
+			// Second validation should use cached negative result
+			result2 := validator.Validate(unsTopic, payload)
+			Expect(result2.SchemaCheckBypassed).To(BeTrue())
+			Expect(result2.BypassReason).To(ContainSubstring("does not exist in registry"))
+		})
+
+		It("should cache successful schema fetches forever", func() {
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			// Validate to populate cache
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+
+			// Check cache entry exists and never expires
+			validator.cacheMutex.RLock()
+			entry, exists := validator.schemaCache["_sensor_data-v1"]
+			validator.cacheMutex.RUnlock()
+
+			Expect(exists).To(BeTrue())
+			Expect(entry.SchemaExists).To(BeTrue())
+			Expect(entry.Schema).NotTo(BeNil())
+			Expect(entry.IsExpired()).To(BeFalse())
+			Expect(entry.ExpiresAt.IsZero()).To(BeTrue()) // Zero time means never expires
+		})
+
+		It("should cache schema misses for 10 minutes", func() {
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._non_existent-v1.temperature")
+			Expect(err).To(BeNil())
+
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			// Validate to populate cache with miss
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+
+			// Check cache entry exists with 10 minute expiration
+			validator.cacheMutex.RLock()
+			entry, exists := validator.schemaCache["_non_existent-v1"]
+			validator.cacheMutex.RUnlock()
+
+			Expect(exists).To(BeTrue())
+			Expect(entry.SchemaExists).To(BeFalse())
+			Expect(entry.Schema).To(BeNil())
+			Expect(entry.IsExpired()).To(BeFalse())
+			Expect(entry.ExpiresAt.IsZero()).To(BeFalse()) // Should have an expiration time
+			Expect(entry.ExpiresAt).To(BeTemporally("~", time.Now().Add(10*time.Minute), time.Second))
+		})
+	})
+
+	Context("when handling contract parsing", func() {
+		It("should parse versioned contracts correctly", func() {
+			contractName, version, err := validator.ExtractSchemaVersionFromDataContract("_sensor_data-v1")
+			Expect(err).To(BeNil())
+			Expect(contractName).To(Equal("_sensor_data"))
+			Expect(version).To(Equal(uint64(1)))
+
+			contractName, version, err = validator.ExtractSchemaVersionFromDataContract("_pump_data-v123")
+			Expect(err).To(BeNil())
+			Expect(contractName).To(Equal("_pump_data"))
+			Expect(version).To(Equal(uint64(123)))
+		})
+
+		It("should reject invalid contract formats", func() {
+			_, _, err := validator.ExtractSchemaVersionFromDataContract("invalid-contract")
+			Expect(err).To(HaveOccurred())
+			Expect(err.Error()).To(ContainSubstring("invalid data contract format"))
+
+			_, _, err = validator.ExtractSchemaVersionFromDataContract("_sensor_data-v")
+			Expect(err).To(HaveOccurred())
+
+			_, _, err = validator.ExtractSchemaVersionFromDataContract("")
+			Expect(err).To(HaveOccurred())
+		})
+	})
+
+	Context("when manually loading schemas", func() {
+		It("should load and cache schemas correctly", func() {
+			schema := []byte(`{"type": "object", "properties": {"test": {"type": "string"}}}`)
+
+			err := validator.LoadSchema("_test_contract", 1, schema)
+			Expect(err).To(BeNil())
+
+			// Check if schema was cached
+			Expect(validator.HasSchema("_test_contract", 1)).To(BeTrue())
+
+			// Verify cache entry
+			validator.cacheMutex.RLock()
+			entry, exists := validator.schemaCache["_test_contract-v1"]
+			validator.cacheMutex.RUnlock()
+
+			Expect(exists).To(BeTrue())
+			Expect(entry.SchemaExists).To(BeTrue())
+			Expect(entry.Schema).NotTo(BeNil())
+		})
+
+		It("should validate contract name requirements", func() {
+			schema := []byte(`{"type": "object"}`)
+
+			err := validator.LoadSchema("invalid_contract", 1, schema)
+			Expect(err).To(HaveOccurred())
+			Expect(err.Error()).To(ContainSubstring("must start with an underscore"))
+
+			err = validator.LoadSchema("", 1, schema)
+			Expect(err).To(HaveOccurred())
+			Expect(err.Error()).To(ContainSubstring("cannot be empty"))
+
+			err = validator.LoadSchema("_test_contract", 1, []byte{})
+			Expect(err).To(HaveOccurred())
+			Expect(err.Error()).To(ContainSubstring("schema cannot be empty"))
+		})
+	})
+
+	Context("when handling network errors", func() {
+		It("should handle schema registry unavailable", func() {
+			validator := NewValidatorWithRegistry("http://localhost:9999") // Invalid URL
+
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeFalse())
+			Expect(result.SchemaCheckBypassed).To(BeTrue())
+			Expect(result.BypassReason).To(ContainSubstring("failed to fetch schema"))
+		})
+	})
+
+	Context("when closing validator", func() {
+		It("should clear cache on close", func() {
+			unsTopic, err := topic.NewUnsTopic("umh.v1.enterprise.site.area._sensor_data-v1.temperature")
+			Expect(err).To(BeNil())
+
+			payload := []byte(`{"value": {"timestamp_ms": 1719859200000, "value": 25.5}}`)
+
+			// Validate to populate cache
+			result := validator.Validate(unsTopic, payload)
+			Expect(result.SchemaCheckPassed).To(BeTrue())
+
+			// Verify cache has entries
+			validator.cacheMutex.RLock()
+			cacheSize := len(validator.schemaCache)
+			validator.cacheMutex.RUnlock()
+			Expect(cacheSize).To(BeNumerically(">", 0))
+
+			// Close validator
+			validator.Close()
+
+			// Verify cache is cleared
+			validator.cacheMutex.RLock()
+			cacheSize = len(validator.schemaCache)
+			validator.cacheMutex.RUnlock()
+			Expect(cacheSize).To(Equal(0))
+		})
+	})
+})
diff --git c/uns_plugin/uns_output.go w/uns_plugin/uns_output.go
index 70ae9a4..0881d4a 100644
--- c/uns_plugin/uns_output.go
+++ w/uns_plugin/uns_output.go
@@ -17,12 +17,14 @@ package uns_plugin
 import (
 	"context"
 	"fmt"
+	"strconv"
 	"strings"
 	"time"
 
 	"github.com/redpanda-data/benthos/v4/public/service"
 	"github.com/twmb/franz-go/pkg/kgo"
 	"github.com/united-manufacturing-hub/benthos-umh/pkg/umh/topic"
+	schemavalidation "github.com/united-manufacturing-hub/benthos-umh/uns_plugin/schema_validation"
 )
 
 // init registers the "uns" batch output plugin with Benthos using its configuration and constructor.
@@ -34,6 +36,7 @@ const (
 	defaultOutputTopic               = "umh.messages" // by the current state, the output topic must not be changed for this plugin
 	defaultOutputTopicPartitionCount = 1
 	defaultBrokerAddress             = "localhost:9092"
+	defaultSchemaRegistryPort        = "8081"
 	defaultClientID                  = "umh_core"
 	defaultUMHTopic                  = "${! meta(\"umh_topic\") }"
 )
@@ -112,20 +115,67 @@ Traceability header.  Defaults to 'umh-core' but is automatically
 overwritten by UMH Core when the container runs as a protocol-converter:
 'protocol-converter-<INSTANCE>-<NAME>'.
 `).
-			Default(defaultClientID))
+			Default(defaultClientID)).
+		Field(service.NewStringField("schema_registry_url").
+			Description(`
+Schema registry URL for data contract validation.  If not provided, it
+will be automatically derived from the first broker in the broker_address
+list by changing the port to 8081.
+
+Example: If broker_address is "localhost:9092", the schema registry URL
+will be "http://localhost:8081".
+`).
+			Example("http://localhost:8081").
+			Example("https://schema-registry.example.com:8081").
+			Optional())
 }
 
 // Config holds the configuration for the UNS output plugin
 type unsOutputConfig struct {
-	umh_topic     *service.InterpolatedString
-	brokerAddress string
-	bridgedBy     string
+	umh_topic         *service.InterpolatedString
+	brokerAddress     string
+	bridgedBy         string
+	schemaRegistryURL string
 }
 
 type unsOutput struct {
-	config unsOutputConfig
-	client MessagePublisher
-	log    *service.Logger
+	config    unsOutputConfig
+	client    MessagePublisher
+	log       *service.Logger
+	validator *schemavalidation.Validator
+}
+
+// deriveSchemaRegistryURL derives a schema registry URL from the broker address
+// Takes the first broker from a comma-separated list and converts the port to 8081
+func deriveSchemaRegistryURL(brokerAddress string) string {
+	// Split by comma to handle multiple brokers
+	brokers := strings.Split(brokerAddress, ",")
+	if len(brokers) == 0 {
+		return ""
+	}
+
+	// Take the first broker and trim any whitespace
+	firstBroker := strings.TrimSpace(brokers[0])
+
+	// Check if the first broker is empty
+	if firstBroker == "" {
+		return ""
+	}
+
+	// Split by colon to separate host and port
+	parts := strings.Split(firstBroker, ":")
+	if len(parts) != 2 {
+		// If no port specified, assume default and add schema registry port
+		return fmt.Sprintf("http://%s:%s", firstBroker, defaultSchemaRegistryPort)
+	}
+
+	// Replace the port with schema registry port
+	host := parts[0]
+	// Check if host is empty
+	if host == "" {
+		return ""
+	}
+	return fmt.Sprintf("http://%s:%s", host, defaultSchemaRegistryPort)
 }
 
 // newUnsOutput creates a new unsOutput instance by parsing configuration fields for umh_topic, broker address, and bridge name, returning the output, batch policy, max in-flight count, and any error encountered during parsing.
@@ -173,15 +223,31 @@ func newUnsOutput(conf *service.ParsedConfig, mgr *service.Resources) (service.B
 		}
 	}
 
-	return newUnsOutputWithClient(NewClient(), config, mgr.Logger()), batchPolicy, maxInFlight, nil
+	// Parse schema_registry_url if provided, otherwise derive from broker_address
+	if conf.Contains("schema_registry_url") {
+		schemaRegistryURL, err := conf.FieldString("schema_registry_url")
+		if err != nil {
+			return nil, batchPolicy, 0, fmt.Errorf("error while parsing schema_registry_url field from the config: %v", err)
+		}
+		config.schemaRegistryURL = schemaRegistryURL
+	} else {
+		// Derive schema registry URL from broker address
+		config.schemaRegistryURL = deriveSchemaRegistryURL(config.brokerAddress)
+	}
+
+	// Initialize the validator with schema registry URL
+	validator := schemavalidation.NewValidatorWithRegistry(config.schemaRegistryURL)
+
+	return newUnsOutputWithClient(NewClient(), config, mgr.Logger(), validator), batchPolicy, maxInFlight, nil
 }
 
 // Testable constructor that accepts client
-func newUnsOutputWithClient(client MessagePublisher, config unsOutputConfig, logger *service.Logger) service.BatchOutput {
+func newUnsOutputWithClient(client MessagePublisher, config unsOutputConfig, logger *service.Logger, validator *schemavalidation.Validator) service.BatchOutput {
 	return &unsOutput{
-		client: client,
-		config: config,
-		log:    logger,
+		client:    client,
+		config:    config,
+		log:       logger,
+		validator: validator,
 	}
 }
 
@@ -192,6 +258,9 @@ func (o *unsOutput) Close(ctx context.Context) error {
 		o.client.Close()
 		o.client = nil
 	}
+	if o.validator != nil {
+		o.validator.Close()
+	}
 	o.log.Infof("uns kafka client closed successfully")
 	return nil
 }
@@ -199,6 +268,7 @@ func (o *unsOutput) Close(ctx context.Context) error {
 // Connect initializes the kafka client
 func (o *unsOutput) Connect(ctx context.Context) error {
 	o.log.Infof("Connecting to uns plugin kafka broker: %v", o.config.brokerAddress)
+	o.log.Infof("Using schema registry URL: %v", o.config.schemaRegistryURL)
 
 	if o.client == nil {
 		o.client = NewClient()
@@ -300,21 +370,36 @@ func (o *unsOutput) WriteBatch(ctx context.Context, msgs service.MessageBatch) e
 		}
 
 		// Validate the UMH topic using the centralized topic library
-		_, err = topic.NewUnsTopic(key)
+		unsTopic, err := topic.NewUnsTopic(key)
 		if err != nil {
 			return fmt.Errorf("error validating message key in message %d: invalid UMH topic '%s': %v", i, key, err)
 		}
 
-		headers, err := o.extractHeaders(msg)
-		if err != nil {
-			return fmt.Errorf("error processing message %d: %v", i, err)
-		}
-
 		msgAsBytes, err := msg.AsBytes()
 		if err != nil {
 			return fmt.Errorf("error getting content of message %d: %v", i, err)
 		}
 
+		// Validate the payload against the schema
+		validationResult := o.validator.Validate(unsTopic, msgAsBytes)
+		if !validationResult.SchemaCheckPassed && !validationResult.SchemaCheckBypassed {
+			return fmt.Errorf("error validating message payload in message %d: %v", i, validationResult.Error)
+		}
+		if validationResult.SchemaCheckPassed {
+			// Add the contract name and version to the headers
+			msg.MetaSet("data_contract_name", validationResult.ContractName)
+			msg.MetaSet("data_contract_version", strconv.FormatUint(validationResult.ContractVersion, 10))
+		} else if validationResult.SchemaCheckBypassed {
+			// Add bypass information if validation was bypassed
+			msg.MetaSet("data_contract_bypassed", "true")
+			msg.MetaSet("data_contract_bypass_reason", validationResult.BypassReason)
+		}
+
+		headers, err := o.extractHeaders(msg)
+		if err != nil {
+			return fmt.Errorf("error processing message %d: %v", i, err)
+		}
+
 		record := Record{
 			Topic:   defaultOutputTopic,
 			Key:     []byte(key),
diff --git c/uns_plugin/uns_output_test.go w/uns_plugin/uns_output_test.go
index 84285d6..dc4e92d 100644
--- c/uns_plugin/uns_output_test.go
+++ w/uns_plugin/uns_output_test.go
@@ -24,6 +24,7 @@ import (
 	"github.com/redpanda-data/benthos/v4/public/service"
 	"github.com/twmb/franz-go/pkg/kgo"
 	"github.com/united-manufacturing-hub/benthos-umh/pkg/umh/topic"
+	schemavalidation "github.com/united-manufacturing-hub/benthos-umh/uns_plugin/schema_validation"
 )
 
 type TestMessagePublisher interface {
@@ -152,7 +153,9 @@ var _ = Describe("Initializing uns output plugin", func() {
 		}
 		umh_topic, _ := service.NewInterpolatedString("${! meta(\"umh_topic\") }")
 		unsConf.umh_topic = umh_topic
-		outputPlugin = newUnsOutputWithClient(mockClient, unsConf, nil)
+		// Initialize the validator
+		validator := schemavalidation.NewValidator()
+		outputPlugin = newUnsOutputWithClient(mockClient, unsConf, nil, validator)
 		unsClient = outputPlugin.(*unsOutput)
 		ctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)
 	})
