# fsm/ README

**Overview:**  
This folder contains multiple **finite state machines** (FSMs) used within umh-core. We use [looplab/fsm](https://github.com/looplab/fsm) to manage each subsystem’s lifecycle (Benthos pipelines, Redpanda brokers, s6 services, etc.). Each subfolder within `fsm/` holds a distinct state machine, so that each subsystem can evolve independently while following a consistent pattern.

#### Pattern: One FSM per Subsystem

We follow a design where each major subsystem (Benthos, Redpanda, etc.) has its own state machine:

- **machine.go**: Contains looplab/fsm `Events` definitions and `NewXyzInstance(...)` constructor.  
- **fsm_callback.go**: Each package also has a `RegisterCallbacks` function that binds side-effect actions to “enter_state” or “before_event” transitions. For example, entering “starting” triggers a function like `StartBenthos(...)` which starts the actual OS process or Docker container.  
- **models.go**: Defines domain-specific data structures, e.g., `BenthosConfig` and `S6Service`.  
- **fsm_test.go**: Thoroughly tests each state transition with Ginkgo and Gomega.

---

#### Key Concepts

1. **States and Events**:  
   Each subpackage’s `machine.go` enumerates states (like “running,” “stopped”) and events (like “start,” “stop”). Only valid transitions are declared (e.g., from “stopped” to “starting”).

2. **Callbacks**:  
   We rely on looplab/fsm’s callback system to run side effects as soon as the FSM transitions to or from a state. For example, `enter_running` might be where we log success or add a history entry.

3. **Reconciliation**:  
   Every state machine has a Reconcile function, that is used to reconcile the desired state with the actual state. This function needs to run deterministically and is called by the main control loop in fixed intervals.