{
  "metadata": {
    "benthos_version": "v4.49.0",
    "generated_at": "2025-10-24T16:24:47.716919+02:00",
    "benthos_umh_version": "v0.11.6-9-g71fed98-dirty"
  },
  "inputs": {
    "ads": {
      "name": "ads",
      "type": "input",
      "source": "upstream",
      "summary": "Creates an input that reads data from Beckhoff PLCs using adsLib. Created by Daniel H",
      "description": "This input plugin enables Benthos to read data directly from Beckhoff PLCs using the ADS protocol. Configure the plugin by specifying the PLC's IP address, runtime port, target AMS net ID, etc. etc, add more here.",
      "config": {
        "cycleTime": {
          "name": "cycleTime",
          "type": "int",
          "kind": "scalar",
          "description": "Requested read interval time for PLC to scan for changes if read type notification, in milliseconds.",
          "required": true,
          "default": 1000
        },
        "hostAMS": {
          "name": "hostAMS",
          "type": "string",
          "kind": "scalar",
          "description": "The host AMS net ID, use auto (default) to automatically derive AMS from host IP. Enter manually if auto not working",
          "required": true,
          "default": "auto"
        },
        "hostPort": {
          "name": "hostPort",
          "type": "int",
          "kind": "scalar",
          "description": "Host port. Default 48898 (Twincat 2)",
          "required": true,
          "default": 10500
        },
        "intervalTime": {
          "name": "intervalTime",
          "type": "int",
          "kind": "scalar",
          "description": "The interval time between reads milliseconds for read requests.",
          "required": true,
          "default": 1000
        },
        "logLevel": {
          "name": "logLevel",
          "type": "string",
          "kind": "scalar",
          "description": "Log level for ADS connection. Default disabled",
          "required": true,
          "default": "disabled"
        },
        "maxDelay": {
          "name": "maxDelay",
          "type": "int",
          "kind": "scalar",
          "description": "Max delay time after value change before PLC should send message, in milliseconds. Default 100",
          "required": true,
          "default": 100
        },
        "readType": {
          "name": "readType",
          "type": "string",
          "kind": "scalar",
          "description": "Read type, interval or notification (default)",
          "required": true,
          "default": "notification"
        },
        "runtimePort": {
          "name": "runtimePort",
          "type": "int",
          "kind": "scalar",
          "description": "Target runtime port. Default 801(Twincat 2)",
          "required": true,
          "default": 801
        },
        "symbols": {
          "name": "symbols",
          "type": "string",
          "kind": "array",
          "description": "List of symbols to read in the format 'function.name', e.g., 'MAIN.counter', '.globalCounter' If using custom max delay and cycle time for a symbol the format is 'function.name:maxDelay:cycleTime', e.g,. 'MAIN.counter:0:100', '.globalCounter:100:10'",
          "required": true,
          "default": null
        },
        "targetAMS": {
          "name": "targetAMS",
          "type": "string",
          "kind": "scalar",
          "description": "Target AMS net ID.",
          "required": true,
          "default": null
        },
        "targetIP": {
          "name": "targetIP",
          "type": "string",
          "kind": "scalar",
          "description": "IP address of the Beckhoff PLC.",
          "required": true,
          "default": null
        },
        "targetPort": {
          "name": "targetPort",
          "type": "int",
          "kind": "scalar",
          "description": "Target port. Default 48898 (Twincat 2)",
          "required": true,
          "default": 48898
        },
        "upperCase": {
          "name": "upperCase",
          "type": "bool",
          "kind": "scalar",
          "description": "Convert symbol names to uppercase(needed on some older PLCs). Default true ",
          "required": true,
          "default": true
        }
      }
    },
    "amqp_0_9": {
      "name": "amqp_0_9",
      "type": "input",
      "source": "upstream",
      "summary": "Connects to an AMQP (0.91) queue. AMQP is a messaging protocol used by various message brokers, including RabbitMQ.",
      "description": "\nTLS is automatic when connecting to an `amqps` URL, but custom settings can be enabled in the `tls` section.\n\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n- amqp_content_type\n- amqp_content_encoding\n- amqp_delivery_mode\n- amqp_priority\n- amqp_correlation_id\n- amqp_reply_to\n- amqp_expiration\n- amqp_message_id\n- amqp_timestamp\n- amqp_type\n- amqp_user_id\n- amqp_app_id\n- amqp_consumer_tag\n- amqp_delivery_tag\n- amqp_redelivered\n- amqp_exchange\n- amqp_routing_key\n- All existing message headers, including nested headers prefixed with the key of their respective parent.\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolations].",
      "config": {
        "auto_ack": {
          "name": "auto_ack",
          "type": "bool",
          "kind": "scalar",
          "description": "Acknowledge messages automatically as they are consumed rather than waiting for acknowledgments from downstream. This can improve throughput and prevent the pipeline from blocking but at the cost of eliminating delivery guarantees.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "bindings_declare": {
          "name": "bindings_declare",
          "type": "object",
          "kind": "array",
          "description": "Allows you to passively declare bindings for the target queue.",
          "required": false,
          "default": null,
          "examples": [
            [
              {
                "exchange": "foo",
                "key": "bar"
              }
            ]
          ],
          "advanced": true,
          "children": [
            {
              "name": "exchange",
              "type": "string",
              "kind": "scalar",
              "description": "The exchange of the declared binding.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "key",
              "type": "string",
              "kind": "scalar",
              "description": "The key of the declared binding.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "consumer_tag": {
          "name": "consumer_tag",
          "type": "string",
          "kind": "scalar",
          "description": "A consumer tag.",
          "required": true,
          "default": ""
        },
        "nack_reject_patterns": {
          "name": "nack_reject_patterns",
          "type": "string",
          "kind": "array",
          "description": "A list of regular expression patterns whereby if a message that has failed to be delivered by Redpanda Connect has an error that matches it will be dropped (or delivered to a dead-letter queue if one exists). By default failed messages are nacked with requeue enabled.",
          "required": true,
          "default": [],
          "examples": [
            [
              "^reject me please:.+$"
            ]
          ],
          "advanced": true
        },
        "prefetch_count": {
          "name": "prefetch_count",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of pending messages to have consumed at a time.",
          "required": true,
          "default": 10
        },
        "prefetch_size": {
          "name": "prefetch_size",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum amount of pending messages measured in bytes to have consumed at a time.",
          "required": true,
          "default": 0,
          "advanced": true
        },
        "queue": {
          "name": "queue",
          "type": "string",
          "kind": "scalar",
          "description": "An AMQP queue to consume from.",
          "required": true,
          "default": null
        },
        "queue_declare": {
          "name": "queue_declare",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to passively declare the target queue. If the queue already exists then the declaration passively verifies that they match the target fields.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to enable queue declaration.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "durable",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether the declared queue is durable.",
              "required": true,
              "default": true,
              "advanced": true
            },
            {
              "name": "auto_delete",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether the declared queue will auto-delete.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "arguments",
              "type": "string",
              "kind": "map",
              "description": "\nOptional arguments specific to the server's implementation of the queue that can be sent for queue types which require extra parameters.\n\n== Arguments\n\n- x-queue-type\n\nIs used to declare quorum and stream queues. Accepted values are: 'classic' (default), 'quorum', 'stream', 'drop-head', 'reject-publish' and 'reject-publish-dlx'.\n\n- x-max-length\n\nMaximum number of messages, is a non-negative integer value.\n\n- x-max-length-bytes\n\nMaximum number of messages, is a non-negative integer value.\n\n- x-overflow\n\nSets overflow behaviour. Possible values are: 'drop-head' (default), 'reject-publish', 'reject-publish-dlx'.\n\n- x-message-ttl\n\nTTL period in milliseconds. Must be a string representation of the number.\n\n- x-expires\n\nExpiration policy, describes the expiration period in milliseconds. Must be a positive integer.\n\n- x-max-age\n\nControls the retention of a stream. Must be a strin, valid units: (Y, M, D, h, m, s) e.g. '7D' for a week.\n\n- x-stream-max-segment-size-bytes\n\nControls the size of the segment files on disk (default 500000000). Must be a positive integer.\n\n- x-queue-version\n\ndeclares the Classic Queue version to use. Expects an integer, either 1 or 2.\n\n- x-consumer-timeout\n\nInteger specified in milliseconds.\n\n- x-single-active-consumer\n\nEnables Single Active Consumer, Expects a Boolean.\n\nSee https://github.com/rabbitmq/amqp091-go/blob/b3d409fe92c34bea04d8123a136384c85e8dc431/types.go#L282-L362 for more information on available arguments.",
              "required": false,
              "default": null,
              "examples": [
                {
                  "x-max-length": 1000,
                  "x-max-length-bytes": 4096,
                  "x-queue-type": "quorum"
                }
              ],
              "advanced": true
            }
          ]
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. The first URL to successfully establish a connection will be used until the connection is closed. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "amqp://guest:guest@127.0.0.1:5672/"
            ],
            [
              "amqp://127.0.0.1:5672/,amqp://127.0.0.2:5672/"
            ],
            [
              "amqp://127.0.0.1:5672/",
              "amqp://127.0.0.2:5672/"
            ]
          ]
        }
      }
    },
    "amqp_1": {
      "name": "amqp_1",
      "type": "input",
      "source": "upstream",
      "summary": "Reads messages from an AMQP (1.0) server.",
      "description": "== Metadata\n\nThis input adds the following metadata fields to each message:\n\n```text\n- amqp_content_type\n- amqp_content_encoding\n- amqp_creation_time\n- All string typed message annotations\n```\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation].\n\nBy setting `read_header` to `true`, additional message header properties will be added to each message:\n\n```text\n- amqp_durable\n- amqp_priority\n- amqp_ttl\n- amqp_first_acquirer\n- amqp_delivery_count\n```\n\n== Performance\n\nThis input benefits from receiving multiple messages in flight in parallel for improved performance.\nYou can tune the max number of in flight messages with the field `credit`.\n",
      "config": {
        "azure_renew_lock": {
          "name": "azure_renew_lock",
          "type": "bool",
          "kind": "scalar",
          "description": "Experimental: Azure service bus specific option to renew lock if processing takes more then configured lock time",
          "required": true,
          "default": false,
          "advanced": true
        },
        "credit": {
          "name": "credit",
          "type": "int",
          "kind": "scalar",
          "description": "Specifies the maximum number of unacknowledged messages the sender can transmit. Once this limit is reached, no more messages will arrive until messages are acknowledged and settled.",
          "required": true,
          "default": 64,
          "advanced": true
        },
        "read_header": {
          "name": "read_header",
          "type": "bool",
          "kind": "scalar",
          "description": "Read additional message header fields into `amqp_*` metadata properties.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "sasl": {
          "name": "sasl",
          "type": "object",
          "kind": "scalar",
          "description": "Enables SASL authentication.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "mechanism",
              "type": "string",
              "kind": "scalar",
              "description": "The SASL authentication mechanism to use.",
              "required": true,
              "default": "none",
              "advanced": true
            },
            {
              "name": "user",
              "type": "string",
              "kind": "scalar",
              "description": "A SASL plain text username. It is recommended that you use environment variables to populate this field.",
              "required": true,
              "default": "",
              "examples": [
                "${USER}"
              ],
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A SASL plain text password. It is recommended that you use environment variables to populate this field.",
              "required": true,
              "default": "",
              "examples": [
                "${PASSWORD}"
              ],
              "advanced": true
            }
          ]
        },
        "source_address": {
          "name": "source_address",
          "type": "string",
          "kind": "scalar",
          "description": "The source address to consume from.",
          "required": true,
          "default": null,
          "examples": [
            "/foo",
            "queue:/bar",
            "topic:/baz"
          ]
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "A URL to connect to.",
          "required": false,
          "default": null,
          "examples": [
            "amqp://localhost:5672/",
            "amqps://guest:guest@localhost:5672/"
          ]
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. The first URL to successfully establish a connection will be used until the connection is closed. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": false,
          "default": null,
          "examples": [
            [
              "amqp://guest:guest@127.0.0.1:5672/"
            ],
            [
              "amqp://127.0.0.1:5672/,amqp://127.0.0.2:5672/"
            ],
            [
              "amqp://127.0.0.1:5672/",
              "amqp://127.0.0.2:5672/"
            ]
          ]
        }
      }
    },
    "aws_kinesis": {
      "name": "aws_kinesis",
      "type": "input",
      "source": "upstream",
      "summary": "Receive messages from one or more Kinesis streams.",
      "description": "\nConsumes messages from one or more Kinesis streams either by automatically balancing shards across other instances of this input, or by consuming shards listed explicitly. The latest message sequence consumed by this input is stored within a \u003c\u003ctable-schema,DynamoDB table\u003e\u003e, which allows it to resume at the correct sequence of the shard during restarts. This table is also used for coordination across distributed inputs when shard balancing.\n\nRedpanda Connect will not store a consumed sequence unless it is acknowledged at the output level, which ensures at-least-once delivery guarantees.\n\n== Ordering\n\nBy default messages of a shard can be processed in parallel, up to a limit determined by the field `checkpoint_limit`. However, if strict ordered processing is required then this value must be set to 1 in order to process shard messages in lock-step. When doing so it is recommended that you perform batching at this component for performance as it will not be possible to batch lock-stepped messages at the output level.\n\n== Table schema\n\nIt's possible to configure Redpanda Connect to create the DynamoDB table required for coordination if it does not already exist. However, if you wish to create this yourself (recommended) then create a table with a string HASH key `StreamID` and a string RANGE key `ShardID`.\n\n== Batching\n\nUse the `batching` fields to configure an optional xref:configuration:batching.adoc#batch-policy[batching policy]. Each stream shard will be batched separately in order to ensure that acknowledgements aren't contaminated.\n",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "checkpoint_limit": {
          "name": "checkpoint_limit",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum gap between the in flight sequence versus the latest acknowledged sequence at a given time. Increasing this limit enables parallel processing and batching at the output level to work on individual shards. Any given sequence will not be committed unless all messages under that offset are delivered in order to preserve at least once delivery guarantees.",
          "required": true,
          "default": 1024
        },
        "commit_period": {
          "name": "commit_period",
          "type": "string",
          "kind": "scalar",
          "description": "The period of time between each update to the checkpoint table.",
          "required": true,
          "default": "5s"
        },
        "credentials": {
          "name": "credentials",
          "type": "object",
          "kind": "scalar",
          "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "profile",
              "type": "string",
              "kind": "scalar",
              "description": "A profile from `~/.aws/credentials` to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "id",
              "type": "string",
              "kind": "scalar",
              "description": "The ID of credentials to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "secret",
              "type": "string",
              "kind": "scalar",
              "description": "The secret for the credentials being used.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token",
              "type": "string",
              "kind": "scalar",
              "description": "The token for the credentials being used, required when using short term credentials.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "from_ec2_role",
              "type": "bool",
              "kind": "scalar",
              "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "role",
              "type": "string",
              "kind": "scalar",
              "description": "A role ARN to assume.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "role_external_id",
              "type": "string",
              "kind": "scalar",
              "description": "An external ID to provide when assuming a role.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "dynamodb": {
          "name": "dynamodb",
          "type": "object",
          "kind": "scalar",
          "description": "Determines the table used for storing and accessing the latest consumed sequence for shards, and for coordinating balanced consumers of streams.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "table",
              "type": "string",
              "kind": "scalar",
              "description": "The name of the table to access.",
              "required": true,
              "default": ""
            },
            {
              "name": "create",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether, if the table does not exist, it should be created.",
              "required": true,
              "default": false
            },
            {
              "name": "billing_mode",
              "type": "string",
              "kind": "scalar",
              "description": "When creating the table determines the billing mode.",
              "required": true,
              "default": "PAY_PER_REQUEST",
              "options": [
                "PROVISIONED",
                "PAY_PER_REQUEST"
              ],
              "advanced": true
            },
            {
              "name": "read_capacity_units",
              "type": "int",
              "kind": "scalar",
              "description": "Set the provisioned read capacity when creating the table with a `billing_mode` of `PROVISIONED`.",
              "required": true,
              "default": 0,
              "advanced": true
            },
            {
              "name": "write_capacity_units",
              "type": "int",
              "kind": "scalar",
              "description": "Set the provisioned write capacity when creating the table with a `billing_mode` of `PROVISIONED`.",
              "required": true,
              "default": 0,
              "advanced": true
            }
          ]
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "Allows you to specify a custom endpoint for the AWS API.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "lease_period": {
          "name": "lease_period",
          "type": "string",
          "kind": "scalar",
          "description": "The period of time after which a client that has failed to update a shard checkpoint is assumed to be inactive.",
          "required": true,
          "default": "30s",
          "advanced": true
        },
        "rebalance_period": {
          "name": "rebalance_period",
          "type": "string",
          "kind": "scalar",
          "description": "The period of time between each attempt to rebalance shards across clients.",
          "required": true,
          "default": "30s",
          "advanced": true
        },
        "region": {
          "name": "region",
          "type": "string",
          "kind": "scalar",
          "description": "The AWS region to target.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "start_from_oldest": {
          "name": "start_from_oldest",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to consume from the oldest message when a sequence does not yet exist for the stream.",
          "required": true,
          "default": true
        },
        "streams": {
          "name": "streams",
          "type": "string",
          "kind": "array",
          "description": "One or more Kinesis data streams to consume from. Streams can either be specified by their name or full ARN. Shards of a stream are automatically balanced across consumers by coordinating through the provided DynamoDB table. Multiple comma separated streams can be listed in a single element. Shards are automatically distributed across consumers of a stream by coordinating through the provided DynamoDB table. Alternatively, it's possible to specify an explicit shard to consume from with a colon after the stream name, e.g. `foo:0` would consume the shard `0` of the stream `foo`.",
          "required": true,
          "default": null,
          "examples": [
            [
              "foo",
              "arn:aws:kinesis:*:111122223333:stream/my-stream"
            ]
          ]
        }
      }
    },
    "aws_s3": {
      "name": "aws_s3",
      "type": "input",
      "source": "upstream",
      "summary": "Downloads objects within an Amazon S3 bucket, optionally filtered by a prefix, either by walking the items in the bucket or by streaming upload notifications in realtime.",
      "description": "\n== Stream objects on upload with SQS\n\nA common pattern for consuming S3 objects is to emit upload notification events from the bucket either directly to an SQS queue, or to an SNS topic that is consumed by an SQS queue, and then have your consumer listen for events which prompt it to download the newly uploaded objects. More information about this pattern and how to set it up can be found at in the https://docs.aws.amazon.com/AmazonS3/latest/dev/ways-to-add-notification-config-to-bucket.html[Amazon S3 docs].\n\nRedpanda Connect is able to follow this pattern when you configure an `sqs.url`, where it consumes events from SQS and only downloads object keys received within those events. In order for this to work Redpanda Connect needs to know where within the event the key and bucket names can be found, specified as xref:configuration:field_paths.adoc[dot paths] with the fields `sqs.key_path` and `sqs.bucket_path`. The default values for these fields should already be correct when following the guide above.\n\nIf your notification events are being routed to SQS via an SNS topic then the events will be enveloped by SNS, in which case you also need to specify the field `sqs.envelope_path`, which in the case of SNS to SQS will usually be `Message`.\n\nWhen using SQS please make sure you have sensible values for `sqs.max_messages` and also the visibility timeout of the queue itself. When Redpanda Connect consumes an S3 object the SQS message that triggered it is not deleted until the S3 object has been sent onwards. This ensures at-least-once crash resiliency, but also means that if the S3 object takes longer to process than the visibility timeout of your queue then the same objects might be processed multiple times.\n\n== Download large files\n\nWhen downloading large files it's often necessary to process it in streamed parts in order to avoid loading the entire file in memory at a given time. In order to do this a \u003c\u003cscanner, `scanner`\u003e\u003e can be specified that determines how to break the input into smaller individual messages.\n\n== Credentials\n\nBy default Redpanda Connect will use a shared credentials file when connecting to AWS services. It's also possible to set them explicitly at the component level, allowing you to transfer data across accounts. You can find out more  in xref:guides:cloud/aws.adoc[].\n\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n- s3_key\n- s3_bucket\n- s3_last_modified_unix\n- s3_last_modified (RFC3339)\n- s3_content_type\n- s3_content_encoding\n- s3_version_id\n- All user defined metadata\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation]. Note that user defined metadata is case insensitive within AWS, and it is likely that the keys will be received in a capitalized form, if you wish to make them consistent you can map all metadata keys to lower or uppercase using a Bloblang mapping such as `meta = meta().map_each_key(key -\u003e key.lowercase())`.",
      "config": {
        "bucket": {
          "name": "bucket",
          "type": "string",
          "kind": "scalar",
          "description": "The bucket to consume from. If the field `sqs.url` is specified this field is optional.",
          "required": true,
          "default": ""
        },
        "codec": {
          "name": "codec",
          "type": "string",
          "kind": "scalar",
          "description": "The way in which the bytes of a data source should be converted into discrete messages, codecs are useful for specifying how large files or continuous streams of data might be processed in small chunks rather than loading it all in memory. It's possible to consume lines using a custom delimiter with the `delim:x` codec, where x is the character sequence custom delimiter. Codecs can be chained with `/`, for example a gzip compressed CSV file can be consumed with the codec `gzip/csv`.",
          "required": false,
          "default": null,
          "examples": [
            "lines",
            "delim:\t",
            "delim:foobar",
            "gzip/csv"
          ]
        },
        "credentials": {
          "name": "credentials",
          "type": "object",
          "kind": "scalar",
          "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "profile",
              "type": "string",
              "kind": "scalar",
              "description": "A profile from `~/.aws/credentials` to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "id",
              "type": "string",
              "kind": "scalar",
              "description": "The ID of credentials to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "secret",
              "type": "string",
              "kind": "scalar",
              "description": "The secret for the credentials being used.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token",
              "type": "string",
              "kind": "scalar",
              "description": "The token for the credentials being used, required when using short term credentials.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "from_ec2_role",
              "type": "bool",
              "kind": "scalar",
              "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "role",
              "type": "string",
              "kind": "scalar",
              "description": "A role ARN to assume.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "role_external_id",
              "type": "string",
              "kind": "scalar",
              "description": "An external ID to provide when assuming a role.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "delete_objects": {
          "name": "delete_objects",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to delete downloaded objects from the bucket once they are processed.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "Allows you to specify a custom endpoint for the AWS API.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "force_path_style_urls": {
          "name": "force_path_style_urls",
          "type": "bool",
          "kind": "scalar",
          "description": "Forces the client API to use path style URLs for downloading keys, which is often required when connecting to custom endpoints.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "max_buffer": {
          "name": "max_buffer",
          "type": "int",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": 1000000
        },
        "prefix": {
          "name": "prefix",
          "type": "string",
          "kind": "scalar",
          "description": "An optional path prefix, if set only objects with the prefix are consumed when walking a bucket.",
          "required": true,
          "default": ""
        },
        "region": {
          "name": "region",
          "type": "string",
          "kind": "scalar",
          "description": "The AWS region to target.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "scanner": {
          "name": "scanner",
          "type": "scanner",
          "kind": "scalar",
          "description": "The xref:components:scanners/about.adoc[scanner] by which the stream of bytes consumed will be broken out into individual messages. Scanners are useful for processing large sources of data without holding the entirety of it within memory. For example, the `csv` scanner allows you to process individual CSV rows without loading the entire CSV file in memory at once.",
          "required": false,
          "default": {
            "to_the_end": {}
          }
        },
        "sqs": {
          "name": "sqs",
          "type": "object",
          "kind": "scalar",
          "description": "Consume SQS messages in order to trigger key downloads.",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "url",
              "type": "string",
              "kind": "scalar",
              "description": "An optional SQS URL to connect to. When specified this queue will control which objects are downloaded.",
              "required": true,
              "default": ""
            },
            {
              "name": "endpoint",
              "type": "string",
              "kind": "scalar",
              "description": "A custom endpoint to use when connecting to SQS.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "key_path",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:configuration:field_paths.adoc[dot path] whereby object keys are found in SQS messages.",
              "required": true,
              "default": "Records.*.s3.object.key"
            },
            {
              "name": "bucket_path",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:configuration:field_paths.adoc[dot path] whereby the bucket name can be found in SQS messages.",
              "required": true,
              "default": "Records.*.s3.bucket.name"
            },
            {
              "name": "envelope_path",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:configuration:field_paths.adoc[dot path] of a field to extract an enveloped JSON payload for further extracting the key and bucket from SQS messages. This is specifically useful when subscribing an SQS queue to an SNS topic that receives bucket events.",
              "required": true,
              "default": "",
              "examples": [
                "Message"
              ]
            },
            {
              "name": "delay_period",
              "type": "string",
              "kind": "scalar",
              "description": "An optional period of time to wait from when a notification was originally sent to when the target key download is attempted.",
              "required": true,
              "default": "",
              "examples": [
                "10s",
                "5m"
              ],
              "advanced": true
            },
            {
              "name": "max_messages",
              "type": "int",
              "kind": "scalar",
              "description": "The maximum number of SQS messages to consume from each request.",
              "required": true,
              "default": 10,
              "advanced": true
            },
            {
              "name": "wait_time_seconds",
              "type": "int",
              "kind": "scalar",
              "description": "Whether to set the wait time. Enabling this activates long-polling. Valid values: 0 to 20.",
              "required": true,
              "default": 0,
              "advanced": true
            }
          ]
        }
      }
    },
    "aws_sqs": {
      "name": "aws_sqs",
      "type": "input",
      "source": "upstream",
      "summary": "Consume messages from an AWS SQS URL.",
      "description": "\n== Credentials\n\nBy default Redpanda Connect will use a shared credentials file when connecting to AWS\nservices. It's also possible to set them explicitly at the component level,\nallowing you to transfer data across accounts. You can find out more in\nxref:guides:cloud/aws.adoc[].\n\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n- sqs_message_id\n- sqs_receipt_handle\n- sqs_approximate_receive_count\n- All message attributes\n\nYou can access these metadata fields using\nxref:configuration:interpolation.adoc#bloblang-queries[function interpolation].",
      "config": {
        "credentials": {
          "name": "credentials",
          "type": "object",
          "kind": "scalar",
          "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "profile",
              "type": "string",
              "kind": "scalar",
              "description": "A profile from `~/.aws/credentials` to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "id",
              "type": "string",
              "kind": "scalar",
              "description": "The ID of credentials to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "secret",
              "type": "string",
              "kind": "scalar",
              "description": "The secret for the credentials being used.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token",
              "type": "string",
              "kind": "scalar",
              "description": "The token for the credentials being used, required when using short term credentials.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "from_ec2_role",
              "type": "bool",
              "kind": "scalar",
              "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "role",
              "type": "string",
              "kind": "scalar",
              "description": "A role ARN to assume.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "role_external_id",
              "type": "string",
              "kind": "scalar",
              "description": "An external ID to provide when assuming a role.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "delete_message": {
          "name": "delete_message",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to delete the consumed message once it is acked. Disabling allows you to handle the deletion using a different mechanism.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "Allows you to specify a custom endpoint for the AWS API.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "max_number_of_messages": {
          "name": "max_number_of_messages",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to return on one poll. Valid values: 1 to 10.",
          "required": true,
          "default": 10,
          "advanced": true
        },
        "max_outstanding_messages": {
          "name": "max_outstanding_messages",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of outstanding pending messages to be consumed at a given time.",
          "required": true,
          "default": 1000
        },
        "message_timeout": {
          "name": "message_timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The time to process messages before needing to refresh the receipt handle. Messages will be eligible for refresh when half of the timeout has elapsed. This sets MessageVisibility for each received message.",
          "required": true,
          "default": "30s",
          "advanced": true
        },
        "region": {
          "name": "region",
          "type": "string",
          "kind": "scalar",
          "description": "The AWS region to target.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "reset_visibility": {
          "name": "reset_visibility",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to set the visibility timeout of the consumed message to zero once it is nacked. Disabling honors the preset visibility timeout specified for the queue.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The SQS URL to consume from.",
          "required": true,
          "default": null
        },
        "wait_time_seconds": {
          "name": "wait_time_seconds",
          "type": "int",
          "kind": "scalar",
          "description": "Whether to set the wait time. Enabling this activates long-polling. Valid values: 0 to 20.",
          "required": true,
          "default": 0,
          "advanced": true
        }
      }
    },
    "azure_blob_storage": {
      "name": "azure_blob_storage",
      "type": "input",
      "source": "upstream",
      "summary": "Downloads objects within an Azure Blob Storage container, optionally filtered by a prefix.",
      "description": "\nSupports multiple authentication methods but only one of the following is required:\n\n- `storage_connection_string`\n- `storage_account` and `storage_access_key`\n- `storage_account` and `storage_sas_token`\n- `storage_account` to access via https://pkg.go.dev/github.com/Azure/azure-sdk-for-go/sdk/azidentity#DefaultAzureCredential[DefaultAzureCredential^]\n\nIf multiple are set then the `storage_connection_string` is given priority.\n\nIf the `storage_connection_string` does not contain the `AccountName` parameter, please specify it in the\n`storage_account` field.\n\n== Download large files\n\nWhen downloading large files it's often necessary to process it in streamed parts in order to avoid loading the entire file in memory at a given time. In order to do this a \u003c\u003cscanner, `scanner`\u003e\u003e can be specified that determines how to break the input into smaller individual messages.\n\n== Stream new files\n\nBy default this input will consume all files found within the target container and will then gracefully terminate. This is referred to as a \"batch\" mode of operation. However, it's possible to instead configure a container as https://learn.microsoft.com/en-gb/azure/event-grid/event-schema-blob-storage[an Event Grid source^] and then use this as a \u003c\u003ctargetsinput, `targets_input`\u003e\u003e, in which case new files are consumed as they're uploaded and Redpanda Connect will continue listening for and downloading files as they arrive. This is referred to as a \"streamed\" mode of operation.\n\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n- blob_storage_key\n- blob_storage_container\n- blob_storage_last_modified\n- blob_storage_last_modified_unix\n- blob_storage_content_type\n- blob_storage_content_encoding\n- All user defined metadata\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation].",
      "config": {
        "codec": {
          "name": "codec",
          "type": "string",
          "kind": "scalar",
          "description": "The way in which the bytes of a data source should be converted into discrete messages, codecs are useful for specifying how large files or continuous streams of data might be processed in small chunks rather than loading it all in memory. It's possible to consume lines using a custom delimiter with the `delim:x` codec, where x is the character sequence custom delimiter. Codecs can be chained with `/`, for example a gzip compressed CSV file can be consumed with the codec `gzip/csv`.",
          "required": false,
          "default": null,
          "examples": [
            "lines",
            "delim:\t",
            "delim:foobar",
            "gzip/csv"
          ]
        },
        "container": {
          "name": "container",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the container from which to download blobs.",
          "required": true,
          "default": null
        },
        "delete_objects": {
          "name": "delete_objects",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to delete downloaded objects from the blob once they are processed.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "max_buffer": {
          "name": "max_buffer",
          "type": "int",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": 1000000
        },
        "prefix": {
          "name": "prefix",
          "type": "string",
          "kind": "scalar",
          "description": "An optional path prefix, if set only objects with the prefix are consumed.",
          "required": true,
          "default": ""
        },
        "scanner": {
          "name": "scanner",
          "type": "scanner",
          "kind": "scalar",
          "description": "The xref:components:scanners/about.adoc[scanner] by which the stream of bytes consumed will be broken out into individual messages. Scanners are useful for processing large sources of data without holding the entirety of it within memory. For example, the `csv` scanner allows you to process individual CSV rows without loading the entire CSV file in memory at once.",
          "required": false,
          "default": {
            "to_the_end": {}
          }
        },
        "storage_access_key": {
          "name": "storage_access_key",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account access key. This field is ignored if `storage_connection_string` is set.",
          "required": true,
          "default": ""
        },
        "storage_account": {
          "name": "storage_account",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account to access. This field is ignored if `storage_connection_string` is set.",
          "required": true,
          "default": ""
        },
        "storage_connection_string": {
          "name": "storage_connection_string",
          "type": "string",
          "kind": "scalar",
          "description": "A storage account connection string. This field is required if `storage_account` and `storage_access_key` / `storage_sas_token` are not set.",
          "required": true,
          "default": ""
        },
        "storage_sas_token": {
          "name": "storage_sas_token",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account SAS token. This field is ignored if `storage_connection_string` or `storage_access_key` are set.",
          "required": true,
          "default": ""
        },
        "targets_input": {
          "name": "targets_input",
          "type": "input",
          "kind": "scalar",
          "description": "EXPERIMENTAL: An optional source of download targets, configured as a xref:components:inputs/about.adoc[regular Redpanda Connect input]. Each message yielded by this input should be a single structured object containing a field `name`, which represents the blob to be downloaded.",
          "required": false,
          "default": null,
          "examples": [
            {
              "mqtt": {
                "topics": [
                  "some-topic"
                ],
                "urls": [
                  "example.westeurope-1.ts.eventgrid.azure.net:8883"
                ]
              },
              "processors": [
                {
                  "unarchive": {
                    "format": "json_array"
                  }
                },
                {
                  "mapping": "if this.eventType == \"Microsoft.Storage.BlobCreated\" {\n  root.name = this.data.url.parse_url().path.trim_prefix(\"/foocontainer/\")\n} else {\n  root = deleted()\n}"
                }
              ]
            }
          ]
        }
      }
    },
    "azure_cosmosdb": {
      "name": "azure_cosmosdb",
      "type": "input",
      "source": "upstream",
      "summary": "Executes a SQL query against https://learn.microsoft.com/en-us/azure/cosmos-db/introduction[Azure CosmosDB^] and creates a batch of messages from each page of items.",
      "description": "\n== Cross-partition queries\n\nCross-partition queries are currently not supported by the underlying driver. For every query, the PartitionKey values must be known in advance and specified in the config. https://github.com/Azure/azure-sdk-for-go/issues/18578#issuecomment-1222510989[See details^].\n\n\n== Credentials\n\nYou can use one of the following authentication mechanisms:\n\n- Set the `endpoint` field and the `account_key` field\n- Set only the `endpoint` field to use https://pkg.go.dev/github.com/Azure/azure-sdk-for-go/sdk/azidentity#DefaultAzureCredential[DefaultAzureCredential^]\n- Set the `connection_string` field\n\n\n== Metadata\n\nThis component adds the following metadata fields to each message:\n```\n- activity_id\n- request_charge\n```\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation].\n",
      "config": {
        "account_key": {
          "name": "account_key",
          "type": "string",
          "kind": "scalar",
          "description": "Account key.",
          "required": false,
          "default": null,
          "examples": [
            "C2y6yDjf5/R+ob0N8A7Cgv30VRDJIWEHLM+4QDU5DE2nQ9nDuVTqobD4b8mGGyPMbIZnqyMsEcaGQy67XIw/Jw=="
          ]
        },
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] that, for each message, creates a list of arguments to use with the query.",
          "required": false,
          "default": null,
          "examples": [
            "root = [\n  { \"Name\": \"@name\", \"Value\": \"benthos\" },\n]"
          ]
        },
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "batch_count": {
          "name": "batch_count",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages that should be accumulated into each batch. Use '-1' specify dynamic page size.",
          "required": true,
          "default": -1,
          "advanced": true
        },
        "connection_string": {
          "name": "connection_string",
          "type": "string",
          "kind": "scalar",
          "description": "Connection string.",
          "required": false,
          "default": null,
          "examples": [
            "AccountEndpoint=https://localhost:8081/;AccountKey=C2y6yDjf5/R+ob0N8A7Cgv30VRDJIWEHLM+4QDU5DE2nQ9nDuVTqobD4b8mGGyPMbIZnqyMsEcaGQy67XIw/Jw==;"
          ]
        },
        "container": {
          "name": "container",
          "type": "string",
          "kind": "scalar",
          "description": "Container.",
          "required": true,
          "default": null,
          "examples": [
            "testcontainer"
          ]
        },
        "database": {
          "name": "database",
          "type": "string",
          "kind": "scalar",
          "description": "Database.",
          "required": true,
          "default": null,
          "examples": [
            "testdb"
          ]
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "CosmosDB endpoint.",
          "required": false,
          "default": null,
          "examples": [
            "https://localhost:8081"
          ]
        },
        "partition_keys_map": {
          "name": "partition_keys_map",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to a single partition key value or an array of partition key values of type string, integer or boolean. Currently, hierarchical partition keys are not supported so only one value may be provided.",
          "required": true,
          "default": null,
          "examples": [
            "root = \"blobfish\"",
            "root = 41",
            "root = true",
            "root = null",
            "root = now().ts_format(\"2006-01-02\")"
          ]
        },
        "query": {
          "name": "query",
          "type": "string",
          "kind": "scalar",
          "description": "The query to execute",
          "required": true,
          "default": null,
          "examples": [
            "SELECT c.foo FROM testcontainer AS c WHERE c.bar = \"baz\" AND c.timestamp \u003c @timestamp"
          ]
        }
      }
    },
    "azure_queue_storage": {
      "name": "azure_queue_storage",
      "type": "input",
      "source": "upstream",
      "summary": "Dequeue objects from an Azure Storage Queue.",
      "description": "\nThis input adds the following metadata fields to each message:\n\n```\n- queue_storage_insertion_time\n- queue_storage_queue_name\n- queue_storage_message_lag (if 'track_properties' set to true)\n- All user defined queue metadata\n```\n\nOnly one authentication method is required, `storage_connection_string` or `storage_account` and `storage_access_key`. If both are set then the `storage_connection_string` is given priority.",
      "config": {
        "dequeue_visibility_timeout": {
          "name": "dequeue_visibility_timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The timeout duration until a dequeued message gets visible again, 30s by default",
          "required": true,
          "default": "30s",
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of unprocessed messages to fetch at a given time.",
          "required": true,
          "default": 10,
          "advanced": true
        },
        "queue_name": {
          "name": "queue_name",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the source storage queue.",
          "required": true,
          "default": null,
          "examples": [
            "foo_queue",
            "${! env(\"MESSAGE_TYPE\").lowercase() }"
          ]
        },
        "storage_access_key": {
          "name": "storage_access_key",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account access key. This field is ignored if `storage_connection_string` is set.",
          "required": true,
          "default": ""
        },
        "storage_account": {
          "name": "storage_account",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account to access. This field is ignored if `storage_connection_string` is set.",
          "required": true,
          "default": ""
        },
        "storage_connection_string": {
          "name": "storage_connection_string",
          "type": "string",
          "kind": "scalar",
          "description": "A storage account connection string. This field is required if `storage_account` and `storage_access_key` / `storage_sas_token` are not set.",
          "required": true,
          "default": ""
        },
        "storage_sas_token": {
          "name": "storage_sas_token",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": ""
        },
        "track_properties": {
          "name": "track_properties",
          "type": "bool",
          "kind": "scalar",
          "description": "If set to `true` the queue is polled on each read request for information such as the queue message lag. These properties are added to consumed messages as metadata, but will also have a negative performance impact.",
          "required": true,
          "default": false,
          "advanced": true
        }
      }
    },
    "azure_table_storage": {
      "name": "azure_table_storage",
      "type": "input",
      "source": "upstream",
      "summary": "Queries an Azure Storage Account Table, optionally with multiple filters.",
      "description": "\nQueries an Azure Storage Account Table, optionally with multiple filters.\n== Metadata\nThis input adds the following metadata fields to each message:\n\n- table_storage_name\n- row_num\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation].",
      "config": {
        "filter": {
          "name": "filter",
          "type": "string",
          "kind": "scalar",
          "description": "OData filter expression. Is not set all rows are returned. Valid operators are `eq, ne, gt, lt, ge and le`",
          "required": true,
          "default": "",
          "examples": [
            "PartitionKey eq 'foo' and RowKey gt '1000'"
          ],
          "advanced": true
        },
        "page_size": {
          "name": "page_size",
          "type": "int",
          "kind": "scalar",
          "description": "Maximum number of records to return on each page.",
          "required": true,
          "default": 1000,
          "advanced": true
        },
        "select": {
          "name": "select",
          "type": "string",
          "kind": "scalar",
          "description": "Select expression using OData notation. Limits the columns on each record to just those requested.",
          "required": true,
          "default": "",
          "examples": [
            "PartitionKey,RowKey,Foo,Bar,Timestamp"
          ],
          "advanced": true
        },
        "storage_access_key": {
          "name": "storage_access_key",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account access key. This field is ignored if `storage_connection_string` is set.",
          "required": true,
          "default": ""
        },
        "storage_account": {
          "name": "storage_account",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account to access. This field is ignored if `storage_connection_string` is set.",
          "required": true,
          "default": ""
        },
        "storage_connection_string": {
          "name": "storage_connection_string",
          "type": "string",
          "kind": "scalar",
          "description": "A storage account connection string. This field is required if `storage_account` and `storage_access_key` / `storage_sas_token` are not set.",
          "required": true,
          "default": ""
        },
        "storage_sas_token": {
          "name": "storage_sas_token",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account SAS token. This field is ignored if `storage_connection_string` or `storage_access_key` are set.",
          "required": true,
          "default": ""
        },
        "table_name": {
          "name": "table_name",
          "type": "string",
          "kind": "scalar",
          "description": "The table to read messages from.",
          "required": true,
          "default": null,
          "examples": [
            "Foo"
          ]
        }
      }
    },
    "batched": {
      "name": "batched",
      "type": "input",
      "source": "upstream",
      "summary": "Consumes data from a child input and applies a batching policy to the stream.",
      "description": "Batching at the input level is sometimes useful for processing across micro-batches, and can also sometimes be a useful performance trick. However, most inputs are fine without it so unless you have a specific plan for batching this component is not worth using.",
      "config": {
        "child": {
          "name": "child",
          "type": "input",
          "kind": "scalar",
          "description": "The child input.",
          "required": true,
          "default": null
        },
        "policy": {
          "name": "policy",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        }
      }
    },
    "beanstalkd": {
      "name": "beanstalkd",
      "type": "input",
      "source": "upstream",
      "summary": "Reads messages from a Beanstalkd queue.",
      "config": {
        "address": {
          "name": "address",
          "type": "string",
          "kind": "scalar",
          "description": "An address to connect to.",
          "required": true,
          "default": null,
          "examples": [
            "127.0.0.1:11300"
          ]
        }
      }
    },
    "broker": {
      "name": "broker",
      "type": "input",
      "source": "upstream",
      "summary": "Allows you to combine multiple inputs into a single stream of data, where each input will be read in parallel.",
      "description": "\nA broker type is configured with its own list of input configurations and a field to specify how many copies of the list of inputs should be created.\n\nAdding more input types allows you to combine streams from multiple sources into one. For example, reading from both RabbitMQ and Kafka:\n\n```yaml\ninput:\n  broker:\n    copies: 1\n    inputs:\n      - amqp_0_9:\n          urls:\n            - amqp://guest:guest@localhost:5672/\n          consumer_tag: benthos-consumer\n          queue: benthos-queue\n\n        # Optional list of input specific processing steps\n        processors:\n          - mapping: |\n              root.message = this\n              root.meta.link_count = this.links.length()\n              root.user.age = this.user.age.number()\n\n      - kafka:\n          addresses:\n            - localhost:9092\n          client_id: benthos_kafka_input\n          consumer_group: benthos_consumer_group\n          topics: [ benthos_stream:0 ]\n```\n\nIf the number of copies is greater than zero the list will be copied that number of times. For example, if your inputs were of type foo and bar, with 'copies' set to '2', you would end up with two 'foo' inputs and two 'bar' inputs.\n\n== Batching\n\nIt's possible to configure a xref:configuration:batching.adoc#batch-policy[batch policy] with a broker using the `batching` fields. When doing this the feeds from all child inputs are combined. Some inputs do not support broker based batching and specify this in their documentation.\n\n== Processors\n\nIt is possible to configure xref:components:processors/about.adoc[processors] at the broker level, where they will be applied to _all_ child inputs, as well as on the individual child inputs. If you have processors at both the broker level _and_ on child inputs then the broker processors will be applied _after_ the child nodes processors.",
      "config": {
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "copies": {
          "name": "copies",
          "type": "int",
          "kind": "scalar",
          "description": "Whatever is specified within `inputs` will be created this many times.",
          "required": true,
          "default": 1,
          "advanced": true
        },
        "inputs": {
          "name": "inputs",
          "type": "input",
          "kind": "array",
          "description": "A list of inputs to create.",
          "required": true,
          "default": null
        }
      }
    },
    "cassandra": {
      "name": "cassandra",
      "type": "input",
      "source": "upstream",
      "summary": "Executes a find query and creates a message for each row received.",
      "config": {
        "addresses": {
          "name": "addresses",
          "type": "string",
          "kind": "array",
          "description": "A list of Cassandra nodes to connect to. Multiple comma separated addresses can be specified on a single line.",
          "required": true,
          "default": null,
          "examples": [
            [
              "localhost:9042"
            ],
            [
              "foo:9042",
              "bar:9042"
            ],
            [
              "foo:9042,bar:9042"
            ]
          ]
        },
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "backoff": {
          "name": "backoff",
          "type": "object",
          "kind": "scalar",
          "description": "Control time intervals between retry attempts.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "initial_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The initial period to wait between retry attempts.",
              "required": true,
              "default": "1s",
              "advanced": true
            },
            {
              "name": "max_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait between retry attempts.",
              "required": true,
              "default": "5s",
              "advanced": true
            }
          ]
        },
        "disable_initial_host_lookup": {
          "name": "disable_initial_host_lookup",
          "type": "bool",
          "kind": "scalar",
          "description": "If enabled the driver will not attempt to get host info from the system.peers table. This can speed up queries but will mean that data_centre, rack and token information will not be available.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "max_retries": {
          "name": "max_retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retries before giving up on a request.",
          "required": true,
          "default": 3,
          "advanced": true
        },
        "password_authenticator": {
          "name": "password_authenticator",
          "type": "object",
          "kind": "scalar",
          "description": "Optional configuration of Cassandra authentication parameters.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use password authentication",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "The username to authenticate as.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "The password to authenticate with.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "query": {
          "name": "query",
          "type": "string",
          "kind": "scalar",
          "description": "A query to execute.",
          "required": true,
          "default": null
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The client connection timeout.",
          "required": true,
          "default": "600ms"
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        }
      }
    },
    "cockroachdb_changefeed": {
      "name": "cockroachdb_changefeed",
      "type": "input",
      "source": "upstream",
      "summary": "Listens to a https://www.cockroachlabs.com/docs/stable/changefeed-examples[CockroachDB Core Changefeed^] and creates a message for each row received. Each message is a json object looking like: \n```json\n{\n\t\"primary_key\": \"[\\\"1a7ff641-3e3b-47ee-94fe-a0cadb56cd8f\\\", 2]\", // stringifed JSON array\n\t\"row\": \"{\\\"after\\\": {\\\"k\\\": \\\"1a7ff641-3e3b-47ee-94fe-a0cadb56cd8f\\\", \\\"v\\\": 2}, \\\"updated\\\": \\\"1637953249519902405.0000000000\\\"}\", // stringified JSON object\n\t\"table\": \"strm_2\"\n}\n```",
      "description": "This input will continue to listen to the changefeed until shutdown. A backfill of the full current state of the table will be delivered upon each run unless a cache is configured for storing cursor timestamps, as this is how Redpanda Connect keeps track as to which changes have been successfully delivered.\n\nNote: You must have `SET CLUSTER SETTING kv.rangefeed.enabled = true;` on your CRDB cluster, for more information refer to https://www.cockroachlabs.com/docs/stable/changefeed-examples?filters=core[the official CockroachDB documentation^].",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "cursor_cache": {
          "name": "cursor_cache",
          "type": "string",
          "kind": "scalar",
          "description": "A https://docs.redpanda.com/redpanda-connect/components/caches/about[cache resource^] to use for storing the current latest cursor that has been successfully delivered, this allows Redpanda Connect to continue from that cursor upon restart, rather than consume the entire state of the table.",
          "required": false,
          "default": null
        },
        "dsn": {
          "name": "dsn",
          "type": "string",
          "kind": "scalar",
          "description": "A Data Source Name to identify the target database.",
          "required": true,
          "default": null,
          "examples": [
            "postgres://user:password@example.com:26257/defaultdb?sslmode=require"
          ]
        },
        "options": {
          "name": "options",
          "type": "string",
          "kind": "array",
          "description": "A list of options to be included in the changefeed (WITH X, Y...).\n\nNOTE: Both the CURSOR option and UPDATED will be ignored from these options when a `cursor_cache` is specified, as they are set explicitly by Redpanda Connect in this case.",
          "required": false,
          "default": null,
          "examples": [
            [
              "virtual_columns=\"omitted\""
            ]
          ],
          "advanced": true
        },
        "tables": {
          "name": "tables",
          "type": "string",
          "kind": "array",
          "description": "CSV of tables to be included in the changefeed",
          "required": true,
          "default": null,
          "examples": [
            [
              "table1",
              "table2"
            ]
          ]
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        }
      }
    },
    "csv": {
      "name": "csv",
      "type": "input",
      "source": "upstream",
      "summary": "Reads one or more CSV files as structured records following the format described in RFC 4180.",
      "description": "\nThis input offers more control over CSV parsing than the xref:components:inputs/file.adoc[`file` input].\n\nWhen parsing with a header row each line of the file will be consumed as a structured object, where the key names are determined from the header now. For example, the following CSV file:\n\n```csv\nfoo,bar,baz\nfirst foo,first bar,first baz\nsecond foo,second bar,second baz\n```\n\nWould produce the following messages:\n\n```json\n{\"foo\":\"first foo\",\"bar\":\"first bar\",\"baz\":\"first baz\"}\n{\"foo\":\"second foo\",\"bar\":\"second bar\",\"baz\":\"second baz\"}\n```\n\nIf, however, the field `parse_header_row` is set to `false` then arrays are produced instead, like follows:\n\n```json\n[\"first foo\",\"first bar\",\"first baz\"]\n[\"second foo\",\"second bar\",\"second baz\"]\n```\n\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n```text\n- header\n- path\n- mod_time_unix\n- mod_time (RFC3339)\n```\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation].\n\nNote: The `header` field is only set when `parse_header_row` is `true`.\n\n=== Output CSV column order\n\nWhen xref:guides:bloblang/advanced.adoc#creating-csv[creating CSV] from Redpanda Connect messages, the columns must be sorted lexicographically to make the output deterministic. Alternatively, when using the `csv` input, one can leverage the `header` metadata field to retrieve the column order:\n\n```yaml\ninput:\n  csv:\n    paths:\n      - ./foo.csv\n      - ./bar.csv\n    parse_header_row: true\n\n  processors:\n    - mapping: |\n        map escape_csv {\n          root = if this.re_match(\"[\\\"\\n,]+\") {\n            \"\\\"\" + this.replace_all(\"\\\"\", \"\\\"\\\"\") + \"\\\"\"\n          } else {\n            this\n          }\n        }\n\n        let header = if count(@path) == 1 {\n          @header.map_each(c -\u003e c.apply(\"escape_csv\")).join(\",\") + \"\\n\"\n        } else { \"\" }\n\n        root = $header + @header.map_each(c -\u003e this.get(c).string().apply(\"escape_csv\")).join(\",\")\n\noutput:\n  file:\n    path: ./output/${! @path.filepath_split().index(-1) }\n```\n",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "batch_count": {
          "name": "batch_count",
          "type": "int",
          "kind": "scalar",
          "description": "Optionally process records in batches. This can help to speed up the consumption of exceptionally large CSV files. When the end of the file is reached the remaining records are processed as a (potentially smaller) batch.",
          "required": true,
          "default": 1,
          "advanced": true
        },
        "delete_on_finish": {
          "name": "delete_on_finish",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to delete input files from the disk once they are fully consumed.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "delimiter": {
          "name": "delimiter",
          "type": "string",
          "kind": "scalar",
          "description": "The delimiter to use for splitting values in each record. It must be a single character.",
          "required": true,
          "default": ","
        },
        "lazy_quotes": {
          "name": "lazy_quotes",
          "type": "bool",
          "kind": "scalar",
          "description": "If set to `true`, a quote may appear in an unquoted field and a non-doubled quote may appear in a quoted field.",
          "required": true,
          "default": false
        },
        "parse_header_row": {
          "name": "parse_header_row",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to reference the first row as a header row. If set to true the output structure for messages will be an object where field keys are determined by the header row. Otherwise, each message will consist of an array of values from the corresponding CSV row.",
          "required": true,
          "default": true
        },
        "paths": {
          "name": "paths",
          "type": "string",
          "kind": "array",
          "description": "A list of file paths to read from. Each file will be read sequentially until the list is exhausted, at which point the input will close. Glob patterns are supported, including super globs (double star).",
          "required": true,
          "default": null,
          "examples": [
            [
              "/tmp/foo.csv",
              "/tmp/bar/*.csv",
              "/tmp/data/**/*.csv"
            ]
          ]
        }
      }
    },
    "discord": {
      "name": "discord",
      "type": "input",
      "source": "upstream",
      "summary": "Consumes messages posted in a Discord channel.",
      "description": "This input works by authenticating as a bot using token based authentication. The ID of the newest message consumed and acked is stored in a cache in order to perform a backfill of unread messages each time the input is initialised. Ideally this cache should be persisted across restarts.",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "bot_token": {
          "name": "bot_token",
          "type": "string",
          "kind": "scalar",
          "description": "A bot token used for authentication.",
          "required": true,
          "default": null
        },
        "cache": {
          "name": "cache",
          "type": "string",
          "kind": "scalar",
          "description": "A cache resource to use for performing unread message backfills, the ID of the last message received will be stored in this cache and used for subsequent requests.",
          "required": true,
          "default": null
        },
        "cache_key": {
          "name": "cache_key",
          "type": "string",
          "kind": "scalar",
          "description": "The key identifier used when storing the ID of the last message received.",
          "required": true,
          "default": "last_message_id",
          "advanced": true
        },
        "channel_id": {
          "name": "channel_id",
          "type": "string",
          "kind": "scalar",
          "description": "A discord channel ID to consume messages from.",
          "required": true,
          "default": null
        },
        "limit": {
          "name": "limit",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to receive in a single request.",
          "required": true,
          "default": 100
        },
        "poll_period": {
          "name": "poll_period",
          "type": "string",
          "kind": "scalar",
          "description": "The length of time (as a duration string) to wait between each poll for backlogged messages. This field can be set empty, in which case requests are made at the limit set by the rate limit. This field also supports cron expressions.",
          "required": true,
          "default": "1m"
        },
        "rate_limit": {
          "name": "rate_limit",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": "An optional rate limit resource to restrict API requests with."
        }
      }
    },
    "dynamic": {
      "name": "dynamic",
      "type": "input",
      "source": "upstream",
      "summary": "A special broker type where the inputs are identified by unique labels and can be created, changed and removed during runtime via a REST HTTP interface.",
      "config": {
        "inputs": {
          "name": "inputs",
          "type": "input",
          "kind": "map",
          "description": "A map of inputs to statically create.",
          "required": true,
          "default": {}
        },
        "prefix": {
          "name": "prefix",
          "type": "string",
          "kind": "scalar",
          "description": "A path prefix for HTTP endpoints that are registered.",
          "required": true,
          "default": ""
        }
      }
    },
    "ethernetip": {
      "name": "ethernetip",
      "type": "input",
      "source": "upstream",
      "summary": "Creates an input that reads data from Ethernet/IP Devices. Created \u0026 maintained by the United Manufacturing Hub. About us: www.umh.app",
      "description": "This input plugin enables Benthos to read data directly from Ethernet/IP-Devices using the CIP protocol. Configure the plugin by specifying the PLC's IP address, path and pollRate, and the data blocks to read.",
      "config": {
        "attributes": {
          "name": "attributes",
          "type": "object",
          "kind": "array",
          "description": "",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "path",
              "type": "string",
              "kind": "scalar",
              "description": "The Path consists of the following: CIP-Class - CIP-Instance - CIP-Attribute, e.g. 1-1-1. They might vary based on which controller you're using.",
              "required": true,
              "default": null
            },
            {
              "name": "type",
              "type": "string",
              "kind": "scalar",
              "description": "The type of the attribute you want to read: e.g. 'bool', 'int16', 'byte'.",
              "required": true,
              "default": null
            },
            {
              "name": "alias",
              "type": "string",
              "kind": "scalar",
              "description": "You can set an alias so the data will be stored with this alias set as name via metadata.",
              "required": false,
              "default": null
            }
          ]
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "IP address of the Ethernet/IP-Device.",
          "required": true,
          "default": null
        },
        "listAllTags": {
          "name": "listAllTags",
          "type": "bool",
          "kind": "scalar",
          "description": "You can use this option to list all available Tags, but only specific controllers support this method.",
          "required": true,
          "default": false
        },
        "path": {
          "name": "path",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": "1,0"
        },
        "pollRate": {
          "name": "pollRate",
          "type": "int",
          "kind": "scalar",
          "description": "The rate in milliseconds on which we try to read data out of the plc.",
          "required": true,
          "default": 1000
        },
        "tags": {
          "name": "tags",
          "type": "object",
          "kind": "array",
          "description": "",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "name",
              "type": "string",
              "kind": "scalar",
              "description": "The tag name is usually provided by something like this: `Program:Gologix.MyTagSet.TestBool`",
              "required": true,
              "default": null
            },
            {
              "name": "type",
              "type": "string",
              "kind": "scalar",
              "description": "The type of the tag you want to read: e.g. 'bool', 'int16', 'byte'.",
              "required": true,
              "default": null
            },
            {
              "name": "length",
              "type": "int",
              "kind": "scalar",
              "description": "The Length of the array, when specified as 'arrayof...'",
              "required": true,
              "default": 1
            },
            {
              "name": "alias",
              "type": "string",
              "kind": "scalar",
              "description": "You can set an alias so the data will be stored with this alias set as name via metadata.",
              "required": false,
              "default": null
            }
          ]
        },
        "useMultiRead": {
          "name": "useMultiRead",
          "type": "bool",
          "kind": "scalar",
          "description": "You can use this option to increase the reading time, but be aware that only specific controllers support this method.",
          "required": true,
          "default": true
        }
      }
    },
    "file": {
      "name": "file",
      "type": "input",
      "source": "upstream",
      "summary": "Consumes data from files on disk, emitting messages according to a chosen codec.",
      "description": "\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n```text\n- path\n- mod_time_unix\n- mod_time (RFC3339)\n```\n\nYou can access these metadata fields using\nxref:configuration:interpolation.adoc#bloblang-queries[function interpolation].",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "codec": {
          "name": "codec",
          "type": "string",
          "kind": "scalar",
          "description": "The way in which the bytes of a data source should be converted into discrete messages, codecs are useful for specifying how large files or continuous streams of data might be processed in small chunks rather than loading it all in memory. It's possible to consume lines using a custom delimiter with the `delim:x` codec, where x is the character sequence custom delimiter. Codecs can be chained with `/`, for example a gzip compressed CSV file can be consumed with the codec `gzip/csv`.",
          "required": false,
          "default": null,
          "examples": [
            "lines",
            "delim:\t",
            "delim:foobar",
            "gzip/csv"
          ]
        },
        "delete_on_finish": {
          "name": "delete_on_finish",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to delete input files from the disk once they are fully consumed.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "max_buffer": {
          "name": "max_buffer",
          "type": "int",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": 1000000
        },
        "paths": {
          "name": "paths",
          "type": "string",
          "kind": "array",
          "description": "A list of paths to consume sequentially. Glob patterns are supported, including super globs (double star).",
          "required": true,
          "default": null
        },
        "scanner": {
          "name": "scanner",
          "type": "scanner",
          "kind": "scalar",
          "description": "The xref:components:scanners/about.adoc[scanner] by which the stream of bytes consumed will be broken out into individual messages. Scanners are useful for processing large sources of data without holding the entirety of it within memory. For example, the `csv` scanner allows you to process individual CSV rows without loading the entire CSV file in memory at once.",
          "required": false,
          "default": {
            "lines": {}
          }
        }
      }
    },
    "gcp_bigquery_select": {
      "name": "gcp_bigquery_select",
      "type": "input",
      "source": "upstream",
      "summary": "Executes a `SELECT` query against BigQuery and creates a message for each row received.",
      "description": "Once the rows from the query are exhausted, this input shuts down, allowing the pipeline to gracefully terminate (or the next input in a xref:components:inputs/sequence.adoc[sequence] to execute).",
      "config": {
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to an array of values matching in size to the number of placeholder arguments in the field `where`.",
          "required": false,
          "default": null,
          "examples": [
            "root = [ \"article\", now().ts_format(\"2006-01-02\") ]"
          ]
        },
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "columns": {
          "name": "columns",
          "type": "string",
          "kind": "array",
          "description": "A list of columns to query.",
          "required": true,
          "default": null
        },
        "credentials_json": {
          "name": "credentials_json",
          "type": "string",
          "kind": "scalar",
          "description": "An optional field to set Google Service Account Credentials json.",
          "required": true,
          "default": ""
        },
        "job_labels": {
          "name": "job_labels",
          "type": "string",
          "kind": "map",
          "description": "A list of labels to add to the query job.",
          "required": true,
          "default": {}
        },
        "prefix": {
          "name": "prefix",
          "type": "string",
          "kind": "scalar",
          "description": "An optional prefix to prepend to the select query (before SELECT).",
          "required": false,
          "default": null
        },
        "priority": {
          "name": "priority",
          "type": "string",
          "kind": "scalar",
          "description": "The priority with which to schedule the query.",
          "required": true,
          "default": ""
        },
        "project": {
          "name": "project",
          "type": "string",
          "kind": "scalar",
          "description": "GCP project where the query job will execute.",
          "required": true,
          "default": null
        },
        "suffix": {
          "name": "suffix",
          "type": "string",
          "kind": "scalar",
          "description": "An optional suffix to append to the select query.",
          "required": false,
          "default": null
        },
        "table": {
          "name": "table",
          "type": "string",
          "kind": "scalar",
          "description": "Fully-qualified BigQuery table name to query.",
          "required": true,
          "default": null,
          "examples": [
            "bigquery-public-data.samples.shakespeare"
          ]
        },
        "where": {
          "name": "where",
          "type": "string",
          "kind": "scalar",
          "description": "An optional where clause to add. Placeholder arguments are populated with the `args_mapping` field. Placeholders should always be question marks (`?`).",
          "required": false,
          "default": null,
          "examples": [
            "type = ? and created_at \u003e ?",
            "user_id = ?"
          ]
        }
      }
    },
    "gcp_cloud_storage": {
      "name": "gcp_cloud_storage",
      "type": "input",
      "source": "upstream",
      "summary": "Downloads objects within a Google Cloud Storage bucket, optionally filtered by a prefix.",
      "description": "\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n```\n- gcs_key\n- gcs_bucket\n- gcs_last_modified\n- gcs_last_modified_unix\n- gcs_content_type\n- gcs_content_encoding\n- All user defined metadata\n```\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation].\n\n=== Credentials\n\nBy default Redpanda Connect will use a shared credentials file when connecting to GCP services. You can find out more in xref:guides:cloud/gcp.adoc[].",
      "config": {
        "bucket": {
          "name": "bucket",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the bucket from which to download objects.",
          "required": true,
          "default": null
        },
        "codec": {
          "name": "codec",
          "type": "string",
          "kind": "scalar",
          "description": "The way in which the bytes of a data source should be converted into discrete messages, codecs are useful for specifying how large files or continuous streams of data might be processed in small chunks rather than loading it all in memory. It's possible to consume lines using a custom delimiter with the `delim:x` codec, where x is the character sequence custom delimiter. Codecs can be chained with `/`, for example a gzip compressed CSV file can be consumed with the codec `gzip/csv`.",
          "required": false,
          "default": null,
          "examples": [
            "lines",
            "delim:\t",
            "delim:foobar",
            "gzip/csv"
          ]
        },
        "credentials_json": {
          "name": "credentials_json",
          "type": "string",
          "kind": "scalar",
          "description": "An optional field to set Google Service Account Credentials json.",
          "required": true,
          "default": ""
        },
        "delete_objects": {
          "name": "delete_objects",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to delete downloaded objects from the bucket once they are processed.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "max_buffer": {
          "name": "max_buffer",
          "type": "int",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": 1000000
        },
        "prefix": {
          "name": "prefix",
          "type": "string",
          "kind": "scalar",
          "description": "An optional path prefix, if set only objects with the prefix are consumed.",
          "required": true,
          "default": ""
        },
        "scanner": {
          "name": "scanner",
          "type": "scanner",
          "kind": "scalar",
          "description": "The xref:components:scanners/about.adoc[scanner] by which the stream of bytes consumed will be broken out into individual messages. Scanners are useful for processing large sources of data without holding the entirety of it within memory. For example, the `csv` scanner allows you to process individual CSV rows without loading the entire CSV file in memory at once.",
          "required": false,
          "default": {
            "to_the_end": {}
          }
        }
      }
    },
    "gcp_pubsub": {
      "name": "gcp_pubsub",
      "type": "input",
      "source": "upstream",
      "summary": "Consumes messages from a GCP Cloud Pub/Sub subscription.",
      "description": "\nFor information on how to set up credentials see https://cloud.google.com/docs/authentication/production[this guide^].\n\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n- gcp_pubsub_publish_time_unix - The time at which the message was published to the topic.\n- gcp_pubsub_delivery_attempt - When dead lettering is enabled, this is set to the number of times PubSub has attempted to deliver a message.\n- All message attributes\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation].\n",
      "config": {
        "create_subscription": {
          "name": "create_subscription",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to configure the input subscription and creates if it doesn't exist.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to configure subscription or not.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "topic",
              "type": "string",
              "kind": "scalar",
              "description": "Defines the topic that the subscription should be vinculated to.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "credentials_json": {
          "name": "credentials_json",
          "type": "string",
          "kind": "scalar",
          "description": "An optional field to set Google Service Account Credentials json.",
          "required": true,
          "default": ""
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "An optional endpoint to override the default of `pubsub.googleapis.com:443`. This can be used to connect to a region specific pubsub endpoint. For a list of valid values, see https://cloud.google.com/pubsub/docs/reference/service_apis_overview#list_of_regional_endpoints[this document^].",
          "required": true,
          "default": "",
          "examples": [
            "us-central1-pubsub.googleapis.com:443",
            "us-west3-pubsub.googleapis.com:443"
          ]
        },
        "max_outstanding_bytes": {
          "name": "max_outstanding_bytes",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of outstanding pending messages to be consumed measured in bytes.",
          "required": true,
          "default": 1000000000
        },
        "max_outstanding_messages": {
          "name": "max_outstanding_messages",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of outstanding pending messages to be consumed at a given time.",
          "required": true,
          "default": 1000
        },
        "project": {
          "name": "project",
          "type": "string",
          "kind": "scalar",
          "description": "The project ID of the target subscription.",
          "required": true,
          "default": null
        },
        "subscription": {
          "name": "subscription",
          "type": "string",
          "kind": "scalar",
          "description": "The target subscription ID.",
          "required": true,
          "default": null
        },
        "sync": {
          "name": "sync",
          "type": "bool",
          "kind": "scalar",
          "description": "Enable synchronous pull mode.",
          "required": true,
          "default": false
        }
      }
    },
    "generate": {
      "name": "generate",
      "type": "input",
      "source": "upstream",
      "summary": "Generates messages at a given interval using a xref:guides:bloblang/about.adoc[Bloblang] mapping executed without a context. This allows you to generate messages for testing your pipeline configs.",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "batch_size": {
          "name": "batch_size",
          "type": "int",
          "kind": "scalar",
          "description": "The number of generated messages that should be accumulated into each batch flushed at the specified interval.",
          "required": true,
          "default": 1
        },
        "count": {
          "name": "count",
          "type": "int",
          "kind": "scalar",
          "description": "An optional number of messages to generate, if set above 0 the specified number of messages is generated and then the input will shut down.",
          "required": true,
          "default": 0
        },
        "interval": {
          "name": "interval",
          "type": "string",
          "kind": "scalar",
          "description": "The time interval at which messages should be generated, expressed either as a duration string or as a cron expression. If set to an empty string messages will be generated as fast as downstream services can process them. Cron expressions can specify a timezone by prefixing the expression with `TZ=\u003clocation name\u003e`, where the location name corresponds to a file within the IANA Time Zone database.",
          "required": true,
          "default": "1s",
          "examples": [
            "5s",
            "1m",
            "1h",
            "@every 1s",
            "0,30 */2 * * * *",
            "TZ=Europe/London 30 3-6,20-23 * * *"
          ]
        },
        "mapping": {
          "name": "mapping",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang] mapping to use for generating messages.",
          "required": true,
          "default": null,
          "examples": [
            "root = \"hello world\"",
            "root = {\"test\":\"message\",\"id\":uuid_v4()}"
          ]
        }
      }
    },
    "hdfs": {
      "name": "hdfs",
      "type": "input",
      "source": "upstream",
      "summary": "Reads files from a HDFS directory, where each discrete file will be consumed as a single message payload.",
      "description": "\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n- hdfs_name\n- hdfs_path\n\nYou can access these metadata fields using\nxref:configuration:interpolation.adoc#bloblang-queries[function interpolation].",
      "config": {
        "directory": {
          "name": "directory",
          "type": "string",
          "kind": "scalar",
          "description": "The directory to consume from.",
          "required": true,
          "default": null
        },
        "hosts": {
          "name": "hosts",
          "type": "string",
          "kind": "array",
          "description": "A list of target host addresses to connect to.",
          "required": true,
          "default": null,
          "examples": [
            "localhost:9000"
          ]
        },
        "user": {
          "name": "user",
          "type": "string",
          "kind": "scalar",
          "description": "A user ID to connect as.",
          "required": true,
          "default": ""
        }
      }
    },
    "http_client": {
      "name": "http_client",
      "type": "input",
      "source": "upstream",
      "summary": "Connects to a server and continuously performs requests for a single message.",
      "description": "\nThe URL and header values of this type can be dynamically set using function interpolations described xref:configuration:interpolation.adoc#bloblang-queries[here].\n\n== Streaming\n\nIf you enable streaming then Redpanda Connect will consume the body of the response as a continuous stream of data, breaking messages out following a chosen scanner. This allows you to consume APIs that provide long lived streamed data feeds (such as Twitter).\n\n== Pagination\n\nThis input supports interpolation functions in the `url` and `headers` fields where data from the previous successfully consumed message (if there was one) can be referenced. This can be used in order to support basic levels of pagination. However, in cases where pagination depends on logic it is recommended that you use an xref:components:processors/http.adoc[`http` processor] instead, often combined with a xref:components:inputs/generate.adoc[`generate` input] in order to schedule the processor.",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "backoff_on": {
          "name": "backoff_on",
          "type": "int",
          "kind": "array",
          "description": "A list of status codes whereby the request should be considered to have failed and retries should be attempted, but the period between them should be increased gradually.",
          "required": true,
          "default": [
            429
          ],
          "advanced": true
        },
        "basic_auth": {
          "name": "basic_auth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify basic authentication.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use basic authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "A username to authenticate as.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A password to authenticate with.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "disable_http2": {
          "name": "disable_http2",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether or not to disable disable HTTP/2",
          "required": true,
          "default": false,
          "advanced": true
        },
        "drop_empty_bodies": {
          "name": "drop_empty_bodies",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether empty payloads received from the target server should be dropped.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "drop_on": {
          "name": "drop_on",
          "type": "int",
          "kind": "array",
          "description": "A list of status codes whereby the request should be considered to have failed but retries should not be attempted. This is useful for preventing wasted retries for requests that will never succeed. Note that with these status codes the _request_ is dropped, but _message_ that caused the request will not be dropped.",
          "required": true,
          "default": [],
          "advanced": true
        },
        "dump_request_log_level": {
          "name": "dump_request_log_level",
          "type": "string",
          "kind": "scalar",
          "description": "EXPERIMENTAL: Optionally set a level at which the request and response payload of each request made will be logged.",
          "required": true,
          "default": "",
          "options": [
            "TRACE",
            "DEBUG",
            "INFO",
            "WARN",
            "ERROR",
            "FATAL",
            ""
          ],
          "advanced": true
        },
        "extract_headers": {
          "name": "extract_headers",
          "type": "object",
          "kind": "scalar",
          "description": "Specify which response headers should be added to resulting messages as metadata. Header keys are lowercased before matching, so ensure that your patterns target lowercased versions of the header keys that you expect.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "include_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  "foo_",
                  "bar_"
                ],
                [
                  "kafka_"
                ],
                [
                  "content-"
                ]
              ],
              "advanced": true
            },
            {
              "name": "include_patterns",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key regular expression (re2) patterns to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  ".*"
                ],
                [
                  "_timestamp_unix$"
                ]
              ],
              "advanced": true
            }
          ]
        },
        "follow_redirects": {
          "name": "follow_redirects",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether or not to transparently follow redirects, i.e. responses with 300-399 status codes. If disabled, the response message will contain the body, status, and headers from the redirect response and the processor will not make a request to the URL set in the Location header of the response.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "headers": {
          "name": "headers",
          "type": "string",
          "kind": "map",
          "description": "A map of headers to add to the request.",
          "required": true,
          "default": {},
          "examples": [
            {
              "Content-Type": "application/octet-stream",
              "traceparent": "${! tracing_span().traceparent }"
            }
          ]
        },
        "jwt": {
          "name": "jwt",
          "type": "object",
          "kind": "scalar",
          "description": "BETA: Allows you to specify JWT authentication.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use JWT authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "private_key_file",
              "type": "string",
              "kind": "scalar",
              "description": "A file with the PEM encoded via PKCS1 or PKCS8 as private key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "signing_method",
              "type": "string",
              "kind": "scalar",
              "description": "A method used to sign the token such as RS256, RS384, RS512 or EdDSA.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "claims",
              "type": "unknown",
              "kind": "map",
              "description": "A value used to identify the claims that issued the JWT.",
              "required": true,
              "default": {},
              "advanced": true
            },
            {
              "name": "headers",
              "type": "unknown",
              "kind": "map",
              "description": "Add optional key/value headers to the JWT.",
              "required": true,
              "default": {},
              "advanced": true
            }
          ]
        },
        "max_retry_backoff": {
          "name": "max_retry_backoff",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum period to wait between failed requests.",
          "required": true,
          "default": "300s",
          "advanced": true
        },
        "metadata": {
          "name": "metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Specify optional matching rules to determine which metadata keys should be added to the HTTP request as headers.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "include_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  "foo_",
                  "bar_"
                ],
                [
                  "kafka_"
                ],
                [
                  "content-"
                ]
              ],
              "advanced": true
            },
            {
              "name": "include_patterns",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key regular expression (re2) patterns to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  ".*"
                ],
                [
                  "_timestamp_unix$"
                ]
              ],
              "advanced": true
            }
          ]
        },
        "oauth": {
          "name": "oauth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify open authentication via OAuth version 1.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use OAuth version 1 in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "consumer_key",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to identify the client to the service provider.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "consumer_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret used to establish ownership of the consumer key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "access_token",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to gain access to the protected resources on behalf of the user.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "access_token_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret provided in order to establish ownership of a given access token.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "oauth2": {
          "name": "oauth2",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify open authentication via OAuth version 2 using the client credentials token flow.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use OAuth version 2 in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "client_key",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to identify the client to the token provider.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "client_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret used to establish ownership of the client key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token_url",
              "type": "string",
              "kind": "scalar",
              "description": "The URL of the token provider.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "scopes",
              "type": "string",
              "kind": "array",
              "description": "A list of optional requested permissions.",
              "required": true,
              "default": [],
              "advanced": true
            },
            {
              "name": "endpoint_params",
              "type": "unknown",
              "kind": "map",
              "description": "A list of optional endpoint parameters, values should be arrays of strings.",
              "required": false,
              "default": {},
              "examples": [
                {
                  "bar": [
                    "woof"
                  ],
                  "foo": [
                    "meow",
                    "quack"
                  ]
                }
              ],
              "advanced": true
            }
          ]
        },
        "payload": {
          "name": "payload",
          "type": "string",
          "kind": "scalar",
          "description": "An optional payload to deliver for each request.",
          "required": false,
          "default": null
        },
        "proxy_url": {
          "name": "proxy_url",
          "type": "string",
          "kind": "scalar",
          "description": "An optional HTTP proxy URL.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "rate_limit": {
          "name": "rate_limit",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:components:rate_limits/about.adoc[rate limit] to throttle requests by.",
          "required": false,
          "default": null
        },
        "retries": {
          "name": "retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retry attempts to make.",
          "required": true,
          "default": 3,
          "advanced": true
        },
        "retry_period": {
          "name": "retry_period",
          "type": "string",
          "kind": "scalar",
          "description": "The base period to wait between failed requests.",
          "required": true,
          "default": "1s",
          "advanced": true
        },
        "stream": {
          "name": "stream",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to set streaming mode, where requests are kept open and messages are processed line-by-line.",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Enables streaming mode.",
              "required": true,
              "default": false
            },
            {
              "name": "reconnect",
              "type": "bool",
              "kind": "scalar",
              "description": "Sets whether to re-establish the connection once it is lost.",
              "required": true,
              "default": true
            },
            {
              "name": "codec",
              "type": "string",
              "kind": "scalar",
              "description": "The way in which the bytes of a data source should be converted into discrete messages, codecs are useful for specifying how large files or continuous streams of data might be processed in small chunks rather than loading it all in memory. It's possible to consume lines using a custom delimiter with the `delim:x` codec, where x is the character sequence custom delimiter. Codecs can be chained with `/`, for example a gzip compressed CSV file can be consumed with the codec `gzip/csv`.",
              "required": false,
              "default": null,
              "examples": [
                "lines",
                "delim:\t",
                "delim:foobar",
                "gzip/csv"
              ]
            },
            {
              "name": "max_buffer",
              "type": "int",
              "kind": "scalar",
              "description": "",
              "required": true,
              "default": 1000000
            },
            {
              "name": "scanner",
              "type": "scanner",
              "kind": "scalar",
              "description": "The xref:components:scanners/about.adoc[scanner] by which the stream of bytes consumed will be broken out into individual messages. Scanners are useful for processing large sources of data without holding the entirety of it within memory. For example, the `csv` scanner allows you to process individual CSV rows without loading the entire CSV file in memory at once.",
              "required": false,
              "default": {
                "lines": {}
              }
            }
          ]
        },
        "successful_on": {
          "name": "successful_on",
          "type": "int",
          "kind": "array",
          "description": "A list of status codes whereby the attempt should be considered successful, this is useful for dropping requests that return non-2XX codes indicating that the message has been dealt with, such as a 303 See Other or a 409 Conflict. All 2XX codes are considered successful unless they are present within `backoff_on` or `drop_on`, regardless of this field.",
          "required": true,
          "default": [],
          "advanced": true
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "A static timeout to apply to requests.",
          "required": true,
          "default": "5s"
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL to connect to.",
          "required": true,
          "default": null
        },
        "verb": {
          "name": "verb",
          "type": "string",
          "kind": "scalar",
          "description": "A verb to connect with",
          "required": true,
          "default": "GET",
          "examples": [
            "POST",
            "GET",
            "DELETE"
          ]
        }
      }
    },
    "http_server": {
      "name": "http_server",
      "type": "input",
      "source": "upstream",
      "summary": "Receive messages POSTed over HTTP(S). HTTP 2.0 is supported when using TLS, which is enabled when key and cert files are specified.",
      "description": "\nIf the `address` config field is left blank the xref:components:http/about.adoc[service-wide HTTP server] will be used.\n\nThe field `rate_limit` allows you to specify an optional xref:components:rate_limits/about.adoc[`rate_limit` resource], which will be applied to each HTTP request made and each websocket payload received.\n\nWhen the rate limit is breached HTTP requests will have a 429 response returned with a Retry-After header. Websocket payloads will be dropped and an optional response payload will be sent as per `ws_rate_limit_message`.\n\n== Responses\n\nIt's possible to return a response for each message received using xref:guides:sync_responses.adoc[synchronous responses]. When doing so you can customize headers with the `sync_response` field `headers`, which can also use xref:configuration:interpolation.adoc#bloblang-queries[function interpolation] in the value based on the response message contents.\n\n== Endpoints\n\nThe following fields specify endpoints that are registered for sending messages, and support path parameters of the form `/\\{foo}`, which are added to ingested messages as metadata. A path ending in `/` will match against all extensions of that path:\n\n=== `path` (defaults to `/post`)\n\nThis endpoint expects POST requests where the entire request body is consumed as a single message.\n\nIf the request contains a multipart `content-type` header as per https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html[RFC1341^] then the multiple parts are consumed as a batch of messages, where each body part is a message of the batch.\n\n=== `ws_path` (defaults to `/post/ws`)\n\nCreates a websocket connection, where payloads received on the socket are passed through the pipeline as a batch of one message.\n\n\n[CAUTION]\n.Endpoint caveats\n====\nComponents within a Redpanda Connect config will register their respective endpoints in a non-deterministic order. This means that establishing precedence of endpoints that are registered via multiple `http_server` inputs or outputs (either within brokers or from cohabiting streams) is not possible in a predictable way.\n\nThis ambiguity makes it difficult to ensure that paths which are both a subset of a path registered by a separate component, and end in a slash (`/`) and will therefore match against all extensions of that path, do not prevent the more specific path from matching against requests.\n\nIt is therefore recommended that you ensure paths of separate components do not collide unless they are explicitly non-competing.\n\nFor example, if you were to deploy two separate `http_server` inputs, one with a path `/foo/` and the other with a path `/foo/bar`, it would not be possible to ensure that the path `/foo/` does not swallow requests made to `/foo/bar`.\n====\n\nYou may specify an optional `ws_welcome_message`, which is a static payload to be sent to all clients once a websocket connection is first established.\n\nIt's also possible to specify a `ws_rate_limit_message`, which is a static payload to be sent to clients that have triggered the servers rate limit.\n\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n```text\n- http_server_user_agent\n- http_server_request_path\n- http_server_verb\n- http_server_remote_ip\n- All headers (only first values are taken)\n- All query parameters\n- All path parameters\n- All cookies\n```\n\nIf HTTPS is enabled, the following fields are added as well:\n```text\n- http_server_tls_version\n- http_server_tls_subject\n- http_server_tls_cipher_suite\n```\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation].",
      "config": {
        "address": {
          "name": "address",
          "type": "string",
          "kind": "scalar",
          "description": "An alternative address to host from. If left empty the service wide address is used.",
          "required": true,
          "default": ""
        },
        "allowed_verbs": {
          "name": "allowed_verbs",
          "type": "string",
          "kind": "array",
          "description": "An array of verbs that are allowed for the `path` endpoint.",
          "required": true,
          "default": [
            "POST"
          ]
        },
        "cert_file": {
          "name": "cert_file",
          "type": "string",
          "kind": "scalar",
          "description": "Enable TLS by specifying a certificate and key file. Only valid with a custom `address`.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "cors": {
          "name": "cors",
          "type": "object",
          "kind": "scalar",
          "description": "Adds Cross-Origin Resource Sharing headers. Only valid with a custom `address`.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow CORS requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "allowed_origins",
              "type": "string",
              "kind": "array",
              "description": "An explicit list of origins that are allowed for CORS requests.",
              "required": true,
              "default": [],
              "advanced": true
            }
          ]
        },
        "key_file": {
          "name": "key_file",
          "type": "string",
          "kind": "scalar",
          "description": "Enable TLS by specifying a certificate and key file. Only valid with a custom `address`.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "path": {
          "name": "path",
          "type": "string",
          "kind": "scalar",
          "description": "The endpoint path to listen for POST requests.",
          "required": true,
          "default": "/post"
        },
        "rate_limit": {
          "name": "rate_limit",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:components:rate_limits/about.adoc[rate limit] to throttle requests by.",
          "required": true,
          "default": ""
        },
        "sync_response": {
          "name": "sync_response",
          "type": "object",
          "kind": "scalar",
          "description": "Customize messages returned via xref:guides:sync_responses.adoc[synchronous responses].",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "status",
              "type": "string",
              "kind": "scalar",
              "description": "Specify the status code to return with synchronous responses. This is a string value, which allows you to customize it based on resulting payloads and their metadata.",
              "required": true,
              "default": "200",
              "examples": [
                "${! json(\"status\") }",
                "${! meta(\"status\") }"
              ],
              "advanced": true
            },
            {
              "name": "headers",
              "type": "string",
              "kind": "map",
              "description": "Specify headers to return with synchronous responses.",
              "required": true,
              "default": {
                "Content-Type": "application/octet-stream"
              },
              "advanced": true
            },
            {
              "name": "metadata_headers",
              "type": "object",
              "kind": "scalar",
              "description": "Specify criteria for which metadata values are added to the response as headers.",
              "required": true,
              "default": null,
              "advanced": true,
              "children": [
                {
                  "name": "include_prefixes",
                  "type": "string",
                  "kind": "array",
                  "description": "Provide a list of explicit metadata key prefixes to match against.",
                  "required": true,
                  "default": [],
                  "examples": [
                    [
                      "foo_",
                      "bar_"
                    ],
                    [
                      "kafka_"
                    ],
                    [
                      "content-"
                    ]
                  ],
                  "advanced": true
                },
                {
                  "name": "include_patterns",
                  "type": "string",
                  "kind": "array",
                  "description": "Provide a list of explicit metadata key regular expression (re2) patterns to match against.",
                  "required": true,
                  "default": [],
                  "examples": [
                    [
                      ".*"
                    ],
                    [
                      "_timestamp_unix$"
                    ]
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "Timeout for requests. If a consumed messages takes longer than this to be delivered the connection is closed, but the message may still be delivered.",
          "required": true,
          "default": "5s"
        },
        "ws_path": {
          "name": "ws_path",
          "type": "string",
          "kind": "scalar",
          "description": "The endpoint path to create websocket connections from.",
          "required": true,
          "default": "/post/ws"
        },
        "ws_rate_limit_message": {
          "name": "ws_rate_limit_message",
          "type": "string",
          "kind": "scalar",
          "description": "An optional message to delivery to websocket connections that are rate limited.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "ws_welcome_message": {
          "name": "ws_welcome_message",
          "type": "string",
          "kind": "scalar",
          "description": "An optional message to deliver to fresh websocket connections.",
          "required": true,
          "default": "",
          "advanced": true
        }
      }
    },
    "inproc": {
      "name": "inproc",
      "type": "input",
      "source": "upstream",
      "summary": "",
      "description": "\nDirectly connect to an output within a Redpanda Connect process by referencing it by a chosen ID. This allows you to hook up isolated streams whilst running Redpanda Connect in xref:guides:streams_mode/about.adoc[streams mode], it is NOT recommended that you connect the inputs of a stream with an output of the same stream, as feedback loops can lead to deadlocks in your message flow.\n\nIt is possible to connect multiple inputs to the same inproc ID, resulting in messages dispatching in a round-robin fashion to connected inputs. However, only one output can assume an inproc ID, and will replace existing outputs if a collision occurs.",
      "config": {}
    },
    "kafka": {
      "name": "kafka",
      "type": "input",
      "source": "upstream",
      "summary": "Connects to Kafka brokers and consumes one or more topics.",
      "description": "\nOffsets are managed within Kafka under the specified consumer group, and partitions for each topic are automatically balanced across members of the consumer group.\n\nThe Kafka input allows parallel processing of messages from different topic partitions, and messages of the same topic partition are processed with a maximum parallelism determined by the field \u003c\u003ccheckpoint_limit,`checkpoint_limit`\u003e\u003e.\n\nIn order to enforce ordered processing of partition messages set the \u003ccheckpoint_limit,`checkpoint_limit`\u003e\u003e to `1` and this will force partitions to be processed in lock-step, where a message will only be processed once the prior message is delivered.\n\nBatching messages before processing can be enabled using the \u003c\u003cbatching,`batching`\u003e\u003e field, and this batching is performed per-partition such that messages of a batch will always originate from the same partition. This batching mechanism is capable of creating batches of greater size than the \u003c\u003ccheckpoint_limit,`checkpoint_limit`\u003e\u003e, in which case the next batch will only be created upon delivery of the current one.\n\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n- kafka_key\n- kafka_topic\n- kafka_partition\n- kafka_offset\n- kafka_lag\n- kafka_timestamp_ms\n- kafka_timestamp_unix\n- kafka_tombstone_message\n- All existing message headers (version 0.11+)\n\nThe field `kafka_lag` is the calculated difference between the high water mark offset of the partition at the time of ingestion and the current message offset.\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation].\n\n== Ordering\n\nBy default messages of a topic partition can be processed in parallel, up to a limit determined by the field `checkpoint_limit`. However, if strict ordered processing is required then this value must be set to 1 in order to process shard messages in lock-step. When doing so it is recommended that you perform batching at this component for performance as it will not be possible to batch lock-stepped messages at the output level.\n\n== Troubleshooting\n\nIf you're seeing issues writing to or reading from Kafka with this component then it's worth trying out the newer xref:components:inputs/kafka_franz.adoc[`kafka_franz` input].\n\n- I'm seeing logs that report `Failed to connect to kafka: kafka: client has run out of available brokers to talk to (Is your cluster reachable?)`, but the brokers are definitely reachable.\n\nUnfortunately this error message will appear for a wide range of connection problems even when the broker endpoint can be reached. Double check your authentication configuration and also ensure that you have \u003c\u003ctlsenabled, enabled TLS\u003e\u003e if applicable.",
      "config": {
        "addresses": {
          "name": "addresses",
          "type": "string",
          "kind": "array",
          "description": "A list of broker addresses to connect to. If an item of the list contains commas it will be expanded into multiple addresses.",
          "required": true,
          "default": null,
          "examples": [
            [
              "localhost:9092"
            ],
            [
              "localhost:9041,localhost:9042"
            ],
            [
              "localhost:9041",
              "localhost:9042"
            ]
          ]
        },
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "advanced": true,
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0,
              "advanced": true
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0,
              "advanced": true
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ],
              "advanced": true
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ],
              "advanced": true
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "checkpoint_limit": {
          "name": "checkpoint_limit",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages of the same topic and partition that can be processed at a given time. Increasing this limit enables parallel processing and batching at the output level to work on individual partitions. Any given offset will not be committed unless all messages under that offset are delivered in order to preserve at least once delivery guarantees.",
          "required": true,
          "default": 1024
        },
        "client_id": {
          "name": "client_id",
          "type": "string",
          "kind": "scalar",
          "description": "An identifier for the client connection.",
          "required": true,
          "default": "benthos",
          "advanced": true
        },
        "commit_period": {
          "name": "commit_period",
          "type": "string",
          "kind": "scalar",
          "description": "The period of time between each commit of the current partition offsets. Offsets are always committed during shutdown.",
          "required": true,
          "default": "1s",
          "advanced": true
        },
        "consumer_group": {
          "name": "consumer_group",
          "type": "string",
          "kind": "scalar",
          "description": "An identifier for the consumer group of the connection. This field can be explicitly made empty in order to disable stored offsets for the consumed topic partitions.",
          "required": true,
          "default": ""
        },
        "extract_tracing_map": {
          "name": "extract_tracing_map",
          "type": "string",
          "kind": "scalar",
          "description": "EXPERIMENTAL: A xref:guides:bloblang/about.adoc[Bloblang mapping] that attempts to extract an object containing tracing propagation information, which will then be used as the root tracing span for the message. The specification of the extracted fields must match the format used by the service wide tracer.",
          "required": false,
          "default": null,
          "examples": [
            "root = @",
            "root = this.meta.span"
          ],
          "advanced": true
        },
        "fetch_buffer_cap": {
          "name": "fetch_buffer_cap",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of unprocessed messages to fetch at a given time.",
          "required": true,
          "default": 256,
          "advanced": true
        },
        "group": {
          "name": "group",
          "type": "object",
          "kind": "scalar",
          "description": "Tuning parameters for consumer group synchronization.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "session_timeout",
              "type": "string",
              "kind": "scalar",
              "description": "A period after which a consumer of the group is kicked after no heartbeats.",
              "required": true,
              "default": "10s",
              "advanced": true
            },
            {
              "name": "heartbeat_interval",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which heartbeats should be sent out.",
              "required": true,
              "default": "3s",
              "advanced": true
            },
            {
              "name": "rebalance_timeout",
              "type": "string",
              "kind": "scalar",
              "description": "A period after which rebalancing is abandoned if unresolved.",
              "required": true,
              "default": "60s",
              "advanced": true
            }
          ]
        },
        "instance_id": {
          "name": "instance_id",
          "type": "string",
          "kind": "scalar",
          "description": "When using consumer groups, an identifier for this specific input so that it can be identified over restarts of this process. This should be unique per input.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "max_processing_period": {
          "name": "max_processing_period",
          "type": "string",
          "kind": "scalar",
          "description": "A maximum estimate for the time taken to process a message, this is used for tuning consumer group synchronization.",
          "required": true,
          "default": "100ms",
          "advanced": true
        },
        "multi_header": {
          "name": "multi_header",
          "type": "bool",
          "kind": "scalar",
          "description": "Decode headers into lists to allow handling of multiple values with the same key",
          "required": true,
          "default": false,
          "advanced": true
        },
        "rack_id": {
          "name": "rack_id",
          "type": "string",
          "kind": "scalar",
          "description": "A rack identifier for this client.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "sasl": {
          "name": "sasl",
          "type": "object",
          "kind": "scalar",
          "description": "Enables SASL authentication.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "mechanism",
              "type": "string",
              "kind": "scalar",
              "description": "The SASL authentication mechanism, if left empty SASL authentication is not used.",
              "required": true,
              "default": "none",
              "advanced": true
            },
            {
              "name": "user",
              "type": "string",
              "kind": "scalar",
              "description": "A PLAIN username. It is recommended that you use environment variables to populate this field.",
              "required": true,
              "default": "",
              "examples": [
                "${USER}"
              ],
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A PLAIN password. It is recommended that you use environment variables to populate this field.",
              "required": true,
              "default": "",
              "examples": [
                "${PASSWORD}"
              ],
              "advanced": true
            },
            {
              "name": "access_token",
              "type": "string",
              "kind": "scalar",
              "description": "A static OAUTHBEARER access token",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token_cache",
              "type": "string",
              "kind": "scalar",
              "description": "Instead of using a static `access_token` allows you to query a xref:components:caches/about.adoc[`cache`] resource to fetch OAUTHBEARER tokens from",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token_key",
              "type": "string",
              "kind": "scalar",
              "description": "Required when using a `token_cache`, the key to query the cache with for tokens.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "start_from_oldest": {
          "name": "start_from_oldest",
          "type": "bool",
          "kind": "scalar",
          "description": "Determines whether to consume from the oldest available offset, otherwise messages are consumed from the latest offset. The setting is applied when creating a new consumer group or the saved offset no longer exists.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "target_version": {
          "name": "target_version",
          "type": "string",
          "kind": "scalar",
          "description": "The version of the Kafka protocol to use. This limits the capabilities used by the client and should ideally match the version of your brokers. Defaults to the oldest supported stable version.",
          "required": false,
          "default": null,
          "examples": [
            "2.1.0",
            "3.1.0"
          ]
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "topics": {
          "name": "topics",
          "type": "string",
          "kind": "array",
          "description": "A list of topics to consume from. Multiple comma separated topics can be listed in a single element. Partitions are automatically distributed across consumers of a topic. Alternatively, it's possible to specify explicit partitions to consume from with a colon after the topic name, e.g. `foo:0` would consume the partition 0 of the topic foo. This syntax supports ranges, e.g. `foo:0-10` would consume partitions 0 through to 10 inclusive.",
          "required": true,
          "default": null,
          "examples": [
            [
              "foo",
              "bar"
            ],
            [
              "foo,bar"
            ],
            [
              "foo:0",
              "bar:1",
              "bar:3"
            ],
            [
              "foo:0,bar:1,bar:3"
            ],
            [
              "foo:0-5"
            ]
          ]
        }
      }
    },
    "kafka_franz": {
      "name": "kafka_franz",
      "type": "input",
      "source": "upstream",
      "summary": "A Kafka input using the https://github.com/twmb/franz-go[Franz Kafka client library^].",
      "description": "\nWhen a consumer group is specified this input consumes one or more topics where partitions will automatically balance across any other connected clients with the same consumer group. When a consumer group is not specified topics can either be consumed in their entirety or with explicit partitions.\n\nThis input often out-performs the traditional `kafka` input as well as providing more useful logs and error messages.\n\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n```text\n- kafka_key\n- kafka_topic\n- kafka_partition\n- kafka_offset\n- kafka_timestamp_ms\n- kafka_timestamp_unix\n- kafka_tombstone_message\n- All record headers\n```\n",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "Allows you to configure a xref:configuration:batching.adoc[batching policy] that applies to individual topic partitions in order to batch messages together before flushing them for processing. Batching can be beneficial for performance as well as useful for windowed processing, and doing so this way preserves the ordering of topic partitions.",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "advanced": true,
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0,
              "advanced": true
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0,
              "advanced": true
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ],
              "advanced": true
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ],
              "advanced": true
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "checkpoint_limit": {
          "name": "checkpoint_limit",
          "type": "int",
          "kind": "scalar",
          "description": "Determines how many messages of the same partition can be processed in parallel before applying back pressure. When a message of a given offset is delivered to the output the offset is only allowed to be committed when all messages of prior offsets have also been delivered, this ensures at-least-once delivery guarantees. However, this mechanism also increases the likelihood of duplicates in the event of crashes or server faults, reducing the checkpoint limit will mitigate this.",
          "required": true,
          "default": 1024,
          "advanced": true
        },
        "client_id": {
          "name": "client_id",
          "type": "string",
          "kind": "scalar",
          "description": "An identifier for the client connection.",
          "required": true,
          "default": "benthos",
          "advanced": true
        },
        "commit_period": {
          "name": "commit_period",
          "type": "string",
          "kind": "scalar",
          "description": "The period of time between each commit of the current partition offsets. Offsets are always committed during shutdown.",
          "required": true,
          "default": "5s",
          "advanced": true
        },
        "consumer_group": {
          "name": "consumer_group",
          "type": "string",
          "kind": "scalar",
          "description": "An optional consumer group to consume as. When specified the partitions of specified topics are automatically distributed across consumers sharing a consumer group, and partition offsets are automatically committed and resumed under this name. Consumer groups are not supported when specifying explicit partitions to consume from in the `topics` field.",
          "required": false,
          "default": null
        },
        "fetch_max_bytes": {
          "name": "fetch_max_bytes",
          "type": "string",
          "kind": "scalar",
          "description": "Sets the maximum amount of bytes a broker will try to send during a fetch. Note that brokers may not obey this limit if it has records larger than this limit. This is the equivalent to the Java fetch.max.bytes setting.",
          "required": true,
          "default": "50MiB",
          "advanced": true
        },
        "fetch_max_partition_bytes": {
          "name": "fetch_max_partition_bytes",
          "type": "string",
          "kind": "scalar",
          "description": "Sets the maximum amount of bytes that will be consumed for a single partition in a fetch request. Note that if a single batch is larger than this number, that batch will still be returned so the client can make progress. This is the equivalent to the Java fetch.max.partition.bytes setting.",
          "required": true,
          "default": "1MiB",
          "advanced": true
        },
        "fetch_max_wait": {
          "name": "fetch_max_wait",
          "type": "string",
          "kind": "scalar",
          "description": "Sets the maximum amount of time a broker will wait for a fetch response to hit the minimum number of required bytes. This is the equivalent to the Java fetch.max.wait.ms setting.",
          "required": true,
          "default": "5s",
          "advanced": true
        },
        "fetch_min_bytes": {
          "name": "fetch_min_bytes",
          "type": "string",
          "kind": "scalar",
          "description": "Sets the minimum amount of bytes a broker will try to send during a fetch. This is the equivalent to the Java fetch.min.bytes setting.",
          "required": true,
          "default": "1B",
          "advanced": true
        },
        "heartbeat_interval": {
          "name": "heartbeat_interval",
          "type": "string",
          "kind": "scalar",
          "description": "When using a consumer group, `heartbeat_interval` sets how long a group member goes between heartbeats to Kafka. Kafka uses heartbeats to ensure that a group member's sesion stays active. This value should be no higher than 1/3rd of the `session_timeout`. This is equivalent to the Java heartbeat.interval.ms setting.",
          "required": true,
          "default": "3s",
          "advanced": true
        },
        "instance_id": {
          "name": "instance_id",
          "type": "string",
          "kind": "scalar",
          "description": "When using a consumer group, an instance ID specifies the groups static membership, which can prevent rebalances during reconnects. When using a instance ID the client does NOT leave the group when closing. To actually leave the group one must use an external admin command to leave the group on behalf of this instance ID. This ID must be unique per consumer within the group.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "metadata_max_age": {
          "name": "metadata_max_age",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum age of metadata before it is refreshed.",
          "required": true,
          "default": "5m",
          "advanced": true
        },
        "multi_header": {
          "name": "multi_header",
          "type": "bool",
          "kind": "scalar",
          "description": "Decode headers into lists to allow handling of multiple values with the same key",
          "required": true,
          "default": false,
          "advanced": true
        },
        "rack_id": {
          "name": "rack_id",
          "type": "string",
          "kind": "scalar",
          "description": "A rack specifies where the client is physically located and changes fetch requests to consume from the closest replica as opposed to the leader replica.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "rebalance_timeout": {
          "name": "rebalance_timeout",
          "type": "string",
          "kind": "scalar",
          "description": "When using a consumer group, `rebalance_timeout` sets how long group members are allowed to take when a rebalance has begun. This timeout is how long all members are allowed to complete work and commit offsets, minus the time it took to detect the rebalance (from a heartbeat).",
          "required": true,
          "default": "45s",
          "advanced": true
        },
        "regexp_topics": {
          "name": "regexp_topics",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether listed topics should be interpreted as regular expression patterns for matching multiple topics. When topics are specified with explicit partitions this field must remain set to `false`.",
          "required": true,
          "default": false
        },
        "sasl": {
          "name": "sasl",
          "type": "object",
          "kind": "array",
          "description": "Specify one or more methods of SASL authentication. SASL is tried in order; if the broker supports the first mechanism, all connections will use that mechanism. If the first mechanism fails, the client will pick the first supported mechanism. If the broker does not support any client mechanisms, connections will fail.",
          "required": false,
          "default": null,
          "examples": [
            [
              {
                "mechanism": "SCRAM-SHA-512",
                "password": "bar",
                "username": "foo"
              }
            ]
          ],
          "advanced": true,
          "children": [
            {
              "name": "mechanism",
              "type": "string",
              "kind": "scalar",
              "description": "The SASL mechanism to use.",
              "required": true,
              "default": null,
              "advanced": true
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "A username to provide for PLAIN or SCRAM-* authentication.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A password to provide for PLAIN or SCRAM-* authentication.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token",
              "type": "string",
              "kind": "scalar",
              "description": "The token to use for a single session's OAUTHBEARER authentication.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "extensions",
              "type": "string",
              "kind": "map",
              "description": "Key/value pairs to add to OAUTHBEARER authentication requests.",
              "required": false,
              "default": null,
              "advanced": true
            },
            {
              "name": "aws",
              "type": "object",
              "kind": "scalar",
              "description": "Contains AWS specific fields for when the `mechanism` is set to `AWS_MSK_IAM`.",
              "required": false,
              "default": null,
              "advanced": true,
              "children": [
                {
                  "name": "region",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The AWS region to target.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "endpoint",
                  "type": "string",
                  "kind": "scalar",
                  "description": "Allows you to specify a custom endpoint for the AWS API.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "credentials",
                  "type": "object",
                  "kind": "scalar",
                  "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
                  "required": true,
                  "default": null,
                  "advanced": true,
                  "children": [
                    {
                      "name": "profile",
                      "type": "string",
                      "kind": "scalar",
                      "description": "A profile from `~/.aws/credentials` to use.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "id",
                      "type": "string",
                      "kind": "scalar",
                      "description": "The ID of credentials to use.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "secret",
                      "type": "string",
                      "kind": "scalar",
                      "description": "The secret for the credentials being used.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "token",
                      "type": "string",
                      "kind": "scalar",
                      "description": "The token for the credentials being used, required when using short term credentials.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "from_ec2_role",
                      "type": "bool",
                      "kind": "scalar",
                      "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
                      "required": true,
                      "default": false,
                      "advanced": true
                    },
                    {
                      "name": "role",
                      "type": "string",
                      "kind": "scalar",
                      "description": "A role ARN to assume.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "role_external_id",
                      "type": "string",
                      "kind": "scalar",
                      "description": "An external ID to provide when assuming a role.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        "seed_brokers": {
          "name": "seed_brokers",
          "type": "string",
          "kind": "array",
          "description": "A list of broker addresses to connect to in order to establish connections. If an item of the list contains commas it will be expanded into multiple addresses.",
          "required": true,
          "default": null,
          "examples": [
            [
              "localhost:9092"
            ],
            [
              "foo:9092",
              "bar:9092"
            ],
            [
              "foo:9092,bar:9092"
            ]
          ]
        },
        "session_timeout": {
          "name": "session_timeout",
          "type": "string",
          "kind": "scalar",
          "description": "When using a consumer group, `session_timeout` sets how long a member in hte group can go between heartbeats. If a member does not heartbeat in this timeout, the broker will remove the member from the group and initiate a rebalance.",
          "required": true,
          "default": "1m",
          "advanced": true
        },
        "start_from_oldest": {
          "name": "start_from_oldest",
          "type": "bool",
          "kind": "scalar",
          "description": "Determines whether to consume from the oldest available offset, otherwise messages are consumed from the latest offset. The setting is applied when creating a new consumer group or the saved offset no longer exists.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "topics": {
          "name": "topics",
          "type": "string",
          "kind": "array",
          "description": "\nA list of topics to consume from. Multiple comma separated topics can be listed in a single element. When a `consumer_group` is specified partitions are automatically distributed across consumers of a topic, otherwise all partitions are consumed.\n\nAlternatively, it's possible to specify explicit partitions to consume from with a colon after the topic name, e.g. `foo:0` would consume the partition 0 of the topic foo. This syntax supports ranges, e.g. `foo:0-10` would consume partitions 0 through to 10 inclusive.\n\nFinally, it's also possible to specify an explicit offset to consume from by adding another colon after the partition, e.g. `foo:0:10` would consume the partition 0 of the topic foo starting from the offset 10. If the offset is not present (or remains unspecified) then the field `start_from_oldest` determines which offset to start from.",
          "required": true,
          "default": null,
          "examples": [
            [
              "foo",
              "bar"
            ],
            [
              "things.*"
            ],
            [
              "foo,bar"
            ],
            [
              "foo:0",
              "bar:1",
              "bar:3"
            ],
            [
              "foo:0,bar:1,bar:3"
            ],
            [
              "foo:0-5"
            ]
          ]
        }
      }
    },
    "modbus": {
      "name": "modbus",
      "type": "input",
      "source": "benthos-umh",
      "summary": "Creates an input that reads data from Modbus devices. Created \u0026 maintained by the United Manufacturing Hub. About us: www.umh.app",
      "description": "This input plugin enables Benthos to read data directly from Modbus devices using the Modbus protocol.",
      "config": {
        "addresses": {
          "name": "addresses",
          "type": "object",
          "kind": "array",
          "description": "List of Modbus addresses to read",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "name",
              "type": "string",
              "kind": "scalar",
              "description": "Field name",
              "required": true,
              "default": null,
              "examples": [
                "temperature",
                "pressure",
                "motor_speed"
              ]
            },
            {
              "name": "register",
              "type": "string",
              "kind": "scalar",
              "description": "Register type: 'coil', 'discrete', 'holding', or 'input'",
              "required": true,
              "default": "holding",
              "examples": [
                "holding",
                "input",
                "coil",
                "discrete"
              ]
            },
            {
              "name": "address",
              "type": "int",
              "kind": "scalar",
              "description": "Address of the register to query",
              "required": true,
              "default": null,
              "examples": [
                40001,
                30100,
                10
              ]
            },
            {
              "name": "type",
              "type": "string",
              "kind": "scalar",
              "description": "Data type of the field",
              "required": true,
              "default": null,
              "examples": [
                "FLOAT32",
                "UINT16",
                "INT32"
              ]
            },
            {
              "name": "length",
              "type": "int",
              "kind": "scalar",
              "description": "Number of registers, only valid for STRING type",
              "required": true,
              "default": 0,
              "examples": [
                0,
                10,
                20
              ]
            },
            {
              "name": "bit",
              "type": "int",
              "kind": "scalar",
              "description": "Bit of the register, only valid for BIT type",
              "required": true,
              "default": 0,
              "examples": [
                0,
                1,
                7
              ]
            },
            {
              "name": "scale",
              "type": "float",
              "kind": "scalar",
              "description": "Factor to scale the variable with",
              "required": true,
              "default": 0,
              "examples": [
                0,
                0.1,
                10
              ]
            },
            {
              "name": "output",
              "type": "string",
              "kind": "scalar",
              "description": "Type of resulting field: 'INT64', 'UINT64', 'FLOAT64', or 'native'",
              "required": true,
              "default": "",
              "examples": [
                "",
                "FLOAT64",
                "INT64",
                "UINT64"
              ]
            }
          ]
        },
        "busyRetries": {
          "name": "busyRetries",
          "type": "int",
          "kind": "scalar",
          "description": "Maximum number of retries when the device is busy",
          "required": false,
          "default": 3,
          "examples": [
            3,
            5,
            10
          ],
          "advanced": true
        },
        "busyRetriesWait": {
          "name": "busyRetriesWait",
          "type": "string",
          "kind": "scalar",
          "description": "Time to wait between retries when the device is busy",
          "required": false,
          "default": "200ms",
          "examples": [
            "200ms",
            "500ms",
            "1s"
          ],
          "advanced": true
        },
        "byteOrder": {
          "name": "byteOrder",
          "type": "string",
          "kind": "scalar",
          "description": "Byte order: 'ABCD', 'DCBA', 'BADC', or 'CDAB'",
          "required": false,
          "default": "ABCD",
          "examples": [
            "ABCD",
            "DCBA",
            "BADC",
            "CDAB"
          ],
          "advanced": true
        },
        "controller": {
          "name": "controller",
          "type": "string",
          "kind": "scalar",
          "description": "The Modbus controller address, e.g., 'tcp://localhost:502'",
          "required": true,
          "default": "tcp://localhost:502",
          "examples": [
            "tcp://{{ .IP }}:{{ .PORT }}",
            "tcp://192.168.1.100:502",
            "tcp://10.0.0.50:502",
            "tcp://plc.local:502"
          ]
        },
        "optimization": {
          "name": "optimization",
          "type": "string",
          "kind": "scalar",
          "description": "Request optimization algorithm: 'none' or 'max_insert'",
          "required": false,
          "default": "none",
          "examples": [
            "none",
            "max_insert"
          ],
          "advanced": true
        },
        "optimizationMaxRegisterFill": {
          "name": "optimizationMaxRegisterFill",
          "type": "int",
          "kind": "scalar",
          "description": "Maximum number of registers to insert for optimization",
          "required": false,
          "default": 50,
          "examples": [
            10,
            50,
            100
          ],
          "advanced": true
        },
        "slaveID": {
          "name": "slaveID",
          "type": "int",
          "kind": "scalar",
          "description": "Slave ID of the Modbus device",
          "required": false,
          "default": 1,
          "examples": [
            1,
            2,
            10
          ],
          "advanced": true
        },
        "slaveIDs": {
          "name": "slaveIDs",
          "type": "int",
          "kind": "array",
          "description": "Slave ID of the Modbus device",
          "required": true,
          "default": [
            1
          ],
          "examples": [
            [
              1
            ],
            [
              1,
              2,
              3
            ],
            [
              10,
              20
            ]
          ]
        },
        "timeBetweenReads": {
          "name": "timeBetweenReads",
          "type": "string",
          "kind": "scalar",
          "description": "The time between two reads of a Modbus device. Useful if you want to read the device every x seconds. Not to be confused with TimeBetweenRequests.",
          "required": true,
          "default": "1s",
          "examples": [
            "1s",
            "5s",
            "100ms"
          ]
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "Timeout for requests to the Modbus device",
          "required": true,
          "default": "1s",
          "examples": [
            "1s",
            "5s",
            "10s"
          ]
        },
        "transmissionMode": {
          "name": "transmissionMode",
          "type": "string",
          "kind": "scalar",
          "description": "Transmission mode: 'TCP', 'RTUOverTCP', or 'ASCIIOverTCP'",
          "required": false,
          "default": "TCP",
          "examples": [
            "TCP",
            "RTUOverTCP",
            "ASCIIOverTCP"
          ],
          "advanced": true
        },
        "workarounds": {
          "name": "workarounds",
          "type": "object",
          "kind": "scalar",
          "description": "Modbus workarounds. Required by some devices to work correctly. Should be left alone by default and must not be changed unless necessary.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "pauseAfterConnect",
              "type": "string",
              "kind": "scalar",
              "description": "Pause after connect to delay the first request",
              "required": true,
              "default": "0s",
              "examples": [
                "0s",
                "1s",
                "5s"
              ],
              "advanced": true
            },
            {
              "name": "oneRequestPerField",
              "type": "bool",
              "kind": "scalar",
              "description": "Send each field in a separate request",
              "required": true,
              "default": false,
              "examples": [
                false,
                true
              ],
              "advanced": true
            },
            {
              "name": "readCoilsStartingAtZero",
              "type": "bool",
              "kind": "scalar",
              "description": "Read coils starting at address 0 instead of 1",
              "required": true,
              "default": false,
              "examples": [
                false,
                true
              ],
              "advanced": true
            },
            {
              "name": "stringRegisterLocation",
              "type": "string",
              "kind": "scalar",
              "description": "String byte-location in registers: 'lower', 'upper', or empty for both",
              "required": true,
              "default": "",
              "examples": [
                "",
                "lower",
                "upper"
              ],
              "advanced": true
            },
            {
              "name": "timeBetweenRequests",
              "type": "string",
              "kind": "scalar",
              "description": "timeBetweenRequests is the time between two requests to the same device. Useful to avoid flooding the device. Not to be confused with TimeBetweenReads.",
              "required": true,
              "default": "0s",
              "examples": [
                "0s",
                "100ms",
                "500ms"
              ],
              "advanced": true
            }
          ]
        }
      }
    },
    "mongodb": {
      "name": "mongodb",
      "type": "input",
      "source": "upstream",
      "summary": "Executes a query and creates a message for each document received.",
      "description": "Once the documents from the query are exhausted, this input shuts down, allowing the pipeline to gracefully terminate (or the next input in a xref:components:inputs/sequence.adoc[sequence] to execute).",
      "config": {
        "app_name": {
          "name": "app_name",
          "type": "string",
          "kind": "scalar",
          "description": "The client application name.",
          "required": true,
          "default": "benthos",
          "advanced": true
        },
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "batch_size": {
          "name": "batch_size",
          "type": "int",
          "kind": "scalar",
          "description": "A explicit number of documents to batch up before flushing them for processing. Must be greater than `0`. Operations: `find`, `aggregate`",
          "required": false,
          "default": null,
          "examples": [
            1000
          ]
        },
        "collection": {
          "name": "collection",
          "type": "string",
          "kind": "scalar",
          "description": "The collection to select from.",
          "required": true,
          "default": null
        },
        "database": {
          "name": "database",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the target MongoDB database.",
          "required": true,
          "default": null
        },
        "json_marshal_mode": {
          "name": "json_marshal_mode",
          "type": "string",
          "kind": "scalar",
          "description": "The json_marshal_mode setting is optional and controls the format of the output message.",
          "required": true,
          "default": "canonical",
          "advanced": true
        },
        "limit": {
          "name": "limit",
          "type": "int",
          "kind": "scalar",
          "description": "An explicit maximum number of documents to return. Operations: `find`",
          "required": false,
          "default": null
        },
        "operation": {
          "name": "operation",
          "type": "string",
          "kind": "scalar",
          "description": "The mongodb operation to perform.",
          "required": true,
          "default": "find",
          "options": [
            "find",
            "aggregate"
          ],
          "advanced": true
        },
        "password": {
          "name": "password",
          "type": "string",
          "kind": "scalar",
          "description": "The password to connect to the database.",
          "required": true,
          "default": ""
        },
        "query": {
          "name": "query",
          "type": "string",
          "kind": "scalar",
          "description": "Bloblang expression describing MongoDB query.",
          "required": true,
          "default": null,
          "examples": [
            "\n  root.from = {\"$lte\": timestamp_unix()}\n  root.to = {\"$gte\": timestamp_unix()}\n"
          ]
        },
        "sort": {
          "name": "sort",
          "type": "int",
          "kind": "map",
          "description": "An object specifying fields to sort by, and the respective sort order (`1` ascending, `-1` descending). Note: The driver currently appears to support only one sorting key. Operations: `find`",
          "required": false,
          "default": null,
          "examples": [
            {
              "name": 1
            },
            {
              "age": -1
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL of the target MongoDB server.",
          "required": true,
          "default": null,
          "examples": [
            "mongodb://localhost:27017"
          ]
        },
        "username": {
          "name": "username",
          "type": "string",
          "kind": "scalar",
          "description": "The username to connect to the database.",
          "required": true,
          "default": ""
        }
      }
    },
    "mqtt": {
      "name": "mqtt",
      "type": "input",
      "source": "upstream",
      "summary": "Subscribe to topics on MQTT brokers.",
      "description": "\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n- mqtt_duplicate\n- mqtt_qos\n- mqtt_retained\n- mqtt_topic\n- mqtt_message_id\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation].",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "clean_session": {
          "name": "clean_session",
          "type": "bool",
          "kind": "scalar",
          "description": "Set whether the connection is non-persistent.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "client_id": {
          "name": "client_id",
          "type": "string",
          "kind": "scalar",
          "description": "An identifier for the client connection.",
          "required": true,
          "default": ""
        },
        "connect_timeout": {
          "name": "connect_timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum amount of time to wait in order to establish a connection before the attempt is abandoned.",
          "required": true,
          "default": "30s",
          "examples": [
            "1s",
            "500ms"
          ]
        },
        "dynamic_client_id_suffix": {
          "name": "dynamic_client_id_suffix",
          "type": "string",
          "kind": "scalar",
          "description": "Append a dynamically generated suffix to the specified `client_id` on each run of the pipeline. This can be useful when clustering Redpanda Connect producers.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "keepalive": {
          "name": "keepalive",
          "type": "int",
          "kind": "scalar",
          "description": "Max seconds of inactivity before a keepalive message is sent.",
          "required": true,
          "default": 30,
          "advanced": true
        },
        "password": {
          "name": "password",
          "type": "string",
          "kind": "scalar",
          "description": "A password to connect with.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "qos": {
          "name": "qos",
          "type": "int",
          "kind": "scalar",
          "description": "The level of delivery guarantee to enforce. Has options 0, 1, 2.",
          "required": true,
          "default": 1,
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "topics": {
          "name": "topics",
          "type": "string",
          "kind": "array",
          "description": "A list of topics to consume from.",
          "required": true,
          "default": null
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. The format should be `scheme://host:port` where `scheme` is one of `tcp`, `ssl`, or `ws`, `host` is the ip-address (or hostname) and `port` is the port on which the broker is accepting connections. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "tcp://localhost:1883"
            ]
          ]
        },
        "user": {
          "name": "user",
          "type": "string",
          "kind": "scalar",
          "description": "A username to connect with.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "will": {
          "name": "will",
          "type": "object",
          "kind": "scalar",
          "description": "Set last will message in case of Redpanda Connect failure",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to enable last will messages.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "qos",
              "type": "int",
              "kind": "scalar",
              "description": "Set QoS for last will message. Valid values are: 0, 1, 2.",
              "required": true,
              "default": 0,
              "advanced": true
            },
            {
              "name": "retained",
              "type": "bool",
              "kind": "scalar",
              "description": "Set retained for last will message.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "topic",
              "type": "string",
              "kind": "scalar",
              "description": "Set topic for last will message.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "payload",
              "type": "string",
              "kind": "scalar",
              "description": "Set payload for last will message.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        }
      }
    },
    "nanomsg": {
      "name": "nanomsg",
      "type": "input",
      "source": "upstream",
      "summary": "Consumes messages via Nanomsg sockets (scalability protocols).",
      "description": "Currently only PULL and SUB sockets are supported.",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "bind": {
          "name": "bind",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether the URLs provided should be connected to, or bound as.",
          "required": true,
          "default": true
        },
        "poll_timeout": {
          "name": "poll_timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The period to wait until a poll is abandoned and reattempted.",
          "required": true,
          "default": "5s",
          "advanced": true
        },
        "socket_type": {
          "name": "socket_type",
          "type": "string",
          "kind": "scalar",
          "description": "The socket type to use.",
          "required": true,
          "default": "PULL",
          "options": [
            "PULL",
            "SUB"
          ]
        },
        "sub_filters": {
          "name": "sub_filters",
          "type": "string",
          "kind": "array",
          "description": "A list of subscription topic filters to use when consuming from a SUB socket. Specifying a single sub_filter of `''` will subscribe to everything.",
          "required": true,
          "default": []
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to (or as). If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null
        }
      }
    },
    "nats": {
      "name": "nats",
      "type": "input",
      "source": "upstream",
      "summary": "Subscribe to a NATS subject.",
      "description": "\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n```text\n- nats_subject\n- nats_reply_subject\n- All message headers (when supported by the connection)\n```\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation].\n\n== Connection name\n\nWhen monitoring and managing a production NATS system, it is often useful to\nknow which connection a message was send/received from. This can be achieved by\nsetting the connection name option when creating a NATS connection.\n\nRedpanda Connect will automatically set the connection name based off the label of the given\nNATS component, so that monitoring tools between NATS and Redpanda Connect can stay in sync.\n\n\n== Authentication\n\nThere are several components within Redpanda Connect which uses NATS services. You will find that each of these components\nsupport optional advanced authentication parameters for https://docs.nats.io/nats-server/configuration/securing_nats/auth_intro/nkey_auth[NKeys^]\nand https://docs.nats.io/using-nats/developer/connecting/creds[User Credentials^].\n\nSee an https://docs.nats.io/running-a-nats-service/nats_admin/security/jwt[in-depth tutorial^].\n\n=== NKey file\n\nThe NATS server can use these NKeys in several ways for authentication. The simplest is for the server to be configured\nwith a list of known public keys and for the clients to respond to the challenge by signing it with its private NKey\nconfigured in the `nkey_file` or `nkey` field.\n\nhttps://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[More details^].\n\n=== User credentials\n\nNATS server supports decentralized authentication based on JSON Web Tokens (JWT). Clients need an https://docs.nats.io/nats-server/configuration/securing_nats/jwt#json-web-tokens[user JWT^]\nand a corresponding https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[NKey secret^] when connecting to a server\nwhich is configured to use this authentication scheme.\n\nThe `user_credentials_file` field should point to a file containing both the private key and the JWT and can be\ngenerated with the https://docs.nats.io/nats-tools/nsc[nsc tool^].\n\nAlternatively, the `user_jwt` field can contain a plain text JWT and the `user_nkey_seed`can contain\nthe plain text NKey Seed.\n\nhttps://docs.nats.io/using-nats/developer/connecting/creds[More details^].",
      "config": {
        "auth": {
          "name": "auth",
          "type": "object",
          "kind": "scalar",
          "description": "Optional configuration of NATS authentication parameters.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "nkey_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing a NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./seed.nk"
              ],
              "advanced": true
            },
            {
              "name": "nkey",
              "type": "string",
              "kind": "scalar",
              "description": "The NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "UDXU4RCSJNZOIQHZNWXHXORDPRTGNJAHAHFRGZNEEJCPQTT2M7NLCNF4"
              ],
              "advanced": true
            },
            {
              "name": "user_credentials_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing user credentials which consist of an user JWT and corresponding NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./user.creds"
              ],
              "advanced": true
            },
            {
              "name": "user_jwt",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user JWT (given along with the corresponding user NKey Seed).",
              "required": false,
              "default": null,
              "advanced": true
            },
            {
              "name": "user_nkey_seed",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user NKey Seed (given along with the corresponding user JWT).",
              "required": false,
              "default": null,
              "advanced": true
            }
          ]
        },
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "extract_tracing_map": {
          "name": "extract_tracing_map",
          "type": "string",
          "kind": "scalar",
          "description": "EXPERIMENTAL: A xref:guides:bloblang/about.adoc[Bloblang mapping] that attempts to extract an object containing tracing propagation information, which will then be used as the root tracing span for the message. The specification of the extracted fields must match the format used by the service wide tracer.",
          "required": false,
          "default": null,
          "examples": [
            "root = @",
            "root = this.meta.span"
          ],
          "advanced": true
        },
        "nak_delay": {
          "name": "nak_delay",
          "type": "string",
          "kind": "scalar",
          "description": "An optional delay duration on redelivering a message when negatively acknowledged.",
          "required": false,
          "default": null,
          "examples": [
            "1m"
          ],
          "advanced": true
        },
        "prefetch_count": {
          "name": "prefetch_count",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to pull at a time.",
          "required": true,
          "default": 524288,
          "advanced": true
        },
        "queue": {
          "name": "queue",
          "type": "string",
          "kind": "scalar",
          "description": "An optional queue group to consume as.",
          "required": false,
          "default": null
        },
        "send_ack": {
          "name": "send_ack",
          "type": "bool",
          "kind": "scalar",
          "description": "Control whether ACKS are sent as a reply to each message. When enabled, these replies are sent only once the data has been delivered to all outputs.",
          "required": true,
          "default": true
        },
        "subject": {
          "name": "subject",
          "type": "string",
          "kind": "scalar",
          "description": "A subject to consume from. Supports wildcards for consuming multiple subjects. Either a subject or stream must be specified.",
          "required": true,
          "default": null,
          "examples": [
            "foo.bar.baz",
            "foo.*.baz",
            "foo.bar.*",
            "foo.\u003e"
          ]
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "nats://127.0.0.1:4222"
            ],
            [
              "nats://username:password@127.0.0.1:4222"
            ]
          ]
        }
      }
    },
    "nats_jetstream": {
      "name": "nats_jetstream",
      "type": "input",
      "source": "upstream",
      "summary": "Reads messages from NATS JetStream subjects.",
      "description": "\n== Consume mirrored streams\n\nIn the case where a stream being consumed is mirrored from a different JetStream domain the stream cannot be resolved from the subject name alone, and so the stream name as well as the subject (if applicable) must both be specified.\n\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n```text\n- nats_subject\n- nats_sequence_stream\n- nats_sequence_consumer\n- nats_num_delivered\n- nats_num_pending\n- nats_domain\n- nats_timestamp_unix_nano\n```\n\nYou can access these metadata fields using\nxref:configuration:interpolation.adoc#bloblang-queries[function interpolation].\n\n== Connection name\n\nWhen monitoring and managing a production NATS system, it is often useful to\nknow which connection a message was send/received from. This can be achieved by\nsetting the connection name option when creating a NATS connection.\n\nRedpanda Connect will automatically set the connection name based off the label of the given\nNATS component, so that monitoring tools between NATS and Redpanda Connect can stay in sync.\n\n\n== Authentication\n\nThere are several components within Redpanda Connect which uses NATS services. You will find that each of these components\nsupport optional advanced authentication parameters for https://docs.nats.io/nats-server/configuration/securing_nats/auth_intro/nkey_auth[NKeys^]\nand https://docs.nats.io/using-nats/developer/connecting/creds[User Credentials^].\n\nSee an https://docs.nats.io/running-a-nats-service/nats_admin/security/jwt[in-depth tutorial^].\n\n=== NKey file\n\nThe NATS server can use these NKeys in several ways for authentication. The simplest is for the server to be configured\nwith a list of known public keys and for the clients to respond to the challenge by signing it with its private NKey\nconfigured in the `nkey_file` or `nkey` field.\n\nhttps://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[More details^].\n\n=== User credentials\n\nNATS server supports decentralized authentication based on JSON Web Tokens (JWT). Clients need an https://docs.nats.io/nats-server/configuration/securing_nats/jwt#json-web-tokens[user JWT^]\nand a corresponding https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[NKey secret^] when connecting to a server\nwhich is configured to use this authentication scheme.\n\nThe `user_credentials_file` field should point to a file containing both the private key and the JWT and can be\ngenerated with the https://docs.nats.io/nats-tools/nsc[nsc tool^].\n\nAlternatively, the `user_jwt` field can contain a plain text JWT and the `user_nkey_seed`can contain\nthe plain text NKey Seed.\n\nhttps://docs.nats.io/using-nats/developer/connecting/creds[More details^].",
      "config": {
        "ack_wait": {
          "name": "ack_wait",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum amount of time NATS server should wait for an ack from consumer.",
          "required": true,
          "default": "30s",
          "examples": [
            "100ms",
            "5m"
          ],
          "advanced": true
        },
        "auth": {
          "name": "auth",
          "type": "object",
          "kind": "scalar",
          "description": "Optional configuration of NATS authentication parameters.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "nkey_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing a NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./seed.nk"
              ],
              "advanced": true
            },
            {
              "name": "nkey",
              "type": "string",
              "kind": "scalar",
              "description": "The NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "UDXU4RCSJNZOIQHZNWXHXORDPRTGNJAHAHFRGZNEEJCPQTT2M7NLCNF4"
              ],
              "advanced": true
            },
            {
              "name": "user_credentials_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing user credentials which consist of an user JWT and corresponding NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./user.creds"
              ],
              "advanced": true
            },
            {
              "name": "user_jwt",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user JWT (given along with the corresponding user NKey Seed).",
              "required": false,
              "default": null,
              "advanced": true
            },
            {
              "name": "user_nkey_seed",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user NKey Seed (given along with the corresponding user JWT).",
              "required": false,
              "default": null,
              "advanced": true
            }
          ]
        },
        "bind": {
          "name": "bind",
          "type": "bool",
          "kind": "scalar",
          "description": "Indicates that the subscription should use an existing consumer.",
          "required": false,
          "default": null
        },
        "deliver": {
          "name": "deliver",
          "type": "string",
          "kind": "scalar",
          "description": "Determines which messages to deliver when consuming without a durable subscriber.",
          "required": true,
          "default": "all"
        },
        "durable": {
          "name": "durable",
          "type": "string",
          "kind": "scalar",
          "description": "Preserve the state of your consumer under a durable name. Used to configure a pull consumer.",
          "required": false,
          "default": null
        },
        "extract_tracing_map": {
          "name": "extract_tracing_map",
          "type": "string",
          "kind": "scalar",
          "description": "EXPERIMENTAL: A xref:guides:bloblang/about.adoc[Bloblang mapping] that attempts to extract an object containing tracing propagation information, which will then be used as the root tracing span for the message. The specification of the extracted fields must match the format used by the service wide tracer.",
          "required": false,
          "default": null,
          "examples": [
            "root = @",
            "root = this.meta.span"
          ],
          "advanced": true
        },
        "max_ack_pending": {
          "name": "max_ack_pending",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of outstanding acks to be allowed before consuming is halted.",
          "required": true,
          "default": 1024,
          "advanced": true
        },
        "queue": {
          "name": "queue",
          "type": "string",
          "kind": "scalar",
          "description": "An optional queue group to consume as. Used to configure a push consumer.",
          "required": false,
          "default": null
        },
        "stream": {
          "name": "stream",
          "type": "string",
          "kind": "scalar",
          "description": "A stream to consume from. Either a subject or stream must be specified.",
          "required": false,
          "default": null
        },
        "subject": {
          "name": "subject",
          "type": "string",
          "kind": "scalar",
          "description": "A subject to consume from. Supports wildcards for consuming multiple subjects. Either a subject or stream must be specified.",
          "required": false,
          "default": null,
          "examples": [
            "foo.bar.baz",
            "foo.*.baz",
            "foo.bar.*",
            "foo.\u003e"
          ]
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "nats://127.0.0.1:4222"
            ],
            [
              "nats://username:password@127.0.0.1:4222"
            ]
          ]
        }
      }
    },
    "nats_kv": {
      "name": "nats_kv",
      "type": "input",
      "source": "upstream",
      "summary": "Watches for updates in a NATS key-value bucket.",
      "description": "\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n``` text\n- nats_kv_key\n- nats_kv_bucket\n- nats_kv_revision\n- nats_kv_delta\n- nats_kv_operation\n- nats_kv_created\n```\n\n== Connection name\n\nWhen monitoring and managing a production NATS system, it is often useful to\nknow which connection a message was send/received from. This can be achieved by\nsetting the connection name option when creating a NATS connection.\n\nRedpanda Connect will automatically set the connection name based off the label of the given\nNATS component, so that monitoring tools between NATS and Redpanda Connect can stay in sync.\n\n\n== Authentication\n\nThere are several components within Redpanda Connect which uses NATS services. You will find that each of these components\nsupport optional advanced authentication parameters for https://docs.nats.io/nats-server/configuration/securing_nats/auth_intro/nkey_auth[NKeys^]\nand https://docs.nats.io/using-nats/developer/connecting/creds[User Credentials^].\n\nSee an https://docs.nats.io/running-a-nats-service/nats_admin/security/jwt[in-depth tutorial^].\n\n=== NKey file\n\nThe NATS server can use these NKeys in several ways for authentication. The simplest is for the server to be configured\nwith a list of known public keys and for the clients to respond to the challenge by signing it with its private NKey\nconfigured in the `nkey_file` or `nkey` field.\n\nhttps://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[More details^].\n\n=== User credentials\n\nNATS server supports decentralized authentication based on JSON Web Tokens (JWT). Clients need an https://docs.nats.io/nats-server/configuration/securing_nats/jwt#json-web-tokens[user JWT^]\nand a corresponding https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[NKey secret^] when connecting to a server\nwhich is configured to use this authentication scheme.\n\nThe `user_credentials_file` field should point to a file containing both the private key and the JWT and can be\ngenerated with the https://docs.nats.io/nats-tools/nsc[nsc tool^].\n\nAlternatively, the `user_jwt` field can contain a plain text JWT and the `user_nkey_seed`can contain\nthe plain text NKey Seed.\n\nhttps://docs.nats.io/using-nats/developer/connecting/creds[More details^].",
      "config": {
        "auth": {
          "name": "auth",
          "type": "object",
          "kind": "scalar",
          "description": "Optional configuration of NATS authentication parameters.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "nkey_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing a NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./seed.nk"
              ],
              "advanced": true
            },
            {
              "name": "nkey",
              "type": "string",
              "kind": "scalar",
              "description": "The NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "UDXU4RCSJNZOIQHZNWXHXORDPRTGNJAHAHFRGZNEEJCPQTT2M7NLCNF4"
              ],
              "advanced": true
            },
            {
              "name": "user_credentials_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing user credentials which consist of an user JWT and corresponding NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./user.creds"
              ],
              "advanced": true
            },
            {
              "name": "user_jwt",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user JWT (given along with the corresponding user NKey Seed).",
              "required": false,
              "default": null,
              "advanced": true
            },
            {
              "name": "user_nkey_seed",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user NKey Seed (given along with the corresponding user JWT).",
              "required": false,
              "default": null,
              "advanced": true
            }
          ]
        },
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "bucket": {
          "name": "bucket",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the KV bucket.",
          "required": true,
          "default": null,
          "examples": [
            "my_kv_bucket"
          ]
        },
        "ignore_deletes": {
          "name": "ignore_deletes",
          "type": "bool",
          "kind": "scalar",
          "description": "Do not send delete markers as messages.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "include_history": {
          "name": "include_history",
          "type": "bool",
          "kind": "scalar",
          "description": "Include all the history per key, not just the last one.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "Key to watch for updates, can include wildcards.",
          "required": true,
          "default": "\u003e",
          "examples": [
            "foo.bar.baz",
            "foo.*.baz",
            "foo.bar.*",
            "foo.\u003e"
          ]
        },
        "meta_only": {
          "name": "meta_only",
          "type": "bool",
          "kind": "scalar",
          "description": "Retrieve only the metadata of the entry",
          "required": true,
          "default": false,
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "nats://127.0.0.1:4222"
            ],
            [
              "nats://username:password@127.0.0.1:4222"
            ]
          ]
        }
      }
    },
    "nats_stream": {
      "name": "nats_stream",
      "type": "input",
      "source": "upstream",
      "summary": "Subscribe to a NATS Stream subject. Joining a queue is optional and allows multiple clients of a subject to consume using queue semantics.",
      "description": "\n[CAUTION]\n.Deprecation notice\n====\nThe NATS Streaming Server is being deprecated. Critical bug fixes and security fixes will be applied until June of 2023. NATS-enabled applications requiring persistence should use https://docs.nats.io/nats-concepts/jetstream[JetStream^].\n====\n\nTracking and persisting offsets through a durable name is also optional and works with or without a queue. If a durable name is not provided then subjects are consumed from the most recently published message.\n\nWhen a consumer closes its connection it unsubscribes, when all consumers of a durable queue do this the offsets are deleted. In order to avoid this you can stop the consumers from unsubscribing by setting the field `unsubscribe_on_close` to `false`.\n\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n- nats_stream_subject\n- nats_stream_sequence\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation].\n\n\n\n== Authentication\n\nThere are several components within Redpanda Connect which uses NATS services. You will find that each of these components\nsupport optional advanced authentication parameters for https://docs.nats.io/nats-server/configuration/securing_nats/auth_intro/nkey_auth[NKeys^]\nand https://docs.nats.io/using-nats/developer/connecting/creds[User Credentials^].\n\nSee an https://docs.nats.io/running-a-nats-service/nats_admin/security/jwt[in-depth tutorial^].\n\n=== NKey file\n\nThe NATS server can use these NKeys in several ways for authentication. The simplest is for the server to be configured\nwith a list of known public keys and for the clients to respond to the challenge by signing it with its private NKey\nconfigured in the `nkey_file` or `nkey` field.\n\nhttps://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[More details^].\n\n=== User credentials\n\nNATS server supports decentralized authentication based on JSON Web Tokens (JWT). Clients need an https://docs.nats.io/nats-server/configuration/securing_nats/jwt#json-web-tokens[user JWT^]\nand a corresponding https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[NKey secret^] when connecting to a server\nwhich is configured to use this authentication scheme.\n\nThe `user_credentials_file` field should point to a file containing both the private key and the JWT and can be\ngenerated with the https://docs.nats.io/nats-tools/nsc[nsc tool^].\n\nAlternatively, the `user_jwt` field can contain a plain text JWT and the `user_nkey_seed`can contain\nthe plain text NKey Seed.\n\nhttps://docs.nats.io/using-nats/developer/connecting/creds[More details^].",
      "config": {
        "ack_wait": {
          "name": "ack_wait",
          "type": "string",
          "kind": "scalar",
          "description": "An optional duration to specify at which a message that is yet to be acked will be automatically retried.",
          "required": true,
          "default": "30s",
          "advanced": true
        },
        "auth": {
          "name": "auth",
          "type": "object",
          "kind": "scalar",
          "description": "Optional configuration of NATS authentication parameters.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "nkey_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing a NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./seed.nk"
              ],
              "advanced": true
            },
            {
              "name": "nkey",
              "type": "string",
              "kind": "scalar",
              "description": "The NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "UDXU4RCSJNZOIQHZNWXHXORDPRTGNJAHAHFRGZNEEJCPQTT2M7NLCNF4"
              ],
              "advanced": true
            },
            {
              "name": "user_credentials_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing user credentials which consist of an user JWT and corresponding NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./user.creds"
              ],
              "advanced": true
            },
            {
              "name": "user_jwt",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user JWT (given along with the corresponding user NKey Seed).",
              "required": false,
              "default": null,
              "advanced": true
            },
            {
              "name": "user_nkey_seed",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user NKey Seed (given along with the corresponding user JWT).",
              "required": false,
              "default": null,
              "advanced": true
            }
          ]
        },
        "client_id": {
          "name": "client_id",
          "type": "string",
          "kind": "scalar",
          "description": "A client ID to connect as.",
          "required": true,
          "default": ""
        },
        "cluster_id": {
          "name": "cluster_id",
          "type": "string",
          "kind": "scalar",
          "description": "The ID of the cluster to consume from.",
          "required": true,
          "default": null
        },
        "durable_name": {
          "name": "durable_name",
          "type": "string",
          "kind": "scalar",
          "description": "Preserve the state of your consumer under a durable name.",
          "required": true,
          "default": ""
        },
        "extract_tracing_map": {
          "name": "extract_tracing_map",
          "type": "string",
          "kind": "scalar",
          "description": "EXPERIMENTAL: A xref:guides:bloblang/about.adoc[Bloblang mapping] that attempts to extract an object containing tracing propagation information, which will then be used as the root tracing span for the message. The specification of the extracted fields must match the format used by the service wide tracer.",
          "required": false,
          "default": null,
          "examples": [
            "root = @",
            "root = this.meta.span"
          ],
          "advanced": true
        },
        "max_inflight": {
          "name": "max_inflight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of unprocessed messages to fetch at a given time.",
          "required": true,
          "default": 1024,
          "advanced": true
        },
        "queue": {
          "name": "queue",
          "type": "string",
          "kind": "scalar",
          "description": "The queue to consume from.",
          "required": true,
          "default": ""
        },
        "start_from_oldest": {
          "name": "start_from_oldest",
          "type": "bool",
          "kind": "scalar",
          "description": "If a position is not found for a queue, determines whether to consume from the oldest available message, otherwise messages are consumed from the latest.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "subject": {
          "name": "subject",
          "type": "string",
          "kind": "scalar",
          "description": "A subject to consume from.",
          "required": true,
          "default": ""
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "unsubscribe_on_close": {
          "name": "unsubscribe_on_close",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether the subscription should be destroyed when this client disconnects.",
          "required": true,
          "default": false
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "nats://127.0.0.1:4222"
            ],
            [
              "nats://username:password@127.0.0.1:4222"
            ]
          ]
        }
      }
    },
    "nsq": {
      "name": "nsq",
      "type": "input",
      "source": "upstream",
      "summary": "Subscribe to an NSQ instance topic and channel.",
      "description": "\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n- nsq_attempts\n- nsq_id\n- nsq_nsqd_address\n- nsq_timestamp\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation].\n",
      "config": {
        "channel": {
          "name": "channel",
          "type": "string",
          "kind": "scalar",
          "description": "The channel to consume from.",
          "required": true,
          "default": null
        },
        "lookupd_http_addresses": {
          "name": "lookupd_http_addresses",
          "type": "string",
          "kind": "array",
          "description": "A list of nsqlookupd addresses to connect to.",
          "required": true,
          "default": null
        },
        "max_attempts": {
          "name": "max_attempts",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of attempts to successfully consume a messages.",
          "required": true,
          "default": 5
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of pending messages to consume at any given time.",
          "required": true,
          "default": 100
        },
        "nsqd_tcp_addresses": {
          "name": "nsqd_tcp_addresses",
          "type": "string",
          "kind": "array",
          "description": "A list of nsqd addresses to connect to.",
          "required": true,
          "default": null
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "topic": {
          "name": "topic",
          "type": "string",
          "kind": "scalar",
          "description": "The topic to consume from.",
          "required": true,
          "default": null
        },
        "user_agent": {
          "name": "user_agent",
          "type": "string",
          "kind": "scalar",
          "description": "A user agent to assume when connecting.",
          "required": false,
          "default": null
        }
      }
    },
    "ockam_kafka": {
      "name": "ockam_kafka",
      "type": "input",
      "source": "upstream",
      "summary": "Ockam",
      "config": {
        "allow": {
          "name": "allow",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": "self"
        },
        "allow_producer": {
          "name": "allow_producer",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": "self"
        },
        "disable_content_encryption": {
          "name": "disable_content_encryption",
          "type": "bool",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": false
        },
        "encrypted_fields": {
          "name": "encrypted_fields",
          "type": "string",
          "kind": "array",
          "description": "The fields to encrypt in the kafka messages, assuming the record is a valid JSON map. By default, the whole record is encrypted.",
          "required": true,
          "default": []
        },
        "enrollment_ticket": {
          "name": "enrollment_ticket",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": false,
          "default": null
        },
        "identity_name": {
          "name": "identity_name",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": false,
          "default": null
        },
        "kafka": {
          "name": "kafka",
          "type": "object",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "seed_brokers",
              "type": "string",
              "kind": "array",
              "description": "A list of broker addresses to connect to in order to establish connections. If an item of the list contains commas it will be expanded into multiple addresses.",
              "required": false,
              "default": null,
              "examples": [
                [
                  "localhost:9092"
                ],
                [
                  "foo:9092",
                  "bar:9092"
                ],
                [
                  "foo:9092,bar:9092"
                ]
              ]
            },
            {
              "name": "tls",
              "type": "object",
              "kind": "scalar",
              "description": "Custom TLS settings can be used to override system defaults.",
              "required": true,
              "default": null,
              "advanced": true,
              "children": [
                {
                  "name": "enabled",
                  "type": "bool",
                  "kind": "scalar",
                  "description": "Whether custom TLS settings are enabled.",
                  "required": true,
                  "default": false,
                  "advanced": true
                },
                {
                  "name": "skip_cert_verify",
                  "type": "bool",
                  "kind": "scalar",
                  "description": "Whether to skip server side certificate verification.",
                  "required": true,
                  "default": false,
                  "advanced": true
                },
                {
                  "name": "enable_renegotiation",
                  "type": "bool",
                  "kind": "scalar",
                  "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
                  "required": true,
                  "default": false,
                  "advanced": true
                },
                {
                  "name": "root_cas",
                  "type": "string",
                  "kind": "scalar",
                  "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
                  "required": true,
                  "default": "",
                  "examples": [
                    "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
                  ],
                  "advanced": true
                },
                {
                  "name": "root_cas_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
                  "required": true,
                  "default": "",
                  "examples": [
                    "./root_cas.pem"
                  ],
                  "advanced": true
                },
                {
                  "name": "client_certs",
                  "type": "object",
                  "kind": "array",
                  "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
                  "required": true,
                  "default": [],
                  "examples": [
                    [
                      {
                        "cert": "foo",
                        "key": "bar"
                      }
                    ],
                    [
                      {
                        "cert_file": "./example.pem",
                        "key_file": "./example.key"
                      }
                    ]
                  ],
                  "advanced": true,
                  "children": [
                    {
                      "name": "cert",
                      "type": "string",
                      "kind": "scalar",
                      "description": "A plain text certificate to use.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "key",
                      "type": "string",
                      "kind": "scalar",
                      "description": "A plain text certificate key to use.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "cert_file",
                      "type": "string",
                      "kind": "scalar",
                      "description": "The path of a certificate to use.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "key_file",
                      "type": "string",
                      "kind": "scalar",
                      "description": "The path of a certificate key to use.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "password",
                      "type": "string",
                      "kind": "scalar",
                      "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                      "required": true,
                      "default": "",
                      "examples": [
                        "foo",
                        "${KEY_PASSWORD}"
                      ],
                      "advanced": true
                    }
                  ]
                }
              ]
            },
            {
              "name": "topics",
              "type": "string",
              "kind": "array",
              "description": "\nA list of topics to consume from. Multiple comma separated topics can be listed in a single element. When a `consumer_group` is specified partitions are automatically distributed across consumers of a topic, otherwise all partitions are consumed.\n\nAlternatively, it's possible to specify explicit partitions to consume from with a colon after the topic name, e.g. `foo:0` would consume the partition 0 of the topic foo. This syntax supports ranges, e.g. `foo:0-10` would consume partitions 0 through to 10 inclusive.\n\nFinally, it's also possible to specify an explicit offset to consume from by adding another colon after the partition, e.g. `foo:0:10` would consume the partition 0 of the topic foo starting from the offset 10. If the offset is not present (or remains unspecified) then the field `start_from_oldest` determines which offset to start from.",
              "required": true,
              "default": null,
              "examples": [
                [
                  "foo",
                  "bar"
                ],
                [
                  "things.*"
                ],
                [
                  "foo,bar"
                ],
                [
                  "foo:0",
                  "bar:1",
                  "bar:3"
                ],
                [
                  "foo:0,bar:1,bar:3"
                ],
                [
                  "foo:0-5"
                ]
              ]
            },
            {
              "name": "regexp_topics",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether listed topics should be interpreted as regular expression patterns for matching multiple topics. When topics are specified with explicit partitions this field must remain set to `false`.",
              "required": true,
              "default": false
            },
            {
              "name": "rack_id",
              "type": "string",
              "kind": "scalar",
              "description": "A rack specifies where the client is physically located and changes fetch requests to consume from the closest replica as opposed to the leader replica.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "instance_id",
              "type": "string",
              "kind": "scalar",
              "description": "When using a consumer group, an instance ID specifies the groups static membership, which can prevent rebalances during reconnects. When using a instance ID the client does NOT leave the group when closing. To actually leave the group one must use an external admin command to leave the group on behalf of this instance ID. This ID must be unique per consumer within the group.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "rebalance_timeout",
              "type": "string",
              "kind": "scalar",
              "description": "When using a consumer group, `rebalance_timeout` sets how long group members are allowed to take when a rebalance has begun. This timeout is how long all members are allowed to complete work and commit offsets, minus the time it took to detect the rebalance (from a heartbeat).",
              "required": true,
              "default": "45s",
              "advanced": true
            },
            {
              "name": "session_timeout",
              "type": "string",
              "kind": "scalar",
              "description": "When using a consumer group, `session_timeout` sets how long a member in hte group can go between heartbeats. If a member does not heartbeat in this timeout, the broker will remove the member from the group and initiate a rebalance.",
              "required": true,
              "default": "1m",
              "advanced": true
            },
            {
              "name": "heartbeat_interval",
              "type": "string",
              "kind": "scalar",
              "description": "When using a consumer group, `heartbeat_interval` sets how long a group member goes between heartbeats to Kafka. Kafka uses heartbeats to ensure that a group member's sesion stays active. This value should be no higher than 1/3rd of the `session_timeout`. This is equivalent to the Java heartbeat.interval.ms setting.",
              "required": true,
              "default": "3s",
              "advanced": true
            },
            {
              "name": "start_from_oldest",
              "type": "bool",
              "kind": "scalar",
              "description": "Determines whether to consume from the oldest available offset, otherwise messages are consumed from the latest offset. The setting is applied when creating a new consumer group or the saved offset no longer exists.",
              "required": true,
              "default": true,
              "advanced": true
            },
            {
              "name": "fetch_max_bytes",
              "type": "string",
              "kind": "scalar",
              "description": "Sets the maximum amount of bytes a broker will try to send during a fetch. Note that brokers may not obey this limit if it has records larger than this limit. This is the equivalent to the Java fetch.max.bytes setting.",
              "required": true,
              "default": "50MiB",
              "advanced": true
            },
            {
              "name": "fetch_max_wait",
              "type": "string",
              "kind": "scalar",
              "description": "Sets the maximum amount of time a broker will wait for a fetch response to hit the minimum number of required bytes. This is the equivalent to the Java fetch.max.wait.ms setting.",
              "required": true,
              "default": "5s",
              "advanced": true
            },
            {
              "name": "fetch_min_bytes",
              "type": "string",
              "kind": "scalar",
              "description": "Sets the minimum amount of bytes a broker will try to send during a fetch. This is the equivalent to the Java fetch.min.bytes setting.",
              "required": true,
              "default": "1B",
              "advanced": true
            },
            {
              "name": "fetch_max_partition_bytes",
              "type": "string",
              "kind": "scalar",
              "description": "Sets the maximum amount of bytes that will be consumed for a single partition in a fetch request. Note that if a single batch is larger than this number, that batch will still be returned so the client can make progress. This is the equivalent to the Java fetch.max.partition.bytes setting.",
              "required": true,
              "default": "1MiB",
              "advanced": true
            },
            {
              "name": "consumer_group",
              "type": "string",
              "kind": "scalar",
              "description": "An optional consumer group to consume as. When specified the partitions of specified topics are automatically distributed across consumers sharing a consumer group, and partition offsets are automatically committed and resumed under this name. Consumer groups are not supported when specifying explicit partitions to consume from in the `topics` field.",
              "required": false,
              "default": null
            },
            {
              "name": "checkpoint_limit",
              "type": "int",
              "kind": "scalar",
              "description": "Determines how many messages of the same partition can be processed in parallel before applying back pressure. When a message of a given offset is delivered to the output the offset is only allowed to be committed when all messages of prior offsets have also been delivered, this ensures at-least-once delivery guarantees. However, this mechanism also increases the likelihood of duplicates in the event of crashes or server faults, reducing the checkpoint limit will mitigate this.",
              "required": true,
              "default": 1024,
              "advanced": true
            },
            {
              "name": "commit_period",
              "type": "string",
              "kind": "scalar",
              "description": "The period of time between each commit of the current partition offsets. Offsets are always committed during shutdown.",
              "required": true,
              "default": "5s",
              "advanced": true
            },
            {
              "name": "multi_header",
              "type": "bool",
              "kind": "scalar",
              "description": "Decode headers into lists to allow handling of multiple values with the same key",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "batching",
              "type": "object",
              "kind": "",
              "description": "Allows you to configure a xref:configuration:batching.adoc[batching policy] that applies to individual topic partitions in order to batch messages together before flushing them for processing. Batching can be beneficial for performance as well as useful for windowed processing, and doing so this way preserves the ordering of topic partitions.",
              "required": true,
              "default": null,
              "examples": [
                {
                  "byte_size": 5000,
                  "count": 0,
                  "period": "1s"
                },
                {
                  "count": 10,
                  "period": "1s"
                },
                {
                  "check": "this.contains(\"END BATCH\")",
                  "count": 0,
                  "period": "1m"
                }
              ],
              "advanced": true,
              "children": [
                {
                  "name": "count",
                  "type": "int",
                  "kind": "scalar",
                  "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
                  "required": true,
                  "default": 0,
                  "advanced": true
                },
                {
                  "name": "byte_size",
                  "type": "int",
                  "kind": "scalar",
                  "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
                  "required": true,
                  "default": 0,
                  "advanced": true
                },
                {
                  "name": "period",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A period in which an incomplete batch should be flushed regardless of its size.",
                  "required": true,
                  "default": "",
                  "examples": [
                    "1s",
                    "1m",
                    "500ms"
                  ],
                  "advanced": true
                },
                {
                  "name": "check",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
                  "required": true,
                  "default": "",
                  "examples": [
                    "this.type == \"end_of_transaction\""
                  ],
                  "advanced": true
                },
                {
                  "name": "processors",
                  "type": "processor",
                  "kind": "array",
                  "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
                  "required": false,
                  "default": null,
                  "examples": [
                    [
                      {
                        "archive": {
                          "format": "concatenate"
                        }
                      }
                    ],
                    [
                      {
                        "archive": {
                          "format": "lines"
                        }
                      }
                    ],
                    [
                      {
                        "archive": {
                          "format": "json_array"
                        }
                      }
                    ]
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "node_address": {
          "name": "node_address",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": "127.0.0.1:6262"
        },
        "relay": {
          "name": "relay",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": false,
          "default": null
        },
        "route_to_kafka_outlet": {
          "name": "route_to_kafka_outlet",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": "self"
        }
      }
    },
    "opcua": {
      "name": "opcua",
      "type": "input",
      "source": "benthos-umh",
      "summary": "OPC UA input plugin",
      "description": "The OPC UA input plugin reads data from an OPC UA server and sends it to Benthos.",
      "config": {
        "autoReconnect": {
          "name": "autoReconnect",
          "type": "bool",
          "kind": "scalar",
          "description": "Set to true to automatically reconnect to the OPC UA server when the connection is lost.",
          "required": true,
          "default": false,
          "examples": [
            false,
            true
          ],
          "advanced": true
        },
        "clientCertificate": {
          "name": "clientCertificate",
          "type": "string",
          "kind": "scalar",
          "description": "The client certificate to use, base64-encoded.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "directConnect": {
          "name": "directConnect",
          "type": "bool",
          "kind": "scalar",
          "description": "Set this to true to directly connect to an OPC UA endpoint. This can be necessary in cases where the OPC UA server does not allow 'endpoint discovery'. This requires having the full endpoint name in endpoint, and securityMode and securityPolicy set.",
          "required": true,
          "default": false,
          "examples": [
            false,
            true
          ],
          "advanced": true
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "The OPC UA server endpoint to connect to.",
          "required": true,
          "default": null,
          "examples": [
            "opc.tcp://localhost:4840",
            "opc.tcp://{{ .IP }}:{{ .PORT }}",
            "opc.tcp://192.168.1.100:4840",
            "opc.tcp://10.0.0.50:4840",
            "opc.tcp://plc.local:4840"
          ]
        },
        "insecure": {
          "name": "insecure",
          "type": "bool",
          "kind": "scalar",
          "description": "Set to true to bypass secure connections, useful in case of SSL or certificate issues. Default is secure (false).",
          "required": true,
          "default": false,
          "examples": [
            false,
            true
          ],
          "advanced": true
        },
        "nodeIDs": {
          "name": "nodeIDs",
          "type": "string",
          "kind": "array",
          "description": "List of OPC-UA node IDs to begin browsing.",
          "required": true,
          "default": null,
          "examples": [
            [
              "i=84"
            ],
            [
              "ns=2;s=Temperature"
            ],
            [
              "ns=2;s=Temperature",
              "ns=2;s=Pressure"
            ],
            [
              "ns=3;i=1001"
            ]
          ]
        },
        "password": {
          "name": "password",
          "type": "string",
          "kind": "scalar",
          "description": "The password for authentication.",
          "required": false,
          "default": "",
          "examples": [
            "",
            "password123"
          ],
          "advanced": true
        },
        "pollRate": {
          "name": "pollRate",
          "type": "int",
          "kind": "scalar",
          "description": "The rate in milliseconds at which to poll the OPC UA server when not using subscriptions. Defaults to 1000ms (1 second).",
          "required": false,
          "default": 1000,
          "examples": [
            1000,
            5000,
            100
          ],
          "advanced": true
        },
        "queueSize": {
          "name": "queueSize",
          "type": "int",
          "kind": "scalar",
          "description": "The size of the queue, which will get filled from the OPC UA server when requesting its data via subscription",
          "required": false,
          "default": 10,
          "examples": [
            10,
            50,
            100
          ],
          "advanced": true
        },
        "reconnectIntervalInSeconds": {
          "name": "reconnectIntervalInSeconds",
          "type": "int",
          "kind": "scalar",
          "description": "The interval in seconds at which to reconnect to the OPC UA server when the connection is lost. This is only used if `autoReconnect` is set to true.",
          "required": true,
          "default": 5,
          "examples": [
            5,
            10,
            30
          ],
          "advanced": true
        },
        "samplingInterval": {
          "name": "samplingInterval",
          "type": "float",
          "kind": "scalar",
          "description": "The interval for sampling on the OPC UA server - notice 0.0 will get you updates as fast as possible",
          "required": false,
          "default": 0,
          "examples": [
            0,
            100,
            1000
          ],
          "advanced": true
        },
        "securityMode": {
          "name": "securityMode",
          "type": "string",
          "kind": "scalar",
          "description": "The security mode to use. Options: None, Sign, SignAndEncrypt",
          "required": false,
          "default": "",
          "examples": [
            "",
            "None",
            "Sign",
            "SignAndEncrypt"
          ],
          "advanced": true
        },
        "securityPolicy": {
          "name": "securityPolicy",
          "type": "string",
          "kind": "scalar",
          "description": "The security policy to use. Options: None, Basic128Rsa15, Basic256, Basic256Sha256",
          "required": false,
          "default": "",
          "examples": [
            "",
            "None",
            "Basic256",
            "Basic256Sha256"
          ],
          "advanced": true
        },
        "serverCertificateFingerprint": {
          "name": "serverCertificateFingerprint",
          "type": "string",
          "kind": "scalar",
          "description": "The server certificate fingerprint to verify, SHA3-512 hash.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "sessionTimeout": {
          "name": "sessionTimeout",
          "type": "int",
          "kind": "scalar",
          "description": "The duration in milliseconds that a OPC UA session will last. Is used to ensure that older failed sessions will timeout and that we will not get a TooManySession error.",
          "required": true,
          "default": 10000,
          "examples": [
            10000,
            30000,
            60000
          ],
          "advanced": true
        },
        "subscribeEnabled": {
          "name": "subscribeEnabled",
          "type": "bool",
          "kind": "scalar",
          "description": "Set to true to subscribe to OPC UA nodes instead of fetching them every seconds. Default is pulling messages every second (false).",
          "required": true,
          "default": false,
          "examples": [
            true,
            false
          ]
        },
        "useHeartbeat": {
          "name": "useHeartbeat",
          "type": "bool",
          "kind": "scalar",
          "description": "Set to true to provide an extra message with the servers timestamp as a heartbeat",
          "required": false,
          "default": false,
          "examples": [
            true,
            false
          ],
          "advanced": true
        },
        "userCertificate": {
          "name": "userCertificate",
          "type": "string",
          "kind": "scalar",
          "description": "User certificate in base64 encoded format of either PEM or DER.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "userPrivateKey": {
          "name": "userPrivateKey",
          "type": "string",
          "kind": "scalar",
          "description": "User private key in base64 format of PEM for user certificate based authentication.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "username": {
          "name": "username",
          "type": "string",
          "kind": "scalar",
          "description": "The username for authentication.",
          "required": false,
          "default": "",
          "examples": [
            "",
            "admin",
            "opcuser"
          ],
          "advanced": true
        }
      }
    },
    "parquet": {
      "name": "parquet",
      "type": "input",
      "source": "upstream",
      "summary": "Reads and decodes https://parquet.apache.org/docs/[Parquet files^] into a stream of structured messages.",
      "description": "\nThis input uses https://github.com/parquet-go/parquet-go[https://github.com/parquet-go/parquet-go^], which is itself experimental. Therefore changes could be made into how this processor functions outside of major version releases.\n\nBy default any BYTE_ARRAY or FIXED_LEN_BYTE_ARRAY value will be extracted as a byte slice (`[]byte`) unless the logical type is UTF8, in which case they are extracted as a string (`string`).\n\nWhen a value extracted as a byte slice exists within a document which is later JSON serialized by default it will be base 64 encoded into strings, which is the default for arbitrary data fields. It is possible to convert these binary values to strings (or other data types) using Bloblang transformations such as `root.foo = this.foo.string()` or `root.foo = this.foo.encode(\"hex\")`, etc.",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "batch_count": {
          "name": "batch_count",
          "type": "int",
          "kind": "scalar",
          "description": "Optionally process records in batches. This can help to speed up the consumption of exceptionally large files. When the end of the file is reached the remaining records are processed as a (potentially smaller) batch.",
          "required": true,
          "default": 1,
          "advanced": true
        },
        "paths": {
          "name": "paths",
          "type": "string",
          "kind": "array",
          "description": "A list of file paths to read from. Each file will be read sequentially until the list is exhausted, at which point the input will close. Glob patterns are supported, including super globs (double star).",
          "required": true,
          "default": null,
          "examples": [
            "/tmp/foo.parquet",
            "/tmp/bar/*.parquet",
            "/tmp/data/**/*.parquet"
          ]
        }
      }
    },
    "pulsar": {
      "name": "pulsar",
      "type": "input",
      "source": "upstream",
      "summary": "Reads messages from an Apache Pulsar server.",
      "description": "\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n```text\n- pulsar_message_id\n- pulsar_key\n- pulsar_ordering_key\n- pulsar_event_time_unix\n- pulsar_publish_time_unix\n- pulsar_topic\n- pulsar_producer_name\n- pulsar_redelivery_count\n- All properties of the message\n```\n\nYou can access these metadata fields using\nxref:configuration:interpolation.adoc#bloblang-queries[function interpolation].\n",
      "config": {
        "auth": {
          "name": "auth",
          "type": "object",
          "kind": "scalar",
          "description": "Optional configuration of Pulsar authentication methods.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "oauth2",
              "type": "object",
              "kind": "scalar",
              "description": "Parameters for Pulsar OAuth2 authentication.",
              "required": false,
              "default": null,
              "advanced": true,
              "children": [
                {
                  "name": "enabled",
                  "type": "bool",
                  "kind": "scalar",
                  "description": "Whether OAuth2 is enabled.",
                  "required": true,
                  "default": false,
                  "advanced": true
                },
                {
                  "name": "audience",
                  "type": "string",
                  "kind": "scalar",
                  "description": "OAuth2 audience.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "issuer_url",
                  "type": "string",
                  "kind": "scalar",
                  "description": "OAuth2 issuer URL.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "scope",
                  "type": "string",
                  "kind": "scalar",
                  "description": "OAuth2 scope to request.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "private_key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path to a file containing a private key.",
                  "required": true,
                  "default": "",
                  "advanced": true
                }
              ]
            },
            {
              "name": "token",
              "type": "object",
              "kind": "scalar",
              "description": "Parameters for Pulsar Token authentication.",
              "required": false,
              "default": null,
              "advanced": true,
              "children": [
                {
                  "name": "enabled",
                  "type": "bool",
                  "kind": "scalar",
                  "description": "Whether Token Auth is enabled.",
                  "required": true,
                  "default": false,
                  "advanced": true
                },
                {
                  "name": "token",
                  "type": "string",
                  "kind": "scalar",
                  "description": "Actual base64 encoded token.",
                  "required": true,
                  "default": "",
                  "advanced": true
                }
              ]
            }
          ]
        },
        "subscription_initial_position": {
          "name": "subscription_initial_position",
          "type": "string",
          "kind": "scalar",
          "description": "Specify the subscription initial position for this consumer.",
          "required": true,
          "default": "latest",
          "options": [
            "latest",
            "earliest"
          ]
        },
        "subscription_name": {
          "name": "subscription_name",
          "type": "string",
          "kind": "scalar",
          "description": "Specify the subscription name for this consumer.",
          "required": true,
          "default": null
        },
        "subscription_type": {
          "name": "subscription_type",
          "type": "string",
          "kind": "scalar",
          "description": "Specify the subscription type for this consumer.\n\n\u003e NOTE: Using a `key_shared` subscription type will __allow out-of-order delivery__ since nack-ing messages sets non-zero nack delivery delay - this can potentially cause consumers to stall. See https://pulsar.apache.org/docs/en/2.8.1/concepts-messaging/#negative-acknowledgement[Pulsar documentation^] and https://github.com/apache/pulsar/issues/12208[this Github issue^] for more details.",
          "required": true,
          "default": "shared",
          "options": [
            "shared",
            "key_shared",
            "failover",
            "exclusive"
          ]
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Specify the path to a custom CA certificate to trust broker TLS service.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ]
            }
          ]
        },
        "topics": {
          "name": "topics",
          "type": "string",
          "kind": "array",
          "description": "A list of topics to subscribe to. This or topics_pattern must be set.",
          "required": false,
          "default": null
        },
        "topics_pattern": {
          "name": "topics_pattern",
          "type": "string",
          "kind": "scalar",
          "description": "A regular expression matching the topics to subscribe to. This or topics must be set.",
          "required": false,
          "default": null
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "A URL to connect to.",
          "required": true,
          "default": null,
          "examples": [
            "pulsar://localhost:6650",
            "pulsar://pulsar.us-west.example.com:6650",
            "pulsar+ssl://pulsar.us-west.example.com:6651"
          ]
        }
      }
    },
    "read_until": {
      "name": "read_until",
      "type": "input",
      "source": "upstream",
      "summary": "Reads messages from a child input until a consumed message passes a xref:guides:bloblang/about.adoc[Bloblang query], at which point the input closes. It is also possible to configure a timeout after which the input is closed if no new messages arrive in that period.",
      "description": "\nMessages are read continuously while the query check returns false, when the query returns true the message that triggered the check is sent out and the input is closed. Use this to define inputs where the stream should end once a certain message appears.\n\nIf the idle timeout is configured, the input will be closed if no new messages arrive after that period of time. Use this field if you want to empty out and close an input that doesn't have a logical end.\n\nSometimes inputs close themselves. For example, when the `file` input type reaches the end of a file it will shut down. By default this type will also shut down. If you wish for the input type to be restarted every time it shuts down until the query check is met then set `restart_input` to `true`.\n\n== Metadata\n\nA metadata key `benthos_read_until` containing the value `final` is added to the first part of the message that triggers the input to stop.",
      "config": {
        "check": {
          "name": "check",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether the input should now be closed.",
          "required": false,
          "default": null,
          "examples": [
            "this.type == \"foo\"",
            "count(\"messages\") \u003e= 100"
          ]
        },
        "idle_timeout": {
          "name": "idle_timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum amount of time without receiving new messages after which the input is closed.",
          "required": false,
          "default": null,
          "examples": [
            "5s"
          ]
        },
        "input": {
          "name": "input",
          "type": "input",
          "kind": "scalar",
          "description": "The child input to consume from.",
          "required": true,
          "default": null
        },
        "restart_input": {
          "name": "restart_input",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether the input should be reopened if it closes itself before the condition has resolved to true.",
          "required": true,
          "default": false
        }
      }
    },
    "redis_list": {
      "name": "redis_list",
      "type": "input",
      "source": "upstream",
      "summary": "Pops messages from the beginning of a Redis list using the BLPop command.",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "command": {
          "name": "command",
          "type": "string",
          "kind": "scalar",
          "description": "The command used to pop elements from the Redis list",
          "required": true,
          "default": "blpop",
          "options": [
            "blpop",
            "brpop"
          ],
          "advanced": true
        },
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "The key of a list to read from.",
          "required": true,
          "default": null
        },
        "kind": {
          "name": "kind",
          "type": "string",
          "kind": "scalar",
          "description": "Specifies a simple, cluster-aware, or failover-aware redis client.",
          "required": true,
          "default": "simple",
          "options": [
            "simple",
            "cluster",
            "failover"
          ],
          "advanced": true
        },
        "master": {
          "name": "master",
          "type": "string",
          "kind": "scalar",
          "description": "Name of the redis master when `kind` is `failover`",
          "required": true,
          "default": "",
          "examples": [
            "mymaster"
          ],
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "Optionally sets a limit on the number of messages that can be flowing through a Redpanda Connect stream pending acknowledgment from the input at any given time. Once a message has been either acknowledged or rejected (nacked) it is no longer considered pending. If the input produces logical batches then each batch is considered a single count against the maximum. **WARNING**: Batching policies at the output level will stall if this field limits the number of messages below the batching threshold. Zero (default) or lower implies no limit.",
          "required": true,
          "default": 0,
          "advanced": true
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The length of time to poll for new messages before reattempting.",
          "required": true,
          "default": "5s",
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.\n\n**Troubleshooting**\n\nSome cloud hosted instances of Redis (such as Azure Cache) might need some hand holding in order to establish stable connections. Unfortunately, it is often the case that TLS issues will manifest as generic error messages such as \"i/o timeout\". If you're using TLS and are seeing connectivity problems consider setting `enable_renegotiation` to `true`, and ensuring that the server supports at least TLS version 1.2.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL of the target Redis server. Database is optional and is supplied as the URL path.",
          "required": true,
          "default": null,
          "examples": [
            "redis://:6379",
            "redis://localhost:6379",
            "redis://foousername:foopassword@redisplace:6379",
            "redis://:foopassword@redisplace:6379",
            "redis://localhost:6379/1",
            "redis://localhost:6379/1,redis://localhost:6380/1"
          ]
        }
      }
    },
    "redis_pubsub": {
      "name": "redis_pubsub",
      "type": "input",
      "source": "upstream",
      "summary": "Consume from a Redis publish/subscribe channel using either the SUBSCRIBE or PSUBSCRIBE commands.",
      "description": "\nIn order to subscribe to channels using the `PSUBSCRIBE` command set the field `use_patterns` to `true`, then you can include glob-style patterns in your channel names. For example:\n\n- `h?llo` subscribes to hello, hallo and hxllo\n- `h*llo` subscribes to hllo and heeeello\n- `h[ae]llo` subscribes to hello and hallo, but not hillo\n\nUse `\\` to escape special characters if you want to match them verbatim.",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "channels": {
          "name": "channels",
          "type": "string",
          "kind": "array",
          "description": "A list of channels to consume from.",
          "required": true,
          "default": null
        },
        "kind": {
          "name": "kind",
          "type": "string",
          "kind": "scalar",
          "description": "Specifies a simple, cluster-aware, or failover-aware redis client.",
          "required": true,
          "default": "simple",
          "options": [
            "simple",
            "cluster",
            "failover"
          ],
          "advanced": true
        },
        "master": {
          "name": "master",
          "type": "string",
          "kind": "scalar",
          "description": "Name of the redis master when `kind` is `failover`",
          "required": true,
          "default": "",
          "examples": [
            "mymaster"
          ],
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.\n\n**Troubleshooting**\n\nSome cloud hosted instances of Redis (such as Azure Cache) might need some hand holding in order to establish stable connections. Unfortunately, it is often the case that TLS issues will manifest as generic error messages such as \"i/o timeout\". If you're using TLS and are seeing connectivity problems consider setting `enable_renegotiation` to `true`, and ensuring that the server supports at least TLS version 1.2.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL of the target Redis server. Database is optional and is supplied as the URL path.",
          "required": true,
          "default": null,
          "examples": [
            "redis://:6379",
            "redis://localhost:6379",
            "redis://foousername:foopassword@redisplace:6379",
            "redis://:foopassword@redisplace:6379",
            "redis://localhost:6379/1",
            "redis://localhost:6379/1,redis://localhost:6380/1"
          ]
        },
        "use_patterns": {
          "name": "use_patterns",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to use the PSUBSCRIBE command, allowing for glob-style patterns within target channel names.",
          "required": true,
          "default": false
        }
      }
    },
    "redis_scan": {
      "name": "redis_scan",
      "type": "input",
      "source": "upstream",
      "summary": "Scans the set of keys in the current selected database and gets their values, using the Scan and Get commands.",
      "description": "Optionally, iterates only elements matching a blob-style pattern. For example:\n\n- `*foo*` iterates only keys which contain `foo` in it.\n- `foo*` iterates only keys starting with `foo`.\n\nThis input generates a message for each key value pair in the following format:\n\n```json\n{\"key\":\"foo\",\"value\":\"bar\"}\n```\n",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "kind": {
          "name": "kind",
          "type": "string",
          "kind": "scalar",
          "description": "Specifies a simple, cluster-aware, or failover-aware redis client.",
          "required": true,
          "default": "simple",
          "options": [
            "simple",
            "cluster",
            "failover"
          ],
          "advanced": true
        },
        "master": {
          "name": "master",
          "type": "string",
          "kind": "scalar",
          "description": "Name of the redis master when `kind` is `failover`",
          "required": true,
          "default": "",
          "examples": [
            "mymaster"
          ],
          "advanced": true
        },
        "match": {
          "name": "match",
          "type": "string",
          "kind": "scalar",
          "description": "Iterates only elements matching the optional glob-style pattern. By default, it matches all elements.",
          "required": true,
          "default": "",
          "examples": [
            "*",
            "1*",
            "foo*",
            "foo",
            "*4*"
          ]
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.\n\n**Troubleshooting**\n\nSome cloud hosted instances of Redis (such as Azure Cache) might need some hand holding in order to establish stable connections. Unfortunately, it is often the case that TLS issues will manifest as generic error messages such as \"i/o timeout\". If you're using TLS and are seeing connectivity problems consider setting `enable_renegotiation` to `true`, and ensuring that the server supports at least TLS version 1.2.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL of the target Redis server. Database is optional and is supplied as the URL path.",
          "required": true,
          "default": null,
          "examples": [
            "redis://:6379",
            "redis://localhost:6379",
            "redis://foousername:foopassword@redisplace:6379",
            "redis://:foopassword@redisplace:6379",
            "redis://localhost:6379/1",
            "redis://localhost:6379/1,redis://localhost:6380/1"
          ]
        }
      }
    },
    "redis_streams": {
      "name": "redis_streams",
      "type": "input",
      "source": "upstream",
      "summary": "Pulls messages from Redis (v5.0+) streams with the XREADGROUP command. The `client_id` should be unique for each consumer of a group.",
      "description": "Redis stream entries are key/value pairs, as such it is necessary to specify the key that contains the body of the message. All other keys/value pairs are saved as metadata fields.",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "body_key": {
          "name": "body_key",
          "type": "string",
          "kind": "scalar",
          "description": "The field key to extract the raw message from. All other keys will be stored in the message as metadata.",
          "required": true,
          "default": "body"
        },
        "client_id": {
          "name": "client_id",
          "type": "string",
          "kind": "scalar",
          "description": "An identifier for the client connection.",
          "required": true,
          "default": ""
        },
        "commit_period": {
          "name": "commit_period",
          "type": "string",
          "kind": "scalar",
          "description": "The period of time between each commit of the current offset. Offsets are always committed during shutdown.",
          "required": true,
          "default": "1s",
          "advanced": true
        },
        "consumer_group": {
          "name": "consumer_group",
          "type": "string",
          "kind": "scalar",
          "description": "An identifier for the consumer group of the stream.",
          "required": true,
          "default": ""
        },
        "create_streams": {
          "name": "create_streams",
          "type": "bool",
          "kind": "scalar",
          "description": "Create subscribed streams if they do not exist (MKSTREAM option).",
          "required": true,
          "default": true,
          "advanced": true
        },
        "kind": {
          "name": "kind",
          "type": "string",
          "kind": "scalar",
          "description": "Specifies a simple, cluster-aware, or failover-aware redis client.",
          "required": true,
          "default": "simple",
          "options": [
            "simple",
            "cluster",
            "failover"
          ],
          "advanced": true
        },
        "limit": {
          "name": "limit",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to consume from a single request.",
          "required": true,
          "default": 10
        },
        "master": {
          "name": "master",
          "type": "string",
          "kind": "scalar",
          "description": "Name of the redis master when `kind` is `failover`",
          "required": true,
          "default": "",
          "examples": [
            "mymaster"
          ],
          "advanced": true
        },
        "start_from_oldest": {
          "name": "start_from_oldest",
          "type": "bool",
          "kind": "scalar",
          "description": "If an offset is not found for a stream, determines whether to consume from the oldest available offset, otherwise messages are consumed from the latest offset.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "streams": {
          "name": "streams",
          "type": "string",
          "kind": "array",
          "description": "A list of streams to consume from.",
          "required": true,
          "default": null
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The length of time to poll for new messages before reattempting.",
          "required": true,
          "default": "1s",
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.\n\n**Troubleshooting**\n\nSome cloud hosted instances of Redis (such as Azure Cache) might need some hand holding in order to establish stable connections. Unfortunately, it is often the case that TLS issues will manifest as generic error messages such as \"i/o timeout\". If you're using TLS and are seeing connectivity problems consider setting `enable_renegotiation` to `true`, and ensuring that the server supports at least TLS version 1.2.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL of the target Redis server. Database is optional and is supplied as the URL path.",
          "required": true,
          "default": null,
          "examples": [
            "redis://:6379",
            "redis://localhost:6379",
            "redis://foousername:foopassword@redisplace:6379",
            "redis://:foopassword@redisplace:6379",
            "redis://localhost:6379/1",
            "redis://localhost:6379/1,redis://localhost:6380/1"
          ]
        }
      }
    },
    "redpanda": {
      "name": "redpanda",
      "type": "input",
      "source": "upstream",
      "summary": "A Kafka input using the https://github.com/twmb/franz-go[Franz Kafka client library^].",
      "description": "\nWhen a consumer group is specified this input consumes one or more topics where partitions will automatically balance across any other connected clients with the same consumer group. When a consumer group is not specified topics can either be consumed in their entirety or with explicit partitions.\n\n== Delivery Guarantees\n\nWhen using consumer groups the offsets of \"delivered\" records will be committed automatically and continuously, and in the event of restarts these committed offsets will be used in order to resume from where the input left off. Redpanda Connect guarantees at least once delivery by ensuring that records are only considerd to be delivered when all configured outputs that the record is routed to have confirmed delivery.\n\n== Ordering\n\nIn order to preserve ordering of topic partitions, records consumed from each partition are processed and delivered in the order that they are received, and only one batch of records of a given partition will ever be processed at a time. This means that parallel processing can only occur when multiple topic partitions are being consumed, but ensures that data is processed in a sequential order as determined from the source partition.\n\nHowever, one way in which the order of records can be mixed is when delivery errors occur and error handling mechanisms kick in. Redpanda Connect always leans towards at least once delivery unless instructed otherwise, and this includes reattempting delivery of data when the ordering of that data can no longer be guaranteed.\n\nFor example, a batch of records may have been sent to an output broker and only a subset of records were delivered, in this case Redpanda Connect by default will reattempt to deliver the records that failed, even though these failed records may have come before records that were previously delivered successfully.\n\nIn order to avoid this scenario you must specify in your configuration an alternative way to handle delivery errors in the form of a xref:components:outputs/fallback.adoc[`fallback`] output. It is good practice to also disable the field `auto_retry_nacks` by setting it to `false` when you've added an explicit fallback output as this will improve the throughput of your pipeline. For example, the following config avoids ordering issues by specifying a fallback output into a DLQ topic, which is also retried indefinitely as a way to apply back pressure during connectivity issues:\n\n```yaml\noutput:\n  fallback:\n    - redpanda:\n        seed_brokers: [ localhost:9092 ]\n        topic: foo\n    - retry:\n        output:\n          redpanda:\n            seed_brokers: [ localhost:9092 ]\n            topic: foo_dlq\n```\n\n== Batching\n\nRecords are processed and delivered from each partition in batches as received from brokers. These batch sizes are therefore dynamically sized in order to optimise throughput, but can be tuned with the config fields `fetch_max_partition_bytes` and `fetch_max_bytes`. Batches can be further broken down using the xref:components:processors/split.adoc[`split`] processor.\n\n== Metrics\n\nEmits a `redpanda_lag` metric with `topic` and `partition` labels for each consumed topic.\n\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n```text\n- kafka_key\n- kafka_topic\n- kafka_partition\n- kafka_offset\n- kafka_lag\n- kafka_timestamp_ms\n- kafka_timestamp_unix\n- kafka_tombstone_message\n- All record headers\n```\n",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "client_id": {
          "name": "client_id",
          "type": "string",
          "kind": "scalar",
          "description": "An identifier for the client connection.",
          "required": true,
          "default": "benthos",
          "advanced": true
        },
        "commit_period": {
          "name": "commit_period",
          "type": "string",
          "kind": "scalar",
          "description": "The period of time between each commit of the current partition offsets. Offsets are always committed during shutdown.",
          "required": true,
          "default": "5s",
          "advanced": true
        },
        "consumer_group": {
          "name": "consumer_group",
          "type": "string",
          "kind": "scalar",
          "description": "An optional consumer group to consume as. When specified the partitions of specified topics are automatically distributed across consumers sharing a consumer group, and partition offsets are automatically committed and resumed under this name. Consumer groups are not supported when specifying explicit partitions to consume from in the `topics` field.",
          "required": false,
          "default": null
        },
        "fetch_max_bytes": {
          "name": "fetch_max_bytes",
          "type": "string",
          "kind": "scalar",
          "description": "Sets the maximum amount of bytes a broker will try to send during a fetch. Note that brokers may not obey this limit if it has records larger than this limit. This is the equivalent to the Java fetch.max.bytes setting.",
          "required": true,
          "default": "50MiB",
          "advanced": true
        },
        "fetch_max_partition_bytes": {
          "name": "fetch_max_partition_bytes",
          "type": "string",
          "kind": "scalar",
          "description": "Sets the maximum amount of bytes that will be consumed for a single partition in a fetch request. Note that if a single batch is larger than this number, that batch will still be returned so the client can make progress. This is the equivalent to the Java fetch.max.partition.bytes setting.",
          "required": true,
          "default": "1MiB",
          "advanced": true
        },
        "fetch_max_wait": {
          "name": "fetch_max_wait",
          "type": "string",
          "kind": "scalar",
          "description": "Sets the maximum amount of time a broker will wait for a fetch response to hit the minimum number of required bytes. This is the equivalent to the Java fetch.max.wait.ms setting.",
          "required": true,
          "default": "5s",
          "advanced": true
        },
        "fetch_min_bytes": {
          "name": "fetch_min_bytes",
          "type": "string",
          "kind": "scalar",
          "description": "Sets the minimum amount of bytes a broker will try to send during a fetch. This is the equivalent to the Java fetch.min.bytes setting.",
          "required": true,
          "default": "1B",
          "advanced": true
        },
        "heartbeat_interval": {
          "name": "heartbeat_interval",
          "type": "string",
          "kind": "scalar",
          "description": "When using a consumer group, `heartbeat_interval` sets how long a group member goes between heartbeats to Kafka. Kafka uses heartbeats to ensure that a group member's sesion stays active. This value should be no higher than 1/3rd of the `session_timeout`. This is equivalent to the Java heartbeat.interval.ms setting.",
          "required": true,
          "default": "3s",
          "advanced": true
        },
        "instance_id": {
          "name": "instance_id",
          "type": "string",
          "kind": "scalar",
          "description": "When using a consumer group, an instance ID specifies the groups static membership, which can prevent rebalances during reconnects. When using a instance ID the client does NOT leave the group when closing. To actually leave the group one must use an external admin command to leave the group on behalf of this instance ID. This ID must be unique per consumer within the group.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "metadata_max_age": {
          "name": "metadata_max_age",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum age of metadata before it is refreshed.",
          "required": true,
          "default": "5m",
          "advanced": true
        },
        "partition_buffer_bytes": {
          "name": "partition_buffer_bytes",
          "type": "string",
          "kind": "scalar",
          "description": "A buffer size (in bytes) for each consumed partition, allowing records to be queued internally before flushing. Increasing this may improve throughput at the cost of higher memory utilisation. Note that each buffer can grow slightly beyond this value.",
          "required": true,
          "default": "1MB",
          "advanced": true
        },
        "rack_id": {
          "name": "rack_id",
          "type": "string",
          "kind": "scalar",
          "description": "A rack specifies where the client is physically located and changes fetch requests to consume from the closest replica as opposed to the leader replica.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "rebalance_timeout": {
          "name": "rebalance_timeout",
          "type": "string",
          "kind": "scalar",
          "description": "When using a consumer group, `rebalance_timeout` sets how long group members are allowed to take when a rebalance has begun. This timeout is how long all members are allowed to complete work and commit offsets, minus the time it took to detect the rebalance (from a heartbeat).",
          "required": true,
          "default": "45s",
          "advanced": true
        },
        "regexp_topics": {
          "name": "regexp_topics",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether listed topics should be interpreted as regular expression patterns for matching multiple topics. When topics are specified with explicit partitions this field must remain set to `false`.",
          "required": true,
          "default": false
        },
        "sasl": {
          "name": "sasl",
          "type": "object",
          "kind": "array",
          "description": "Specify one or more methods of SASL authentication. SASL is tried in order; if the broker supports the first mechanism, all connections will use that mechanism. If the first mechanism fails, the client will pick the first supported mechanism. If the broker does not support any client mechanisms, connections will fail.",
          "required": false,
          "default": null,
          "examples": [
            [
              {
                "mechanism": "SCRAM-SHA-512",
                "password": "bar",
                "username": "foo"
              }
            ]
          ],
          "advanced": true,
          "children": [
            {
              "name": "mechanism",
              "type": "string",
              "kind": "scalar",
              "description": "The SASL mechanism to use.",
              "required": true,
              "default": null,
              "advanced": true
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "A username to provide for PLAIN or SCRAM-* authentication.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A password to provide for PLAIN or SCRAM-* authentication.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token",
              "type": "string",
              "kind": "scalar",
              "description": "The token to use for a single session's OAUTHBEARER authentication.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "extensions",
              "type": "string",
              "kind": "map",
              "description": "Key/value pairs to add to OAUTHBEARER authentication requests.",
              "required": false,
              "default": null,
              "advanced": true
            },
            {
              "name": "aws",
              "type": "object",
              "kind": "scalar",
              "description": "Contains AWS specific fields for when the `mechanism` is set to `AWS_MSK_IAM`.",
              "required": false,
              "default": null,
              "advanced": true,
              "children": [
                {
                  "name": "region",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The AWS region to target.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "endpoint",
                  "type": "string",
                  "kind": "scalar",
                  "description": "Allows you to specify a custom endpoint for the AWS API.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "credentials",
                  "type": "object",
                  "kind": "scalar",
                  "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
                  "required": true,
                  "default": null,
                  "advanced": true,
                  "children": [
                    {
                      "name": "profile",
                      "type": "string",
                      "kind": "scalar",
                      "description": "A profile from `~/.aws/credentials` to use.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "id",
                      "type": "string",
                      "kind": "scalar",
                      "description": "The ID of credentials to use.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "secret",
                      "type": "string",
                      "kind": "scalar",
                      "description": "The secret for the credentials being used.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "token",
                      "type": "string",
                      "kind": "scalar",
                      "description": "The token for the credentials being used, required when using short term credentials.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "from_ec2_role",
                      "type": "bool",
                      "kind": "scalar",
                      "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
                      "required": true,
                      "default": false,
                      "advanced": true
                    },
                    {
                      "name": "role",
                      "type": "string",
                      "kind": "scalar",
                      "description": "A role ARN to assume.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "role_external_id",
                      "type": "string",
                      "kind": "scalar",
                      "description": "An external ID to provide when assuming a role.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        "seed_brokers": {
          "name": "seed_brokers",
          "type": "string",
          "kind": "array",
          "description": "A list of broker addresses to connect to in order to establish connections. If an item of the list contains commas it will be expanded into multiple addresses.",
          "required": true,
          "default": null,
          "examples": [
            [
              "localhost:9092"
            ],
            [
              "foo:9092",
              "bar:9092"
            ],
            [
              "foo:9092,bar:9092"
            ]
          ]
        },
        "session_timeout": {
          "name": "session_timeout",
          "type": "string",
          "kind": "scalar",
          "description": "When using a consumer group, `session_timeout` sets how long a member in hte group can go between heartbeats. If a member does not heartbeat in this timeout, the broker will remove the member from the group and initiate a rebalance.",
          "required": true,
          "default": "1m",
          "advanced": true
        },
        "start_from_oldest": {
          "name": "start_from_oldest",
          "type": "bool",
          "kind": "scalar",
          "description": "Determines whether to consume from the oldest available offset, otherwise messages are consumed from the latest offset. The setting is applied when creating a new consumer group or the saved offset no longer exists.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "topic_lag_refresh_period": {
          "name": "topic_lag_refresh_period",
          "type": "string",
          "kind": "scalar",
          "description": "The period of time between each topic lag refresh cycle.",
          "required": true,
          "default": "5s",
          "advanced": true
        },
        "topics": {
          "name": "topics",
          "type": "string",
          "kind": "array",
          "description": "\nA list of topics to consume from. Multiple comma separated topics can be listed in a single element. When a `consumer_group` is specified partitions are automatically distributed across consumers of a topic, otherwise all partitions are consumed.\n\nAlternatively, it's possible to specify explicit partitions to consume from with a colon after the topic name, e.g. `foo:0` would consume the partition 0 of the topic foo. This syntax supports ranges, e.g. `foo:0-10` would consume partitions 0 through to 10 inclusive.\n\nFinally, it's also possible to specify an explicit offset to consume from by adding another colon after the partition, e.g. `foo:0:10` would consume the partition 0 of the topic foo starting from the offset 10. If the offset is not present (or remains unspecified) then the field `start_from_oldest` determines which offset to start from.",
          "required": true,
          "default": null,
          "examples": [
            [
              "foo",
              "bar"
            ],
            [
              "things.*"
            ],
            [
              "foo,bar"
            ],
            [
              "foo:0",
              "bar:1",
              "bar:3"
            ],
            [
              "foo:0,bar:1,bar:3"
            ],
            [
              "foo:0-5"
            ]
          ]
        }
      }
    },
    "resource": {
      "name": "resource",
      "type": "input",
      "source": "upstream",
      "summary": "Resource is an input type that channels messages from a resource input, identified by its name.",
      "description": "Resources allow you to tidy up deeply nested configs. For example, the config:\n\n```yaml\ninput:\n  broker:\n    inputs:\n      - kafka:\n          addresses: [ TODO ]\n          topics: [ foo ]\n          consumer_group: foogroup\n      - gcp_pubsub:\n          project: bar\n          subscription: baz\n```\n\nCould also be expressed as:\n\n```yaml\ninput:\n  broker:\n    inputs:\n      - resource: foo\n      - resource: bar\n\ninput_resources:\n  - label: foo\n    kafka:\n      addresses: [ TODO ]\n      topics: [ foo ]\n      consumer_group: foogroup\n\n  - label: bar\n    gcp_pubsub:\n      project: bar\n      subscription: baz\n```\n\nResources also allow you to reference a single input in multiple places, such as multiple streams mode configs, or multiple entries in a broker input. However, when a resource is referenced more than once the messages it produces are distributed across those references, so each message will only be directed to a single reference, not all of them.\n\nYou can find out more about resources in xref:configuration:resources.adoc[].",
      "config": {}
    },
    "s7comm": {
      "name": "s7comm",
      "type": "input",
      "source": "benthos-umh",
      "summary": "Creates an input that reads data from Siemens S7 PLCs. Created \u0026 maintained by the United Manufacturing Hub. About us: www.umh.app",
      "description": "This input plugin enables Benthos to read data directly from Siemens S7 PLCs using the S7comm protocol. Configure the plugin by specifying the PLC's IP address, rack and slot numbers, and the data blocks to read.",
      "config": {
        "addresses": {
          "name": "addresses",
          "type": "string",
          "kind": "array",
          "description": "Format: '\u003carea\u003e.\u003ctype\u003e\u003caddress\u003e[.extra]'. Examples: 'DB5.X3.2' (bit), 'DB5.B3' (byte), 'DB5.C3' (character). Direct area access (DB1 = data block 1). Data types: X (bit), B (byte), W (word), DW (double word).",
          "required": true,
          "default": null,
          "examples": [
            [
              "DB1.DW20",
              "DB1.S30.10"
            ],
            [
              "DB1.DBW0"
            ],
            [
              "DB1.DBW0",
              "DB3.DBX270.5"
            ],
            [
              "DB5.DBB3",
              "DB10.DBD20"
            ]
          ]
        },
        "batchMaxSize": {
          "name": "batchMaxSize",
          "type": "int",
          "kind": "scalar",
          "description": "Maximum count of addresses to be bundled in one batch-request (PDU size).",
          "required": false,
          "default": 480,
          "examples": [
            480,
            100,
            960
          ],
          "advanced": true
        },
        "disableCPUInfo": {
          "name": "disableCPUInfo",
          "type": "bool",
          "kind": "scalar",
          "description": "Set this to true to not fetch CPU information from the PLC. Should be used when you get the error 'Failed to get CPU information'",
          "required": false,
          "default": false,
          "examples": [
            false,
            true
          ],
          "advanced": true
        },
        "rack": {
          "name": "rack",
          "type": "int",
          "kind": "scalar",
          "description": "Rack number of the PLC. Identifies the physical location of the CPU within the PLC rack.",
          "required": false,
          "default": 0,
          "examples": [
            0,
            1,
            2
          ]
        },
        "slot": {
          "name": "slot",
          "type": "int",
          "kind": "scalar",
          "description": "Slot number of the PLC. Identifies the CPU slot within the rack.",
          "required": false,
          "default": 1,
          "examples": [
            1,
            2,
            3
          ]
        },
        "tcpDevice": {
          "name": "tcpDevice",
          "type": "string",
          "kind": "scalar",
          "description": "IP address of the S7 PLC.",
          "required": true,
          "default": null,
          "examples": [
            "{{ .IP }}",
            "192.168.1.100",
            "10.0.0.50",
            "plc.local"
          ]
        },
        "timeout": {
          "name": "timeout",
          "type": "int",
          "kind": "scalar",
          "description": "The timeout duration in seconds for connection attempts and read requests.",
          "required": false,
          "default": 10,
          "examples": [
            10,
            5,
            30
          ],
          "advanced": true
        }
      }
    },
    "sensorconnect": {
      "name": "sensorconnect",
      "type": "input",
      "source": "benthos-umh",
      "summary": "An input plugin that discovers devices and collects sensor data.",
      "description": "This plugin replaces the 'sensorconnect' microservice as a Benthos plugin.",
      "config": {
        "device_address": {
          "name": "device_address",
          "type": "string",
          "kind": "scalar",
          "description": "IP address or hostname of the IFM IO-Link master device",
          "required": true,
          "default": null
        },
        "devices": {
          "name": "devices",
          "type": "object",
          "kind": "array",
          "description": "List of devices with specific configuration options",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "device_id",
              "type": "int",
              "kind": "scalar",
              "description": "The device ID of the IO-Link device",
              "required": true,
              "default": null,
              "examples": [
                509
              ]
            },
            {
              "name": "vendor_id",
              "type": "int",
              "kind": "scalar",
              "description": "The vendor ID of the IO-Link device",
              "required": true,
              "default": null,
              "examples": [
                2035
              ]
            },
            {
              "name": "iodd_url",
              "type": "string",
              "kind": "scalar",
              "description": "Fallback URL to download the IODD file if not found in the IODD API",
              "required": true,
              "default": null,
              "examples": [
                "https://yourserver.com/iodd/KEYENCE-FD-EPA1-20230410-IODD1.1.xml"
              ]
            }
          ]
        },
        "iodd_api": {
          "name": "iodd_api",
          "type": "string",
          "kind": "scalar",
          "description": "URL of the IODD API",
          "required": true,
          "default": "https://management.umh.app/iodd"
        }
      }
    },
    "sequence": {
      "name": "sequence",
      "type": "input",
      "source": "upstream",
      "summary": "Reads messages from a sequence of child inputs, starting with the first and once that input gracefully terminates starts consuming from the next, and so on.",
      "description": "This input is useful for consuming from inputs that have an explicit end but must not be consumed in parallel.",
      "config": {
        "inputs": {
          "name": "inputs",
          "type": "input",
          "kind": "array",
          "description": "An array of inputs to read from sequentially.",
          "required": true,
          "default": null
        },
        "sharded_join": {
          "name": "sharded_join",
          "type": "object",
          "kind": "scalar",
          "description": "EXPERIMENTAL: Provides a way to perform outer joins of arbitrarily structured and unordered data resulting from the input sequence, even when the overall size of the data surpasses the memory available on the machine.\n\nWhen configured the sequence of inputs will be consumed one or more times according to the number of iterations, and when more than one iteration is specified each iteration will process an entirely different set of messages by sharding them by the ID field. Increasing the number of iterations reduces the memory consumption at the cost of needing to fully parse the data each time.\n\nEach message must be structured (JSON or otherwise processed into a structured form) and the fields will be aggregated with those of other messages sharing the ID. At the end of each iteration the joined messages are flushed downstream before the next iteration begins, hence keeping memory usage limited.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "type",
              "type": "string",
              "kind": "scalar",
              "description": "The type of join to perform. A `full-outer` ensures that all identifiers seen in any of the input sequences are sent, and is performed by consuming all input sequences before flushing the joined results. An `outer` join consumes all input sequences but only writes data joined from the last input in the sequence, similar to a left or right outer join. With an `outer` join if an identifier appears multiple times within the final sequence input it will be flushed each time it appears. `full-outter` and `outter` have been deprecated in favour of `full-outer` and `outer`.",
              "required": true,
              "default": "none",
              "options": [
                "none",
                "full-outer",
                "outer",
                "full-outter",
                "outter"
              ],
              "advanced": true
            },
            {
              "name": "id_path",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:configuration:field_paths.adoc[dot path] that points to a common field within messages of each fragmented data set and can be used to join them. Messages that are not structured or are missing this field will be dropped. This field must be set in order to enable joins.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "iterations",
              "type": "int",
              "kind": "scalar",
              "description": "The total number of iterations (shards), increasing this number will increase the overall time taken to process the data, but reduces the memory used in the process. The real memory usage required is significantly higher than the real size of the data and therefore the number of iterations should be at least an order of magnitude higher than the available memory divided by the overall size of the dataset.",
              "required": true,
              "default": 1,
              "advanced": true
            },
            {
              "name": "merge_strategy",
              "type": "string",
              "kind": "scalar",
              "description": "The chosen strategy to use when a data join would otherwise result in a collision of field values. The strategy `array` means non-array colliding values are placed into an array and colliding arrays are merged. The strategy `replace` replaces old values with new values. The strategy `keep` keeps the old value.",
              "required": true,
              "default": "array",
              "options": [
                "array",
                "replace",
                "keep"
              ],
              "advanced": true
            }
          ]
        }
      }
    },
    "sftp": {
      "name": "sftp",
      "type": "input",
      "source": "upstream",
      "summary": "Consumes files from an SFTP server.",
      "description": "\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n- sftp_path\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation].",
      "config": {
        "address": {
          "name": "address",
          "type": "string",
          "kind": "scalar",
          "description": "The address of the server to connect to.",
          "required": true,
          "default": null
        },
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "codec": {
          "name": "codec",
          "type": "string",
          "kind": "scalar",
          "description": "The way in which the bytes of a data source should be converted into discrete messages, codecs are useful for specifying how large files or continuous streams of data might be processed in small chunks rather than loading it all in memory. It's possible to consume lines using a custom delimiter with the `delim:x` codec, where x is the character sequence custom delimiter. Codecs can be chained with `/`, for example a gzip compressed CSV file can be consumed with the codec `gzip/csv`.",
          "required": false,
          "default": null,
          "examples": [
            "lines",
            "delim:\t",
            "delim:foobar",
            "gzip/csv"
          ]
        },
        "credentials": {
          "name": "credentials",
          "type": "object",
          "kind": "scalar",
          "description": "The credentials to use to log into the target server.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "The username to connect to the SFTP server.",
              "required": true,
              "default": ""
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "The password for the username to connect to the SFTP server.",
              "required": true,
              "default": ""
            },
            {
              "name": "private_key_file",
              "type": "string",
              "kind": "scalar",
              "description": "The private key for the username to connect to the SFTP server.",
              "required": true,
              "default": ""
            },
            {
              "name": "private_key_pass",
              "type": "string",
              "kind": "scalar",
              "description": "Optional passphrase for private key.",
              "required": true,
              "default": ""
            }
          ]
        },
        "delete_on_finish": {
          "name": "delete_on_finish",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to delete files from the server once they are processed.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "max_buffer": {
          "name": "max_buffer",
          "type": "int",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": 1000000
        },
        "paths": {
          "name": "paths",
          "type": "string",
          "kind": "array",
          "description": "A list of paths to consume sequentially. Glob patterns are supported.",
          "required": true,
          "default": null
        },
        "scanner": {
          "name": "scanner",
          "type": "scanner",
          "kind": "scalar",
          "description": "The xref:components:scanners/about.adoc[scanner] by which the stream of bytes consumed will be broken out into individual messages. Scanners are useful for processing large sources of data without holding the entirety of it within memory. For example, the `csv` scanner allows you to process individual CSV rows without loading the entire CSV file in memory at once.",
          "required": false,
          "default": {
            "to_the_end": {}
          }
        },
        "watcher": {
          "name": "watcher",
          "type": "object",
          "kind": "scalar",
          "description": "An experimental mode whereby the input will periodically scan the target paths for new files and consume them, when all files are consumed the input will continue polling for new files.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether file watching is enabled.",
              "required": true,
              "default": false
            },
            {
              "name": "minimum_age",
              "type": "string",
              "kind": "scalar",
              "description": "The minimum period of time since a file was last updated before attempting to consume it. Increasing this period decreases the likelihood that a file will be consumed whilst it is still being written to.",
              "required": true,
              "default": "1s",
              "examples": [
                "10s",
                "1m",
                "10m"
              ]
            },
            {
              "name": "poll_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The interval between each attempt to scan the target paths for new files.",
              "required": true,
              "default": "1s",
              "examples": [
                "100ms",
                "1s"
              ]
            },
            {
              "name": "cache",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:components:caches/about.adoc[cache resource] for storing the paths of files already consumed.",
              "required": true,
              "default": ""
            }
          ]
        }
      }
    },
    "socket": {
      "name": "socket",
      "type": "input",
      "source": "upstream",
      "summary": "Connects to a tcp or unix socket and consumes a continuous stream of messages.",
      "config": {
        "address": {
          "name": "address",
          "type": "string",
          "kind": "scalar",
          "description": "The address to connect to.",
          "required": true,
          "default": null,
          "examples": [
            "/tmp/benthos.sock",
            "127.0.0.1:6000"
          ]
        },
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "codec": {
          "name": "codec",
          "type": "string",
          "kind": "scalar",
          "description": "The way in which the bytes of a data source should be converted into discrete messages, codecs are useful for specifying how large files or continuous streams of data might be processed in small chunks rather than loading it all in memory. It's possible to consume lines using a custom delimiter with the `delim:x` codec, where x is the character sequence custom delimiter. Codecs can be chained with `/`, for example a gzip compressed CSV file can be consumed with the codec `gzip/csv`.",
          "required": false,
          "default": null,
          "examples": [
            "lines",
            "delim:\t",
            "delim:foobar",
            "gzip/csv"
          ]
        },
        "max_buffer": {
          "name": "max_buffer",
          "type": "int",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": 1000000
        },
        "network": {
          "name": "network",
          "type": "string",
          "kind": "scalar",
          "description": "A network type to assume (unix|tcp).",
          "required": true,
          "default": null,
          "options": [
            "unix",
            "tcp"
          ]
        },
        "scanner": {
          "name": "scanner",
          "type": "scanner",
          "kind": "scalar",
          "description": "The xref:components:scanners/about.adoc[scanner] by which the stream of bytes consumed will be broken out into individual messages. Scanners are useful for processing large sources of data without holding the entirety of it within memory. For example, the `csv` scanner allows you to process individual CSV rows without loading the entire CSV file in memory at once.",
          "required": false,
          "default": {
            "lines": {}
          }
        }
      }
    },
    "socket_server": {
      "name": "socket_server",
      "type": "input",
      "source": "upstream",
      "summary": "Creates a server that receives a stream of messages over a TCP, UDP or Unix socket.",
      "config": {
        "address": {
          "name": "address",
          "type": "string",
          "kind": "scalar",
          "description": "The address to listen from.",
          "required": true,
          "default": null,
          "examples": [
            "/tmp/benthos.sock",
            "0.0.0.0:6000"
          ]
        },
        "address_cache": {
          "name": "address_cache",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:components:caches/about.adoc[`cache`] within which this input should write it's bound address once known. The key of the cache item containing the address will be the label of the component suffixed with `_address` (e.g. `foo_address`), or `socket_server_address` when a label has not been provided. This is useful in situations where the address is dynamically allocated by the server (`127.0.0.1:0`) and you want to store the allocated address somewhere for reference by other systems and components.",
          "required": false,
          "default": null
        },
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "codec": {
          "name": "codec",
          "type": "string",
          "kind": "scalar",
          "description": "The way in which the bytes of a data source should be converted into discrete messages, codecs are useful for specifying how large files or continuous streams of data might be processed in small chunks rather than loading it all in memory. It's possible to consume lines using a custom delimiter with the `delim:x` codec, where x is the character sequence custom delimiter. Codecs can be chained with `/`, for example a gzip compressed CSV file can be consumed with the codec `gzip/csv`.",
          "required": false,
          "default": null,
          "examples": [
            "lines",
            "delim:\t",
            "delim:foobar",
            "gzip/csv"
          ]
        },
        "max_buffer": {
          "name": "max_buffer",
          "type": "int",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": 1000000
        },
        "network": {
          "name": "network",
          "type": "string",
          "kind": "scalar",
          "description": "A network type to accept.",
          "required": true,
          "default": null,
          "options": [
            "unix",
            "tcp",
            "udp",
            "tls"
          ]
        },
        "scanner": {
          "name": "scanner",
          "type": "scanner",
          "kind": "scalar",
          "description": "The xref:components:scanners/about.adoc[scanner] by which the stream of bytes consumed will be broken out into individual messages. Scanners are useful for processing large sources of data without holding the entirety of it within memory. For example, the `csv` scanner allows you to process individual CSV rows without loading the entire CSV file in memory at once.",
          "required": false,
          "default": {
            "lines": {}
          }
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "TLS specific configuration, valid when the `network` is set to `tls`.",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "cert_file",
              "type": "string",
              "kind": "scalar",
              "description": "PEM encoded certificate for use with TLS.",
              "required": false,
              "default": null
            },
            {
              "name": "key_file",
              "type": "string",
              "kind": "scalar",
              "description": "PEM encoded private key for use with TLS.",
              "required": false,
              "default": null
            },
            {
              "name": "self_signed",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to generate self signed certificates.",
              "required": true,
              "default": false
            },
            {
              "name": "client_auth",
              "type": "string",
              "kind": "scalar",
              "description": "How client authentication is handled.",
              "required": true,
              "default": "no"
            }
          ]
        }
      }
    },
    "sparkplug_b": {
      "name": "sparkplug_b",
      "type": "input",
      "source": "benthos-umh",
      "summary": "Sparkplug B MQTT input with idiomatic configuration",
      "description": "A Sparkplug B input plugin with three Host modes:\n\nSPARKPLUG B HOST MODES:\n- secondary_passive (default): Read-only consumer, no rebirth commands, safe for brownfield\n- secondary_active: Active consumer, sends rebirth commands, no STATE publishing\n- primary: Full Primary Host with STATE publishing and session management\n\nKey features:\n- Three-mode system for different deployment scenarios\n- Safe default mode prevents rebirth storms\n- Automatic STATE topic management with LWT (Primary mode only)\n- Sequence number validation and rebirth coordination\n- Alias resolution using BIRTH message metadata\n- Configurable message processing (splitting, extraction, filtering)\n- Comprehensive metrics and monitoring",
      "config": {
        "identity": {
          "name": "identity",
          "type": "object",
          "kind": "scalar",
          "description": "Sparkplug identity configuration",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "group_id",
              "type": "string",
              "kind": "scalar",
              "description": "Sparkplug Group ID (e.g., 'FactoryA')",
              "required": true,
              "default": null,
              "examples": [
                "FactoryA"
              ]
            },
            {
              "name": "edge_node_id",
              "type": "string",
              "kind": "scalar",
              "description": "For Primary Host: used as host_id for STATE topic (spBv1.0/STATE/\u003chost_id\u003e). For Secondary Host: optional.",
              "required": false,
              "default": null,
              "examples": [
                "PrimaryHost"
              ]
            },
            {
              "name": "device_id",
              "type": "string",
              "kind": "scalar",
              "description": "Device ID under the edge node (optional, if not specified acts as node-level)",
              "required": false,
              "default": ""
            }
          ]
        },
        "mqtt": {
          "name": "mqtt",
          "type": "object",
          "kind": "scalar",
          "description": "MQTT transport configuration",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "urls",
              "type": "string",
              "kind": "array",
              "description": "List of MQTT broker URLs to connect to",
              "required": true,
              "default": [
                "tcp://localhost:1883"
              ],
              "examples": [
                [
                  "tcp://localhost:1883",
                  "ssl://broker.hivemq.com:8883"
                ]
              ]
            },
            {
              "name": "client_id",
              "type": "string",
              "kind": "scalar",
              "description": "MQTT client ID for this input plugin",
              "required": true,
              "default": "benthos-sparkplug-input"
            },
            {
              "name": "credentials",
              "type": "object",
              "kind": "scalar",
              "description": "MQTT authentication credentials",
              "required": false,
              "default": null,
              "children": [
                {
                  "name": "username",
                  "type": "string",
                  "kind": "scalar",
                  "description": "MQTT username for authentication",
                  "required": false,
                  "default": ""
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "MQTT password for authentication",
                  "required": false,
                  "default": ""
                }
              ]
            },
            {
              "name": "qos",
              "type": "int",
              "kind": "scalar",
              "description": "QoS level for MQTT operations (0, 1, or 2)",
              "required": true,
              "default": 1,
              "examples": [
                0,
                1,
                2
              ]
            },
            {
              "name": "keep_alive",
              "type": "string",
              "kind": "scalar",
              "description": "MQTT keep alive interval",
              "required": true,
              "default": "60s"
            },
            {
              "name": "connect_timeout",
              "type": "string",
              "kind": "scalar",
              "description": "MQTT connection timeout",
              "required": true,
              "default": "30s"
            },
            {
              "name": "clean_session",
              "type": "bool",
              "kind": "scalar",
              "description": "MQTT clean session flag",
              "required": true,
              "default": true
            }
          ]
        },
        "role": {
          "name": "role",
          "type": "string",
          "kind": "scalar",
          "description": "Sparkplug Host mode: 'secondary_passive' (default), 'secondary_active', or 'primary'",
          "required": true,
          "default": "secondary_passive"
        },
        "subscription": {
          "name": "subscription",
          "type": "object",
          "kind": "scalar",
          "description": "Subscription filtering configuration for primary_host role",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "groups",
              "type": "string",
              "kind": "array",
              "description": "Specific groups to subscribe to for primary_host role. Empty means all groups (+)",
              "required": false,
              "default": [],
              "examples": [
                [
                  "benthos",
                  "factory1",
                  "test"
                ]
              ]
            }
          ]
        }
      }
    },
    "spicedb_watch": {
      "name": "spicedb_watch",
      "type": "input",
      "source": "upstream",
      "summary": "Consume messages from the Watch API from SpiceDB.",
      "description": "\nThe SpiceDB input allows you to consume messages from the Watch API of a SpiceDB instance.\nThis input is useful for applications that need to react to changes in the data managed by SpiceDB in real-time.\n\n== Credentials\n\nYou need to provide the endpoint of your SpiceDB instance and a Bearer token for authentication.\n\n== Cache\n\nThe zed token of the newest update consumed and acked is stored in a cache in order to start reading from it each time the input is initialised.\nIdeally this cache should be persisted across restarts.\n",
      "config": {
        "bearer_token": {
          "name": "bearer_token",
          "type": "string",
          "kind": "scalar",
          "description": "The SpiceDB Bearer token used to authenticate against the SpiceDB instance.",
          "required": true,
          "default": "",
          "examples": [
            "t_your_token_here_1234567deadbeef"
          ]
        },
        "cache": {
          "name": "cache",
          "type": "string",
          "kind": "scalar",
          "description": "A cache resource to use for performing unread message backfills, the ID of the last message received will be stored in this cache and used for subsequent requests.",
          "required": true,
          "default": null
        },
        "cache_key": {
          "name": "cache_key",
          "type": "string",
          "kind": "scalar",
          "description": "The key identifier used when storing the ID of the last message received.",
          "required": true,
          "default": "authzed.com/spicedb/watch/last_zed_token",
          "advanced": true
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "The SpiceDB endpoint.",
          "required": true,
          "default": null,
          "examples": [
            "grpc.authzed.com:443"
          ]
        },
        "max_receive_message_bytes": {
          "name": "max_receive_message_bytes",
          "type": "string",
          "kind": "scalar",
          "description": "Maximum message size in bytes the SpiceDB client can receive.",
          "required": true,
          "default": "4MB",
          "examples": [
            "100MB",
            "50mib"
          ],
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        }
      }
    },
    "sql_raw": {
      "name": "sql_raw",
      "type": "input",
      "source": "upstream",
      "summary": "Executes a select query and creates a message for each row received.",
      "description": "Once the rows from the query are exhausted this input shuts down, allowing the pipeline to gracefully terminate (or the next input in a xref:components:inputs/sequence.adoc[sequence] to execute).",
      "config": {
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to an array of values matching in size to the number of placeholder arguments in the field `query`.",
          "required": false,
          "default": null,
          "examples": [
            "root = [ this.cat.meow, this.doc.woofs[0] ]",
            "root = [ meta(\"user.id\") ]"
          ]
        },
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "conn_max_idle": {
          "name": "conn_max_idle",
          "type": "int",
          "kind": "scalar",
          "description": "An optional maximum number of connections in the idle connection pool. If conn_max_open is greater than 0 but less than the new conn_max_idle, then the new conn_max_idle will be reduced to match the conn_max_open limit. If `value \u003c= 0`, no idle connections are retained. The default max idle connections is currently 2. This may change in a future release.",
          "required": false,
          "default": 2,
          "advanced": true
        },
        "conn_max_idle_time": {
          "name": "conn_max_idle_time",
          "type": "string",
          "kind": "scalar",
          "description": "An optional maximum amount of time a connection may be idle. Expired connections may be closed lazily before reuse. If `value \u003c= 0`, connections are not closed due to a connections idle time.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "conn_max_life_time": {
          "name": "conn_max_life_time",
          "type": "string",
          "kind": "scalar",
          "description": "An optional maximum amount of time a connection may be reused. Expired connections may be closed lazily before reuse. If `value \u003c= 0`, connections are not closed due to a connections age.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "conn_max_open": {
          "name": "conn_max_open",
          "type": "int",
          "kind": "scalar",
          "description": "An optional maximum number of open connections to the database. If conn_max_idle is greater than 0 and the new conn_max_open is less than conn_max_idle, then conn_max_idle will be reduced to match the new conn_max_open limit. If `value \u003c= 0`, then there is no limit on the number of open connections. The default is 0 (unlimited).",
          "required": false,
          "default": null,
          "advanced": true
        },
        "driver": {
          "name": "driver",
          "type": "string",
          "kind": "scalar",
          "description": "A database \u003c\u003cdrivers, driver\u003e\u003e to use.",
          "required": true,
          "default": null,
          "options": [
            "mysql",
            "postgres",
            "clickhouse",
            "mssql",
            "sqlite",
            "oracle",
            "snowflake",
            "trino",
            "gocosmos",
            "spanner"
          ]
        },
        "dsn": {
          "name": "dsn",
          "type": "string",
          "kind": "scalar",
          "description": "A Data Source Name to identify the target database.\n\n==== Drivers\n\n:driver-support: mysql=certified, postgres=certified, clickhouse=community, mssql=community, sqlite=certified, oracle=certified, snowflake=community, trino=community, gocosmos=community, spanner=community\n\nThe following is a list of supported drivers, their placeholder style, and their respective DSN formats:\n\n|===\n| Driver | Data Source Name Format\n\n| `clickhouse` \n| https://github.com/ClickHouse/clickhouse-go#dsn[`clickhouse://[username[:password\\]@\\][netloc\\][:port\\]/dbname[?param1=value1\u0026...\u0026paramN=valueN\\]`^] \n\n| `mysql` \n| `[username[:password]@][protocol[(address)]]/dbname[?param1=value1\u0026...\u0026paramN=valueN]` \n\n| `postgres` \n| `postgres://[user[:password]@][netloc][:port][/dbname][?param1=value1\u0026...]` \n\n| `mssql` \n| `sqlserver://[user[:password]@][netloc][:port][?database=dbname\u0026param1=value1\u0026...]` \n\n| `sqlite` \n| `file:/path/to/filename.db[?param\u0026=value1\u0026...]` \n\n| `oracle` \n| `oracle://[username[:password]@][netloc][:port]/service_name?server=server2\u0026server=server3` \n\n| `snowflake` \n| `username[:password]@account_identifier/dbname/schemaname[?param1=value\u0026...\u0026paramN=valueN]` \n\n| `trino` \n| https://github.com/trinodb/trino-go-client#dsn-data-source-name[`http[s\\]://user[:pass\\]@host[:port\\][?parameters\\]`^] \n\n| `gocosmos` \n| https://pkg.go.dev/github.com/microsoft/gocosmos#readme-example-usage[`AccountEndpoint=\u003ccosmosdb-endpoint\u003e;AccountKey=\u003ccosmosdb-account-key\u003e[;TimeoutMs=\u003ctimeout-in-ms\u003e\\][;Version=\u003ccosmosdb-api-version\u003e\\][;DefaultDb/Db=\u003cdb-name\u003e\\][;AutoId=\u003ctrue/false\u003e\\][;InsecureSkipVerify=\u003ctrue/false\u003e\\]`^] \n\n| `spanner` \n| projects/[PROJECT]/instances/[INSTANCE]/databases/[DATABASE] \n|===\n\nPlease note that the `postgres` driver enforces SSL by default, you can override this with the parameter `sslmode=disable` if required.\n\nThe `snowflake` driver supports multiple DSN formats. Please consult https://pkg.go.dev/github.com/snowflakedb/gosnowflake#hdr-Connection_String[the docs^] for more details. For https://docs.snowflake.com/en/user-guide/key-pair-auth.html#configuring-key-pair-authentication[key pair authentication^], the DSN has the following format: `\u003csnowflake_user\u003e@\u003csnowflake_account\u003e/\u003cdb_name\u003e/\u003cschema_name\u003e?warehouse=\u003cwarehouse\u003e\u0026role=\u003crole\u003e\u0026authenticator=snowflake_jwt\u0026privateKey=\u003cbase64_url_encoded_private_key\u003e`, where the value for the `privateKey` parameter can be constructed from an unencrypted RSA private key file `rsa_key.p8` using `openssl enc -d -base64 -in rsa_key.p8 | basenc --base64url -w0` (you can use `gbasenc` insted of `basenc` on OSX if you install `coreutils` via Homebrew). If you have a password-encrypted private key, you can decrypt it using `openssl pkcs8 -in rsa_key_encrypted.p8 -out rsa_key.p8`. Also, make sure fields such as the username are URL-encoded.\n\nThe https://pkg.go.dev/github.com/microsoft/gocosmos[`gocosmos`^] driver is still experimental, but it has support for https://learn.microsoft.com/en-us/azure/cosmos-db/hierarchical-partition-keys[hierarchical partition keys^] as well as https://learn.microsoft.com/en-us/azure/cosmos-db/nosql/how-to-query-container#cross-partition-query[cross-partition queries^]. Please refer to the https://github.com/microsoft/gocosmos/blob/main/SQL.md[SQL notes^] for details.",
          "required": true,
          "default": null,
          "examples": [
            "clickhouse://username:password@host1:9000,host2:9000/database?dial_timeout=200ms\u0026max_execution_time=60",
            "foouser:foopassword@tcp(localhost:3306)/foodb",
            "postgres://foouser:foopass@localhost:5432/foodb?sslmode=disable",
            "oracle://foouser:foopass@localhost:1521/service_name"
          ]
        },
        "init_files": {
          "name": "init_files",
          "type": "string",
          "kind": "array",
          "description": "\nAn optional list of file paths containing SQL statements to execute immediately upon the first connection to the target database. This is a useful way to initialise tables before processing data. Glob patterns are supported, including super globs (double star).\n\nCare should be taken to ensure that the statements are idempotent, and therefore would not cause issues when run multiple times after service restarts. If both `init_statement` and `init_files` are specified the `init_statement` is executed _after_ the `init_files`.\n\nIf a statement fails for any reason a warning log will be emitted but the operation of this component will not be stopped.\n",
          "required": false,
          "default": null,
          "examples": [
            [
              "./init/*.sql"
            ],
            [
              "./foo.sql",
              "./bar.sql"
            ]
          ],
          "advanced": true
        },
        "init_statement": {
          "name": "init_statement",
          "type": "string",
          "kind": "scalar",
          "description": "\nAn optional SQL statement to execute immediately upon the first connection to the target database. This is a useful way to initialise tables before processing data. Care should be taken to ensure that the statement is idempotent, and therefore would not cause issues when run multiple times after service restarts.\n\nIf both `init_statement` and `init_files` are specified the `init_statement` is executed _after_ the `init_files`.\n\nIf the statement fails for any reason a warning log will be emitted but the operation of this component will not be stopped.\n",
          "required": false,
          "default": null,
          "examples": [
            "\nCREATE TABLE IF NOT EXISTS some_table (\n  foo varchar(50) not null,\n  bar integer,\n  baz varchar(50),\n  primary key (foo)\n) WITHOUT ROWID;\n"
          ],
          "advanced": true
        },
        "query": {
          "name": "query",
          "type": "string",
          "kind": "scalar",
          "description": "The query to execute. The style of placeholder to use depends on the driver, some drivers require question marks (`?`) whereas others expect incrementing dollar signs (`$1`, `$2`, and so on) or colons (`:1`, `:2` and so on). The style to use is outlined in this table:\n\n| Driver | Placeholder Style |\n|---|---|\n| `clickhouse` | Dollar sign |\n| `mysql` | Question mark |\n| `postgres` | Dollar sign |\n| `mssql` | Question mark |\n| `sqlite` | Question mark |\n| `oracle` | Colon |\n| `snowflake` | Question mark |\n| `trino` | Question mark |\n| `gocosmos` | Colon |\n",
          "required": true,
          "default": null,
          "examples": [
            "SELECT * FROM footable WHERE user_id = $1;"
          ]
        }
      }
    },
    "sql_select": {
      "name": "sql_select",
      "type": "input",
      "source": "upstream",
      "summary": "Executes a select query and creates a message for each row received.",
      "description": "Once the rows from the query are exhausted this input shuts down, allowing the pipeline to gracefully terminate (or the next input in a xref:components:inputs/sequence.adoc[sequence] to execute).",
      "config": {
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to an array of values matching in size to the number of placeholder arguments in the field `where`.",
          "required": false,
          "default": null,
          "examples": [
            "root = [ \"article\", now().ts_format(\"2006-01-02\") ]"
          ]
        },
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "columns": {
          "name": "columns",
          "type": "string",
          "kind": "array",
          "description": "A list of columns to select.",
          "required": true,
          "default": null,
          "examples": [
            [
              "*"
            ],
            [
              "foo",
              "bar",
              "baz"
            ]
          ]
        },
        "conn_max_idle": {
          "name": "conn_max_idle",
          "type": "int",
          "kind": "scalar",
          "description": "An optional maximum number of connections in the idle connection pool. If conn_max_open is greater than 0 but less than the new conn_max_idle, then the new conn_max_idle will be reduced to match the conn_max_open limit. If `value \u003c= 0`, no idle connections are retained. The default max idle connections is currently 2. This may change in a future release.",
          "required": false,
          "default": 2,
          "advanced": true
        },
        "conn_max_idle_time": {
          "name": "conn_max_idle_time",
          "type": "string",
          "kind": "scalar",
          "description": "An optional maximum amount of time a connection may be idle. Expired connections may be closed lazily before reuse. If `value \u003c= 0`, connections are not closed due to a connections idle time.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "conn_max_life_time": {
          "name": "conn_max_life_time",
          "type": "string",
          "kind": "scalar",
          "description": "An optional maximum amount of time a connection may be reused. Expired connections may be closed lazily before reuse. If `value \u003c= 0`, connections are not closed due to a connections age.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "conn_max_open": {
          "name": "conn_max_open",
          "type": "int",
          "kind": "scalar",
          "description": "An optional maximum number of open connections to the database. If conn_max_idle is greater than 0 and the new conn_max_open is less than conn_max_idle, then conn_max_idle will be reduced to match the new conn_max_open limit. If `value \u003c= 0`, then there is no limit on the number of open connections. The default is 0 (unlimited).",
          "required": false,
          "default": null,
          "advanced": true
        },
        "driver": {
          "name": "driver",
          "type": "string",
          "kind": "scalar",
          "description": "A database \u003c\u003cdrivers, driver\u003e\u003e to use.",
          "required": true,
          "default": null,
          "options": [
            "mysql",
            "postgres",
            "clickhouse",
            "mssql",
            "sqlite",
            "oracle",
            "snowflake",
            "trino",
            "gocosmos",
            "spanner"
          ]
        },
        "dsn": {
          "name": "dsn",
          "type": "string",
          "kind": "scalar",
          "description": "A Data Source Name to identify the target database.\n\n==== Drivers\n\n:driver-support: mysql=certified, postgres=certified, clickhouse=community, mssql=community, sqlite=certified, oracle=certified, snowflake=community, trino=community, gocosmos=community, spanner=community\n\nThe following is a list of supported drivers, their placeholder style, and their respective DSN formats:\n\n|===\n| Driver | Data Source Name Format\n\n| `clickhouse` \n| https://github.com/ClickHouse/clickhouse-go#dsn[`clickhouse://[username[:password\\]@\\][netloc\\][:port\\]/dbname[?param1=value1\u0026...\u0026paramN=valueN\\]`^] \n\n| `mysql` \n| `[username[:password]@][protocol[(address)]]/dbname[?param1=value1\u0026...\u0026paramN=valueN]` \n\n| `postgres` \n| `postgres://[user[:password]@][netloc][:port][/dbname][?param1=value1\u0026...]` \n\n| `mssql` \n| `sqlserver://[user[:password]@][netloc][:port][?database=dbname\u0026param1=value1\u0026...]` \n\n| `sqlite` \n| `file:/path/to/filename.db[?param\u0026=value1\u0026...]` \n\n| `oracle` \n| `oracle://[username[:password]@][netloc][:port]/service_name?server=server2\u0026server=server3` \n\n| `snowflake` \n| `username[:password]@account_identifier/dbname/schemaname[?param1=value\u0026...\u0026paramN=valueN]` \n\n| `trino` \n| https://github.com/trinodb/trino-go-client#dsn-data-source-name[`http[s\\]://user[:pass\\]@host[:port\\][?parameters\\]`^] \n\n| `gocosmos` \n| https://pkg.go.dev/github.com/microsoft/gocosmos#readme-example-usage[`AccountEndpoint=\u003ccosmosdb-endpoint\u003e;AccountKey=\u003ccosmosdb-account-key\u003e[;TimeoutMs=\u003ctimeout-in-ms\u003e\\][;Version=\u003ccosmosdb-api-version\u003e\\][;DefaultDb/Db=\u003cdb-name\u003e\\][;AutoId=\u003ctrue/false\u003e\\][;InsecureSkipVerify=\u003ctrue/false\u003e\\]`^] \n\n| `spanner` \n| projects/[PROJECT]/instances/[INSTANCE]/databases/[DATABASE] \n|===\n\nPlease note that the `postgres` driver enforces SSL by default, you can override this with the parameter `sslmode=disable` if required.\n\nThe `snowflake` driver supports multiple DSN formats. Please consult https://pkg.go.dev/github.com/snowflakedb/gosnowflake#hdr-Connection_String[the docs^] for more details. For https://docs.snowflake.com/en/user-guide/key-pair-auth.html#configuring-key-pair-authentication[key pair authentication^], the DSN has the following format: `\u003csnowflake_user\u003e@\u003csnowflake_account\u003e/\u003cdb_name\u003e/\u003cschema_name\u003e?warehouse=\u003cwarehouse\u003e\u0026role=\u003crole\u003e\u0026authenticator=snowflake_jwt\u0026privateKey=\u003cbase64_url_encoded_private_key\u003e`, where the value for the `privateKey` parameter can be constructed from an unencrypted RSA private key file `rsa_key.p8` using `openssl enc -d -base64 -in rsa_key.p8 | basenc --base64url -w0` (you can use `gbasenc` insted of `basenc` on OSX if you install `coreutils` via Homebrew). If you have a password-encrypted private key, you can decrypt it using `openssl pkcs8 -in rsa_key_encrypted.p8 -out rsa_key.p8`. Also, make sure fields such as the username are URL-encoded.\n\nThe https://pkg.go.dev/github.com/microsoft/gocosmos[`gocosmos`^] driver is still experimental, but it has support for https://learn.microsoft.com/en-us/azure/cosmos-db/hierarchical-partition-keys[hierarchical partition keys^] as well as https://learn.microsoft.com/en-us/azure/cosmos-db/nosql/how-to-query-container#cross-partition-query[cross-partition queries^]. Please refer to the https://github.com/microsoft/gocosmos/blob/main/SQL.md[SQL notes^] for details.",
          "required": true,
          "default": null,
          "examples": [
            "clickhouse://username:password@host1:9000,host2:9000/database?dial_timeout=200ms\u0026max_execution_time=60",
            "foouser:foopassword@tcp(localhost:3306)/foodb",
            "postgres://foouser:foopass@localhost:5432/foodb?sslmode=disable",
            "oracle://foouser:foopass@localhost:1521/service_name"
          ]
        },
        "init_files": {
          "name": "init_files",
          "type": "string",
          "kind": "array",
          "description": "\nAn optional list of file paths containing SQL statements to execute immediately upon the first connection to the target database. This is a useful way to initialise tables before processing data. Glob patterns are supported, including super globs (double star).\n\nCare should be taken to ensure that the statements are idempotent, and therefore would not cause issues when run multiple times after service restarts. If both `init_statement` and `init_files` are specified the `init_statement` is executed _after_ the `init_files`.\n\nIf a statement fails for any reason a warning log will be emitted but the operation of this component will not be stopped.\n",
          "required": false,
          "default": null,
          "examples": [
            [
              "./init/*.sql"
            ],
            [
              "./foo.sql",
              "./bar.sql"
            ]
          ],
          "advanced": true
        },
        "init_statement": {
          "name": "init_statement",
          "type": "string",
          "kind": "scalar",
          "description": "\nAn optional SQL statement to execute immediately upon the first connection to the target database. This is a useful way to initialise tables before processing data. Care should be taken to ensure that the statement is idempotent, and therefore would not cause issues when run multiple times after service restarts.\n\nIf both `init_statement` and `init_files` are specified the `init_statement` is executed _after_ the `init_files`.\n\nIf the statement fails for any reason a warning log will be emitted but the operation of this component will not be stopped.\n",
          "required": false,
          "default": null,
          "examples": [
            "\nCREATE TABLE IF NOT EXISTS some_table (\n  foo varchar(50) not null,\n  bar integer,\n  baz varchar(50),\n  primary key (foo)\n) WITHOUT ROWID;\n"
          ],
          "advanced": true
        },
        "prefix": {
          "name": "prefix",
          "type": "string",
          "kind": "scalar",
          "description": "An optional prefix to prepend to the select query (before SELECT).",
          "required": false,
          "default": null,
          "advanced": true
        },
        "suffix": {
          "name": "suffix",
          "type": "string",
          "kind": "scalar",
          "description": "An optional suffix to append to the select query.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "table": {
          "name": "table",
          "type": "string",
          "kind": "scalar",
          "description": "The table to select from.",
          "required": true,
          "default": null,
          "examples": [
            "foo"
          ]
        },
        "where": {
          "name": "where",
          "type": "string",
          "kind": "scalar",
          "description": "An optional where clause to add. Placeholder arguments are populated with the `args_mapping` field. Placeholders should always be question marks, and will automatically be converted to dollar syntax when the postgres or clickhouse drivers are used.",
          "required": false,
          "default": null,
          "examples": [
            "type = ? and created_at \u003e ?",
            "user_id = ?"
          ]
        }
      }
    },
    "stdin": {
      "name": "stdin",
      "type": "input",
      "source": "upstream",
      "summary": "Consumes data piped to stdin, chopping it into individual messages according to the specified scanner.",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "codec": {
          "name": "codec",
          "type": "string",
          "kind": "scalar",
          "description": "The way in which the bytes of a data source should be converted into discrete messages, codecs are useful for specifying how large files or continuous streams of data might be processed in small chunks rather than loading it all in memory. It's possible to consume lines using a custom delimiter with the `delim:x` codec, where x is the character sequence custom delimiter. Codecs can be chained with `/`, for example a gzip compressed CSV file can be consumed with the codec `gzip/csv`.",
          "required": false,
          "default": null,
          "examples": [
            "lines",
            "delim:\t",
            "delim:foobar",
            "gzip/csv"
          ]
        },
        "max_buffer": {
          "name": "max_buffer",
          "type": "int",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": 1000000
        },
        "scanner": {
          "name": "scanner",
          "type": "scanner",
          "kind": "scalar",
          "description": "The xref:components:scanners/about.adoc[scanner] by which the stream of bytes consumed will be broken out into individual messages. Scanners are useful for processing large sources of data without holding the entirety of it within memory. For example, the `csv` scanner allows you to process individual CSV rows without loading the entire CSV file in memory at once.",
          "required": false,
          "default": {
            "lines": {}
          }
        }
      }
    },
    "subprocess": {
      "name": "subprocess",
      "type": "input",
      "source": "upstream",
      "summary": "Executes a command, runs it as a subprocess, and consumes messages from it over stdout.",
      "description": "\nMessages are consumed according to a specified codec. The command is executed once and if it terminates the input also closes down gracefully. Alternatively, the field `restart_on_close` can be set to `true` in order to have Redpanda Connect re-execute the command each time it stops.\n\nThe field `max_buffer` defines the maximum message size able to be read from the subprocess. This value should be set significantly above the real expected maximum message size.\n\nThe execution environment of the subprocess is the same as the Redpanda Connect instance, including environment variables and the current working directory.",
      "config": {
        "args": {
          "name": "args",
          "type": "string",
          "kind": "array",
          "description": "A list of arguments to provide the command.",
          "required": true,
          "default": []
        },
        "codec": {
          "name": "codec",
          "type": "string",
          "kind": "scalar",
          "description": "The way in which messages should be consumed from the subprocess.",
          "required": true,
          "default": "lines",
          "options": [
            "lines"
          ]
        },
        "max_buffer": {
          "name": "max_buffer",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum expected size of an individual message.",
          "required": true,
          "default": 65536,
          "advanced": true
        },
        "name": {
          "name": "name",
          "type": "string",
          "kind": "scalar",
          "description": "The command to execute as a subprocess.",
          "required": true,
          "default": null,
          "examples": [
            "cat",
            "sed",
            "awk"
          ]
        },
        "restart_on_exit": {
          "name": "restart_on_exit",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether the command should be re-executed each time the subprocess ends.",
          "required": true,
          "default": false
        }
      }
    },
    "timeplus": {
      "name": "timeplus",
      "type": "input",
      "source": "upstream",
      "summary": "Executes a query on Timeplus Enterprise and creates a message from each row received",
      "description": "\nThis input can execute a query on Timeplus Enterprise Cloud, Timeplus Enterprise (self-hosted) or Timeplusd. A structured message will be created\nfrom each row received.\n\nIf it is a streaming query, this input will keep running until the query is terminated. If it is a table query, this input will shut down once the rows from the query are exhausted.",
      "config": {
        "apikey": {
          "name": "apikey",
          "type": "string",
          "kind": "scalar",
          "description": "The API key. Required when reads from Timeplus Enterprise Cloud",
          "required": false,
          "default": null
        },
        "password": {
          "name": "password",
          "type": "string",
          "kind": "scalar",
          "description": "The password. Required when reads from Timeplus Enterprise (self-hosted) or Timeplusd",
          "required": false,
          "default": null
        },
        "query": {
          "name": "query",
          "type": "string",
          "kind": "scalar",
          "description": "The query to run",
          "required": true,
          "default": null,
          "examples": [
            "select * from iot",
            "select count(*) from table(iot)"
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The url should always include schema and host.",
          "required": true,
          "default": "tcp://localhost:8463"
        },
        "username": {
          "name": "username",
          "type": "string",
          "kind": "scalar",
          "description": "The username. Required when reads from Timeplus Enterprise (self-hosted) or Timeplusd",
          "required": false,
          "default": null
        },
        "workspace": {
          "name": "workspace",
          "type": "string",
          "kind": "scalar",
          "description": "ID of the workspace. Required when reads from Timeplus Enterprise.",
          "required": false,
          "default": null
        }
      }
    },
    "twitter_search": {
      "name": "twitter_search",
      "type": "input",
      "source": "upstream",
      "summary": "Consumes tweets matching a given search using the Twitter recent search V2 API.",
      "description": "Continuously polls the https://developer.twitter.com/en/docs/twitter-api/tweets/search/api-reference/get-tweets-search-recent[Twitter recent search V2 API^] for tweets that match a given search query.\n\nEach tweet received is emitted as a JSON object message, with a field `id` and `text` by default. Extra fields https://developer.twitter.com/en/docs/twitter-api/fields[can be obtained from the search API^] when listed with the `tweet_fields` field.\n\nIn order to paginate requests that are made the ID of the latest received tweet is stored in a xref:components:caches/about.adoc[cache resource], which is then used by subsequent requests to ensure only tweets after it are consumed. It is recommended that the cache you use is persistent so that Redpanda Connect can resume searches at the correct place on a restart.\n\nAuthentication is done using OAuth 2.0 credentials which can be generated within the https://developer.twitter.com[Twitter developer portal^].\n",
      "config": {
        "api_key": {
          "name": "api_key",
          "type": "string",
          "kind": "scalar",
          "description": "An API key for OAuth 2.0 authentication. It is recommended that you populate this field using xref:configuration:interpolation.adoc[environment variables].",
          "required": true,
          "default": null
        },
        "api_secret": {
          "name": "api_secret",
          "type": "string",
          "kind": "scalar",
          "description": "An API secret for OAuth 2.0 authentication. It is recommended that you populate this field using xref:configuration:interpolation.adoc[environment variables].",
          "required": true,
          "default": null
        },
        "backfill_period": {
          "name": "backfill_period",
          "type": "string",
          "kind": "scalar",
          "description": "A duration string indicating the maximum age of tweets to acquire when starting a search.",
          "required": true,
          "default": "5m"
        },
        "cache": {
          "name": "cache",
          "type": "string",
          "kind": "scalar",
          "description": "A cache resource to use for request pagination.",
          "required": true,
          "default": null
        },
        "cache_key": {
          "name": "cache_key",
          "type": "string",
          "kind": "scalar",
          "description": "The key identifier used when storing the ID of the last tweet received.",
          "required": true,
          "default": "last_tweet_id",
          "advanced": true
        },
        "poll_period": {
          "name": "poll_period",
          "type": "string",
          "kind": "scalar",
          "description": "The length of time (as a duration string) to wait between each search request. This field can be set empty, in which case requests are made at the limit set by the rate limit. This field also supports cron expressions.",
          "required": true,
          "default": "1m"
        },
        "query": {
          "name": "query",
          "type": "string",
          "kind": "scalar",
          "description": "A search expression to use.",
          "required": true,
          "default": null
        },
        "rate_limit": {
          "name": "rate_limit",
          "type": "string",
          "kind": "scalar",
          "description": "An optional rate limit resource to restrict API requests with.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "tweet_fields": {
          "name": "tweet_fields",
          "type": "string",
          "kind": "array",
          "description": "An optional list of additional fields to obtain for each tweet, by default only the fields `id` and `text` are returned. For more info refer to the https://developer.twitter.com/en/docs/twitter-api/fields[twitter API docs^].",
          "required": true,
          "default": []
        }
      }
    },
    "uns": {
      "name": "uns",
      "type": "input",
      "source": "benthos-umh",
      "summary": "Consumes messsages from the UMH platform's Kafka messaging system",
      "description": "\n\tThe uns_plugin input consumes messages from the United Manufacturing Hub's kafka messaging system.\n\tThis input plugin is optimized for communication with UMH core components and handles the complexities of Kafka for you.\n\n\tAll messages are read from the uns topic 'umh.messages' by default, with messages being filtered by the regular expression(s) specified in the plugin config field 'umh_topic' or 'umh_topics'. This becomes crucial for streaming out the data of interest from the uns topic.\n\n\tBy default, the plugin connects to the Kafka broker at localhost:9092 with the consumer group id specified in the plugin config. The consumer group id is usually derived from the UMH workloads like protocol converter names.\n\t\t",
      "config": {
        "broker_address": {
          "name": "broker_address",
          "type": "string",
          "kind": "scalar",
          "description": "\nThe Kafka broker address to connect to. This can be a single address or multiple addresses\nseparated by commas. For example: \"localhost:9092\" or \"broker1:9092,broker2:9092\".\n\nIn most UMH deployments, the default value is sufficient as Kafka runs on the same host.\n\t\t",
          "required": true,
          "default": "localhost:9092"
        },
        "consumer_group": {
          "name": "consumer_group",
          "type": "string",
          "kind": "scalar",
          "description": "\n\tThe consumer group id to be used by the plugin. The default consumer group id is uns_plugin. This is an optional plugin input and can be used by the users if one wants to read the topic with a different consumer group discarding the previous consumed offsets.\n\t",
          "required": true,
          "default": "uns_plugin",
          "examples": [
            "uns_consumer_group"
          ]
        },
        "kafka_topic": {
          "name": "kafka_topic",
          "type": "string",
          "kind": "scalar",
          "description": "\n\tThe input kafka topic to read messages from. By default the messages will be consumed from 'umh.messages' topic.\n\t\t\t",
          "required": false,
          "default": null,
          "examples": [
            "umh.messages"
          ]
        },
        "topic": {
          "name": "topic",
          "type": "string",
          "kind": "scalar",
          "description": "\n\t[DEPRECATED] Use 'umh_topic' or 'umh_topics' instead. Key used to filter the messages for backwards compatibility.\n\t\t",
          "required": false,
          "default": null,
          "examples": [
            "umh.v1.acme.berlin.assembly.temperature",
            "umh\\.v1\\..+"
          ],
          "advanced": true
        },
        "umh_topic": {
          "name": "umh_topic",
          "type": "string",
          "kind": "scalar",
          "description": "\n\tKey used to filter the messages. The value set for the 'umh_topic' field will be used to compare against the message key in kafka. The 'umh_topic' field allows regular expressions which should be compatible with RE2 regex engine.\n\n\tThe topic should follow the UMH naming convention: umh.v1.enterprise.site.area.tag\n\t(e.g., 'umh.v1.acme.berlin.assembly.temperature')\n\t(e.g., 'umh.v1.acme.berlin.+' # regex to match all areas and tags under brelin site )\n\n\tCannot be used together with 'umh_topics'.\n\t\t",
          "required": false,
          "default": null,
          "examples": [
            "umh.v1.acme.berlin.assembly.temperature",
            "umh\\.v1\\..+"
          ]
        },
        "umh_topics": {
          "name": "umh_topics",
          "type": "string",
          "kind": "array",
          "description": "\n\tList of keys used to filter the messages. Each value in the 'umh_topics' list will be used to compare against the message key in kafka. The 'umh_topics' field allows regular expressions which should be compatible with RE2 regex engine.\n\n\tThe topics should follow the UMH naming convention: umh.v1.enterprise.site.area.tag\n\t(e.g., ['umh.v1.acme.berlin.assembly.temperature', 'umh.v1.acme.munich.packaging.pressure'])\n\t(e.g., ['umh.v1.acme.berlin.+', 'umh.v1.acme.munich.+'] # regex to match all areas and tags under both sites)\n\n\tCannot be used together with 'umh_topic'.\n\t\t",
          "required": true,
          "default": null,
          "examples": [
            [
              "umh.v1.acme.berlin.assembly.temperature",
              "umh.v1.acme.munich.packaging.pressure"
            ],
            [
              "umh\\.v1\\.acme\\.berlin\\..+",
              "umh\\.v1\\.acme\\.munich\\..+"
            ]
          ]
        }
      }
    },
    "websocket": {
      "name": "websocket",
      "type": "input",
      "source": "upstream",
      "summary": "Connects to a websocket server and continuously receives messages.",
      "description": "It is possible to configure an `open_message`, which when set to a non-empty string will be sent to the websocket server each time a connection is first established.",
      "config": {
        "auto_replay_nacks": {
          "name": "auto_replay_nacks",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages that are rejected (nacked) at the output level should be automatically replayed indefinitely, eventually resulting in back pressure if the cause of the rejections is persistent. If set to `false` these messages will instead be deleted. Disabling auto replays can greatly improve memory efficiency of high throughput streams as the original shape of the data can be discarded immediately upon consumption and mutation.",
          "required": true,
          "default": true
        },
        "basic_auth": {
          "name": "basic_auth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify basic authentication.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use basic authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "A username to authenticate as.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A password to authenticate with.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "connection": {
          "name": "connection",
          "type": "object",
          "kind": "scalar",
          "description": "Customise how websocket connection attempts are made.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "max_retries",
              "type": "int",
              "kind": "scalar",
              "description": "An optional limit to the number of consecutive retry attempts that will be made before abandoning the connection altogether and gracefully terminating the input. When all inputs terminate in this way the service (or stream) will shut down. If set to zero connections will never be reattempted upon a failure. If set below zero this field is ignored (effectively unset).",
              "required": false,
              "default": null,
              "examples": [
                -1,
                10
              ],
              "advanced": true
            }
          ]
        },
        "jwt": {
          "name": "jwt",
          "type": "object",
          "kind": "scalar",
          "description": "BETA: Allows you to specify JWT authentication.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use JWT authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "private_key_file",
              "type": "string",
              "kind": "scalar",
              "description": "A file with the PEM encoded via PKCS1 or PKCS8 as private key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "signing_method",
              "type": "string",
              "kind": "scalar",
              "description": "A method used to sign the token such as RS256, RS384, RS512 or EdDSA.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "claims",
              "type": "unknown",
              "kind": "map",
              "description": "A value used to identify the claims that issued the JWT.",
              "required": true,
              "default": {},
              "advanced": true
            },
            {
              "name": "headers",
              "type": "unknown",
              "kind": "map",
              "description": "Add optional key/value headers to the JWT.",
              "required": true,
              "default": {},
              "advanced": true
            }
          ]
        },
        "oauth": {
          "name": "oauth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify open authentication via OAuth version 1.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use OAuth version 1 in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "consumer_key",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to identify the client to the service provider.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "consumer_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret used to establish ownership of the consumer key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "access_token",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to gain access to the protected resources on behalf of the user.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "access_token_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret provided in order to establish ownership of a given access token.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "open_message": {
          "name": "open_message",
          "type": "string",
          "kind": "scalar",
          "description": "An optional message to send to the server upon connection.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "open_message_type": {
          "name": "open_message_type",
          "type": "string",
          "kind": "scalar",
          "description": "An optional flag to indicate the data type of open_message.",
          "required": true,
          "default": "binary",
          "advanced": true
        },
        "proxy_url": {
          "name": "proxy_url",
          "type": "string",
          "kind": "scalar",
          "description": "An optional HTTP proxy URL.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL to connect to.",
          "required": true,
          "default": null,
          "examples": [
            "ws://localhost:4195/get/ws"
          ]
        }
      }
    }
  },
  "processors": {
    "alarm": {
      "name": "alarm",
      "type": "processor",
      "source": "upstream",
      "summary": "Creates an processor that sends data when conditions are met. Created by Daniel H",
      "description": "This processor plugin enables Benthos to send data when specific conditions are met. Configure the plugin by specifying the alarm value, reset value, operator and reset operator.",
      "config": {
        "addMeta": {
          "name": "addMeta",
          "type": "bool",
          "kind": "scalar",
          "description": "Add existing metadata to message",
          "required": true,
          "default": false
        },
        "addToJson": {
          "name": "addToJson",
          "type": "bool",
          "kind": "scalar",
          "description": "Add the alarm to the json structure",
          "required": true,
          "default": false
        },
        "addValue": {
          "name": "addValue",
          "type": "bool",
          "kind": "scalar",
          "description": "Add the current value to the alarm text",
          "required": true,
          "default": false
        },
        "alarmJsonStruct": {
          "name": "alarmJsonStruct",
          "type": "string",
          "kind": "scalar",
          "description": "specific json struct for output. Default ''",
          "required": true,
          "default": ""
        },
        "alarmObject": {
          "name": "alarmObject",
          "type": "string",
          "kind": "scalar",
          "description": "Name of the json object for the alarm. Default 'alarm'",
          "required": true,
          "default": "alarm"
        },
        "alarmText": {
          "name": "alarmText",
          "type": "string",
          "kind": "scalar",
          "description": "Alarm text to be added to the alarm. Default 'Alarm'",
          "required": true,
          "default": "Alarm"
        },
        "cleanMsg": {
          "name": "cleanMsg",
          "type": "bool",
          "kind": "scalar",
          "description": "Create a new clean msg with alarmtext only",
          "required": true,
          "default": true
        },
        "filterTime": {
          "name": "filterTime",
          "type": "string",
          "kind": "scalar",
          "description": "Time filter before trigger. Default 0s",
          "required": true,
          "default": "0s"
        },
        "json": {
          "name": "json",
          "type": "string",
          "kind": "scalar",
          "description": "tag name is value is json)",
          "required": true,
          "default": ""
        },
        "operator": {
          "name": "operator",
          "type": "string",
          "kind": "scalar",
          "description": "allowed operators: \u003c,\u003e,=",
          "required": true,
          "default": "\u003e"
        },
        "reset": {
          "name": "reset",
          "type": "float",
          "kind": "scalar",
          "description": "reset value",
          "required": true,
          "default": 0
        },
        "resetOperator": {
          "name": "resetOperator",
          "type": "string",
          "kind": "scalar",
          "description": "reset operator",
          "required": true,
          "default": "\u003c"
        },
        "sendAlarmOnly": {
          "name": "sendAlarmOnly",
          "type": "bool",
          "kind": "scalar",
          "description": "Block all messages except alarm",
          "required": true,
          "default": true
        },
        "sendInterval": {
          "name": "sendInterval",
          "type": "string",
          "kind": "scalar",
          "description": "Interval time before resending alarm. Default 0s",
          "required": true,
          "default": "0s"
        },
        "stringValue": {
          "name": "stringValue",
          "type": "string",
          "kind": "scalar",
          "description": "Alarm value if using string)",
          "required": true,
          "default": ""
        },
        "value": {
          "name": "value",
          "type": "float",
          "kind": "scalar",
          "description": "Alarm value, default '100'",
          "required": true,
          "default": 100
        }
      }
    },
    "archive": {
      "name": "archive",
      "type": "processor",
      "source": "upstream",
      "summary": "Archives all the messages of a batch into a single message according to the selected archive format.",
      "description": "\nSome archive formats (such as tar, zip) treat each archive item (message part) as a file with a path. Since message parts only contain raw data a unique path must be generated for each part. This can be done by using function interpolations on the 'path' field as described in xref:configuration:interpolation.adoc#bloblang-queries[Bloblang queries]. For types that aren't file based (such as binary) the file field is ignored.\n\nThe resulting archived message adopts the metadata of the _first_ message part of the batch.\n\nThe functionality of this processor depends on being applied across messages that are batched. You can find out more about batching xref:configuration:batching.adoc[in this doc].",
      "config": {
        "format": {
          "name": "format",
          "type": "string",
          "kind": "scalar",
          "description": "The archiving format to apply.",
          "required": true,
          "default": null
        },
        "path": {
          "name": "path",
          "type": "string",
          "kind": "scalar",
          "description": "The path to set for each message in the archive (when applicable).",
          "required": true,
          "default": "",
          "examples": [
            "${!count(\"files\")}-${!timestamp_unix_nano()}.txt",
            "${!meta(\"kafka_key\")}-${!json(\"id\")}.json"
          ]
        }
      }
    },
    "avro": {
      "name": "avro",
      "type": "processor",
      "source": "upstream",
      "summary": "Performs Avro based operations on messages based on a schema.",
      "description": "\nWARNING: If you are consuming or generating messages using a schema registry service then it is likely this processor will fail as those services require messages to be prefixed with the identifier of the schema version being used. Instead, try the xref:components:processors/schema_registry_encode.adoc[`schema_registry_encode`] and xref:components:processors/schema_registry_decode.adoc[`schema_registry_decode`] processors.\n\n== Operators\n\n=== `to_json`\n\nConverts Avro documents into a JSON structure. This makes it easier to\nmanipulate the contents of the document within Benthos. The encoding field\nspecifies how the source documents are encoded.\n\n=== `from_json`\n\nAttempts to convert JSON documents into Avro documents according to the\nspecified encoding.",
      "config": {
        "encoding": {
          "name": "encoding",
          "type": "string",
          "kind": "scalar",
          "description": "An Avro encoding format to use for conversions to and from a schema.",
          "required": true,
          "default": "textual",
          "options": [
            "textual",
            "binary",
            "single"
          ]
        },
        "operator": {
          "name": "operator",
          "type": "string",
          "kind": "scalar",
          "description": "The \u003c\u003coperators, operator\u003e\u003e to execute",
          "required": true,
          "default": null,
          "options": [
            "to_json",
            "from_json"
          ]
        },
        "schema": {
          "name": "schema",
          "type": "string",
          "kind": "scalar",
          "description": "A full Avro schema to use.",
          "required": true,
          "default": ""
        },
        "schema_path": {
          "name": "schema_path",
          "type": "string",
          "kind": "scalar",
          "description": "The path of a schema document to apply. Use either this or the `schema` field.",
          "required": true,
          "default": "",
          "examples": [
            "file://path/to/spec.avsc",
            "http://localhost:8081/path/to/spec/versions/1"
          ]
        }
      }
    },
    "awk": {
      "name": "awk",
      "type": "processor",
      "source": "upstream",
      "summary": "Executes an AWK program on messages. This processor is very powerful as it offers a range of \u003c\u003cawk-functions,custom functions\u003e\u003e for querying and mutating message contents and metadata.",
      "description": "\nWorks by feeding message contents as the program input based on a chosen \u003c\u003ccodecs,codec\u003e\u003e and replaces the contents of each message with the result. If the result is empty (nothing is printed by the program) then the original message contents remain unchanged.\n\nComes with a wide range of \u003c\u003cawk-functions,custom functions\u003e\u003e for accessing message metadata, json fields, printing logs, etc. These functions can be overridden by functions within the program.\n\nCheck out the \u003c\u003cexamples,examples section\u003e\u003e in order to see how this processor can be used.\n\nThis processor uses https://github.com/benhoyt/goawk[GoAWK^], in order to understand the differences in how the program works you can read more about it in https://github.com/benhoyt/goawk#differences-from-awk[goawk.differences^].",
      "config": {
        "codec": {
          "name": "codec",
          "type": "string",
          "kind": "scalar",
          "description": "A \u003c\u003ccodecs,codec\u003e\u003e defines how messages should be inserted into the AWK program as variables. The codec does not change which \u003c\u003cawk-functions,custom Redpanda Connect functions\u003e\u003e are available. The `text` codec is the closest to a typical AWK use case.",
          "required": true,
          "default": null,
          "options": [
            "none",
            "text",
            "json"
          ]
        },
        "program": {
          "name": "program",
          "type": "string",
          "kind": "scalar",
          "description": "An AWK program to execute",
          "required": true,
          "default": null
        }
      }
    },
    "aws_dynamodb_partiql": {
      "name": "aws_dynamodb_partiql",
      "type": "processor",
      "source": "upstream",
      "summary": "Executes a PartiQL expression against a DynamoDB table for each message.",
      "description": "Both writes or reads are supported, when the query is a read the contents of the message will be replaced with the result. This processor is more efficient when messages are pre-batched as the whole batch will be executed in a single call.",
      "config": {
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] that, for each message, creates a list of arguments to use with the query.",
          "required": true,
          "default": ""
        },
        "credentials": {
          "name": "credentials",
          "type": "object",
          "kind": "scalar",
          "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "profile",
              "type": "string",
              "kind": "scalar",
              "description": "A profile from `~/.aws/credentials` to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "id",
              "type": "string",
              "kind": "scalar",
              "description": "The ID of credentials to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "secret",
              "type": "string",
              "kind": "scalar",
              "description": "The secret for the credentials being used.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token",
              "type": "string",
              "kind": "scalar",
              "description": "The token for the credentials being used, required when using short term credentials.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "from_ec2_role",
              "type": "bool",
              "kind": "scalar",
              "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "role",
              "type": "string",
              "kind": "scalar",
              "description": "A role ARN to assume.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "role_external_id",
              "type": "string",
              "kind": "scalar",
              "description": "An external ID to provide when assuming a role.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "Allows you to specify a custom endpoint for the AWS API.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "query": {
          "name": "query",
          "type": "string",
          "kind": "scalar",
          "description": "A PartiQL query to execute for each message.",
          "required": true,
          "default": null
        },
        "region": {
          "name": "region",
          "type": "string",
          "kind": "scalar",
          "description": "The AWS region to target.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "unsafe_dynamic_query": {
          "name": "unsafe_dynamic_query",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to enable dynamic queries that support interpolation functions.",
          "required": true,
          "default": false,
          "advanced": true
        }
      }
    },
    "aws_lambda": {
      "name": "aws_lambda",
      "type": "processor",
      "source": "upstream",
      "summary": "Invokes an AWS lambda for each message. The contents of the message is the payload of the request, and the result of the invocation will become the new contents of the message.",
      "description": "The `rate_limit` field can be used to specify a rate limit xref:components:rate_limits/about.adoc[resource] to cap the rate of requests across parallel components service wide.\n\nIn order to map or encode the payload to a specific request body, and map the response back into the original payload instead of replacing it entirely, you can use the xref:components:processors/branch.adoc[`branch` processor].\n\n== Error handling\n\nWhen Redpanda Connect is unable to connect to the AWS endpoint or is otherwise unable to invoke the target lambda function it will retry the request according to the configured number of retries. Once these attempts have been exhausted the failed message will continue through the pipeline with it's contents unchanged, but flagged as having failed, allowing you to use xref:configuration:error_handling.adoc[standard processor error handling patterns].\n\nHowever, if the invocation of the function is successful but the function itself throws an error, then the message will have it's contents updated with a JSON payload describing the reason for the failure, and a metadata field `lambda_function_error` will be added to the message allowing you to detect and handle function errors with a xref:components:processors/branch.adoc[`branch`]:\n\n```yaml\npipeline:\n  processors:\n    - branch:\n        processors:\n          - aws_lambda:\n              function: foo\n        result_map: |\n          root = if meta().exists(\"lambda_function_error\") {\n            throw(\"Invocation failed due to %v: %v\".format(this.errorType, this.errorMessage))\n          } else {\n            this\n          }\noutput:\n  switch:\n    retry_until_success: false\n    cases:\n      - check: errored()\n        output:\n          reject: ${! error() }\n      - output:\n          resource: somewhere_else\n```\n\n== Credentials\n\nBy default Redpanda Connect will use a shared credentials file when connecting to AWS services. It's also possible to set them explicitly at the component level, allowing you to transfer data across accounts. You can find out more in xref:guides:cloud/aws.adoc[].",
      "config": {
        "credentials": {
          "name": "credentials",
          "type": "object",
          "kind": "scalar",
          "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "profile",
              "type": "string",
              "kind": "scalar",
              "description": "A profile from `~/.aws/credentials` to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "id",
              "type": "string",
              "kind": "scalar",
              "description": "The ID of credentials to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "secret",
              "type": "string",
              "kind": "scalar",
              "description": "The secret for the credentials being used.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token",
              "type": "string",
              "kind": "scalar",
              "description": "The token for the credentials being used, required when using short term credentials.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "from_ec2_role",
              "type": "bool",
              "kind": "scalar",
              "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "role",
              "type": "string",
              "kind": "scalar",
              "description": "A role ARN to assume.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "role_external_id",
              "type": "string",
              "kind": "scalar",
              "description": "An external ID to provide when assuming a role.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "Allows you to specify a custom endpoint for the AWS API.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "function": {
          "name": "function",
          "type": "string",
          "kind": "scalar",
          "description": "The function to invoke.",
          "required": true,
          "default": null
        },
        "parallel": {
          "name": "parallel",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages of a batch should be dispatched in parallel.",
          "required": true,
          "default": false
        },
        "rate_limit": {
          "name": "rate_limit",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:components:rate_limits/about.adoc[`rate_limit`] to throttle invocations by.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "region": {
          "name": "region",
          "type": "string",
          "kind": "scalar",
          "description": "The AWS region to target.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "retries": {
          "name": "retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retry attempts for each message.",
          "required": true,
          "default": 3,
          "advanced": true
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum period of time to wait before abandoning an invocation.",
          "required": true,
          "default": "5s",
          "advanced": true
        }
      }
    },
    "azure_cosmosdb": {
      "name": "azure_cosmosdb",
      "type": "processor",
      "source": "upstream",
      "summary": "Creates or updates messages as JSON documents in https://learn.microsoft.com/en-us/azure/cosmos-db/introduction[Azure CosmosDB^].",
      "description": "\nWhen creating documents, each message must have the `id` property (case-sensitive) set (or use `auto_id: true`). It is the unique name that identifies the document, that is, no two documents share the same `id` within a logical partition. The `id` field must not exceed 255 characters. https://learn.microsoft.com/en-us/rest/api/cosmos-db/documents[See details^].\n\nThe `partition_keys` field must resolve to the same value(s) across the entire message batch.\n\n\n== Credentials\n\nYou can use one of the following authentication mechanisms:\n\n- Set the `endpoint` field and the `account_key` field\n- Set only the `endpoint` field to use https://pkg.go.dev/github.com/Azure/azure-sdk-for-go/sdk/azidentity#DefaultAzureCredential[DefaultAzureCredential^]\n- Set the `connection_string` field\n\n\n== Metadata\n\nThis component adds the following metadata fields to each message:\n```\n- activity_id\n- request_charge\n```\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation].\n\n\n== Batching\n\nCosmosDB limits the maximum batch size to 100 messages and the payload must not exceed 2MB (https://learn.microsoft.com/en-us/azure/cosmos-db/concepts-limits#per-request-limits[details here^]).\n",
      "config": {
        "account_key": {
          "name": "account_key",
          "type": "string",
          "kind": "scalar",
          "description": "Account key.",
          "required": false,
          "default": null,
          "examples": [
            "C2y6yDjf5/R+ob0N8A7Cgv30VRDJIWEHLM+4QDU5DE2nQ9nDuVTqobD4b8mGGyPMbIZnqyMsEcaGQy67XIw/Jw=="
          ]
        },
        "auto_id": {
          "name": "auto_id",
          "type": "bool",
          "kind": "scalar",
          "description": "Automatically set the item `id` field to a random UUID v4. If the `id` field is already set, then it will not be overwritten. Setting this to `false` can improve performance, since the messages will not have to be parsed.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "connection_string": {
          "name": "connection_string",
          "type": "string",
          "kind": "scalar",
          "description": "Connection string.",
          "required": false,
          "default": null,
          "examples": [
            "AccountEndpoint=https://localhost:8081/;AccountKey=C2y6yDjf5/R+ob0N8A7Cgv30VRDJIWEHLM+4QDU5DE2nQ9nDuVTqobD4b8mGGyPMbIZnqyMsEcaGQy67XIw/Jw==;"
          ]
        },
        "container": {
          "name": "container",
          "type": "string",
          "kind": "scalar",
          "description": "Container.",
          "required": true,
          "default": null,
          "examples": [
            "testcontainer"
          ]
        },
        "database": {
          "name": "database",
          "type": "string",
          "kind": "scalar",
          "description": "Database.",
          "required": true,
          "default": null,
          "examples": [
            "testdb"
          ]
        },
        "enable_content_response_on_write": {
          "name": "enable_content_response_on_write",
          "type": "bool",
          "kind": "scalar",
          "description": "Enable content response on write operations. To save some bandwidth, set this to false if you don't need to receive the updated message(s) from the server, in which case the processor will not modify the content of the messages which are fed into it. Applies to every operation except Read.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "CosmosDB endpoint.",
          "required": false,
          "default": null,
          "examples": [
            "https://localhost:8081"
          ]
        },
        "item_id": {
          "name": "item_id",
          "type": "string",
          "kind": "scalar",
          "description": "ID of item to replace or delete. Only used by the Replace and Delete operations",
          "required": false,
          "default": null,
          "examples": [
            "${! json(\"id\") }"
          ]
        },
        "operation": {
          "name": "operation",
          "type": "string",
          "kind": "scalar",
          "description": "Operation.",
          "required": true,
          "default": "Create"
        },
        "partition_keys_map": {
          "name": "partition_keys_map",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to a single partition key value or an array of partition key values of type string, integer or boolean. Currently, hierarchical partition keys are not supported so only one value may be provided.",
          "required": true,
          "default": null,
          "examples": [
            "root = \"blobfish\"",
            "root = 41",
            "root = true",
            "root = null",
            "root = json(\"blobfish\").depth"
          ]
        },
        "patch_condition": {
          "name": "patch_condition",
          "type": "string",
          "kind": "scalar",
          "description": "Patch operation condition.",
          "required": false,
          "default": null,
          "examples": [
            "from c where not is_defined(c.blobfish)"
          ],
          "advanced": true
        },
        "patch_operations": {
          "name": "patch_operations",
          "type": "object",
          "kind": "array",
          "description": "Patch operations to be performed when `operation: Patch` .",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "operation",
              "type": "string",
              "kind": "scalar",
              "description": "Operation.",
              "required": true,
              "default": "Add",
              "advanced": true
            },
            {
              "name": "path",
              "type": "string",
              "kind": "scalar",
              "description": "Path.",
              "required": true,
              "default": null,
              "examples": [
                "/foo/bar/baz"
              ],
              "advanced": true
            },
            {
              "name": "value_map",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to a value of any type that is supported by CosmosDB.",
              "required": false,
              "default": null,
              "examples": [
                "root = \"blobfish\"",
                "root = 41",
                "root = true",
                "root = json(\"blobfish\").depth",
                "root = [1, 2, 3]"
              ],
              "advanced": true
            }
          ]
        }
      }
    },
    "benchmark": {
      "name": "benchmark",
      "type": "processor",
      "source": "upstream",
      "summary": "Logs basic throughput statistics of messages that pass through this processor.",
      "description": "Logs messages per second and bytes per second of messages that are processed at a regular interval. A summary of the amount of messages processed over the entire lifetime of the processor will also be printed when the processor shuts down.",
      "config": {
        "count_bytes": {
          "name": "count_bytes",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether or not to measure the number of bytes per second of throughput. Counting the number of bytes requires serializing structured data, which can cause an unnecessary performance hit if serialization is not required elsewhere in the pipeline.",
          "required": true,
          "default": true
        },
        "interval": {
          "name": "interval",
          "type": "string",
          "kind": "scalar",
          "description": "How often to emit rolling statistics. If set to 0, only a summary will be logged when the processor shuts down.",
          "required": true,
          "default": "5s"
        }
      }
    },
    "bloblang": {
      "name": "bloblang",
      "type": "processor",
      "source": "upstream",
      "summary": "Executes a xref:guides:bloblang/about.adoc[Bloblang] mapping on messages.",
      "description": "\nBloblang is a powerful language that enables a wide range of mapping, transformation and filtering tasks. For more information see xref:guides:bloblang/about.adoc[].\n\nIf your mapping is large and you'd prefer for it to live in a separate file then you can execute a mapping directly from a file with the expression `from \"\u003cpath\u003e\"`, where the path must be absolute, or relative from the location that Redpanda Connect is executed from.\n\n== Component rename\n\nThis processor was recently renamed to the xref:components:processors/mapping.adoc[`mapping` processor] in order to make the purpose of the processor more prominent. It is still valid to use the existing `bloblang` name but eventually it will be deprecated and replaced by the new name in example configs.",
      "config": {}
    },
    "bounds_check": {
      "name": "bounds_check",
      "type": "processor",
      "source": "upstream",
      "summary": "Removes messages (and batches) that do not fit within certain size boundaries.",
      "config": {
        "max_part_size": {
          "name": "max_part_size",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum size of a message to allow (in bytes)",
          "required": true,
          "default": 1073741824
        },
        "max_parts": {
          "name": "max_parts",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum size of message batches to allow (in message count)",
          "required": true,
          "default": 100,
          "advanced": true
        },
        "min_part_size": {
          "name": "min_part_size",
          "type": "int",
          "kind": "scalar",
          "description": "The minimum size of a message to allow (in bytes)",
          "required": true,
          "default": 1
        },
        "min_parts": {
          "name": "min_parts",
          "type": "int",
          "kind": "scalar",
          "description": "The minimum size of message batches to allow (in message count)",
          "required": true,
          "default": 1,
          "advanced": true
        }
      }
    },
    "branch": {
      "name": "branch",
      "type": "processor",
      "source": "upstream",
      "summary": "The `branch` processor allows you to create a new request message via a xref:guides:bloblang/about.adoc[Bloblang mapping], execute a list of processors on the request messages, and, finally, map the result back into the source message using another mapping.",
      "description": "\nThis is useful for preserving the original message contents when using processors that would otherwise replace the entire contents.\n\n== Metadata\n\nMetadata fields that are added to messages during branch processing will not be automatically copied into the resulting message. In order to do this you should explicitly declare in your `result_map` either a wholesale copy with `meta = metadata()`, or selective copies with `meta foo = metadata(\"bar\")` and so on. It is also possible to reference the metadata of the origin message in the `result_map` using the xref:guides:bloblang/about.adoc#metadata[`@` operator].\n\n== Error handling\n\nIf the `request_map` fails the child processors will not be executed. If the child processors themselves result in an (uncaught) error then the `result_map` will not be executed. If the `result_map` fails the message will remain unchanged. Under any of these conditions standard xref:configuration:error_handling.adoc[error handling methods] can be used in order to filter, DLQ or recover the failed messages.\n\n== Conditional branching\n\nIf the root of your request map is set to `deleted()` then the branch processors are skipped for the given message, this allows you to conditionally branch messages.",
      "config": {
        "processors": {
          "name": "processors",
          "type": "processor",
          "kind": "array",
          "description": "A list of processors to apply to mapped requests. When processing message batches the resulting batch must match the size and ordering of the input batch, therefore filtering, grouping should not be performed within these processors.",
          "required": true,
          "default": null
        },
        "request_map": {
          "name": "request_map",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] that describes how to create a request payload suitable for the child processors of this branch. If left empty then the branch will begin with an exact copy of the origin message (including metadata).",
          "required": true,
          "default": "",
          "examples": [
            "root = {\n\t\"id\": this.doc.id,\n\t\"content\": this.doc.body.text\n}",
            "root = if this.type == \"foo\" {\n\tthis.foo.request\n} else {\n\tdeleted()\n}"
          ]
        },
        "result_map": {
          "name": "result_map",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] that describes how the resulting messages from branched processing should be mapped back into the original payload. If left empty the origin message will remain unchanged (including metadata).",
          "required": true,
          "default": "",
          "examples": [
            "meta foo_code = metadata(\"code\")\nroot.foo_result = this",
            "meta = metadata()\nroot.bar.body = this.body\nroot.bar.id = this.user.id",
            "root.raw_result = content().string()",
            "root.enrichments.foo = if metadata(\"request_failed\") != null {\n  throw(metadata(\"request_failed\"))\n} else {\n  this\n}",
            "# Retain only the updated metadata fields which were present in the origin message\nmeta = metadata().filter(v -\u003e @.get(v.key) != null)"
          ]
        }
      }
    },
    "cache": {
      "name": "cache",
      "type": "processor",
      "source": "upstream",
      "summary": "Performs operations against a xref:components:caches/about.adoc[cache resource] for each message, allowing you to store or retrieve data within message payloads.",
      "description": "\nFor use cases where you wish to cache the result of processors consider using the xref:components:processors/cached.adoc[`cached` processor] instead.\n\nThis processor will interpolate functions within the `key` and `value` fields individually for each message. This allows you to specify dynamic keys and values based on the contents of the message payloads and metadata. You can find a list of functions in xref:configuration:interpolation.adoc#bloblang-queries[Bloblang queries].",
      "config": {
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "A key to use with the cache.",
          "required": true,
          "default": null
        },
        "operator": {
          "name": "operator",
          "type": "string",
          "kind": "scalar",
          "description": "The \u003c\u003coperators, operation\u003e\u003e to perform with the cache.",
          "required": true,
          "default": null,
          "options": [
            "set",
            "add",
            "get",
            "delete",
            "exists"
          ]
        },
        "resource": {
          "name": "resource",
          "type": "string",
          "kind": "scalar",
          "description": "The xref:components:caches/about.adoc[`cache` resource] to target with this processor.",
          "required": true,
          "default": null
        },
        "ttl": {
          "name": "ttl",
          "type": "string",
          "kind": "scalar",
          "description": "The TTL of each individual item as a duration string. After this period an item will be eligible for removal during the next compaction. Not all caches support per-key TTLs, those that do will have a configuration field `default_ttl`, and those that do not will fall back to their generally configured TTL setting.",
          "required": false,
          "default": null,
          "examples": [
            "60s",
            "5m",
            "36h"
          ],
          "advanced": true
        },
        "value": {
          "name": "value",
          "type": "string",
          "kind": "scalar",
          "description": "A value to use with the cache (when applicable).",
          "required": false,
          "default": null
        }
      }
    },
    "cached": {
      "name": "cached",
      "type": "processor",
      "source": "upstream",
      "summary": "Cache the result of applying one or more processors to messages identified by a key. If the key already exists within the cache the contents of the message will be replaced with the cached result instead of applying the processors. This component is therefore useful in situations where an expensive set of processors need only be executed periodically.",
      "description": "The format of the data when stored within the cache is a custom and versioned schema chosen to balance performance and storage space. It is therefore not possible to point this processor to a cache that is pre-populated with data that this processor has not created itself.",
      "config": {
        "cache": {
          "name": "cache",
          "type": "string",
          "kind": "scalar",
          "description": "The cache resource to read and write processor results from.",
          "required": true,
          "default": null
        },
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "A key to be resolved for each message, if the key already exists in the cache then the cached result is used, otherwise the processors are applied and the result is cached under this key. The key could be static and therefore apply generally to all messages or it could be an interpolated expression that is potentially unique for each message.",
          "required": true,
          "default": null,
          "examples": [
            "my_foo_result",
            "${! this.document.id }",
            "${! meta(\"kafka_key\") }",
            "${! meta(\"kafka_topic\") }"
          ]
        },
        "processors": {
          "name": "processors",
          "type": "processor",
          "kind": "array",
          "description": "The list of processors whose result will be cached.",
          "required": true,
          "default": null
        },
        "skip_on": {
          "name": "skip_on",
          "type": "string",
          "kind": "scalar",
          "description": "A condition that can be used to skip caching the results from the processors.",
          "required": false,
          "default": null,
          "examples": [
            "errored()"
          ]
        },
        "ttl": {
          "name": "ttl",
          "type": "string",
          "kind": "scalar",
          "description": "An optional expiry period to set for each cache entry. Some caches only have a general TTL and will therefore ignore this setting.",
          "required": false,
          "default": null
        }
      }
    },
    "catch": {
      "name": "catch",
      "type": "processor",
      "source": "upstream",
      "summary": "Applies a list of child processors _only_ when a previous processing step has failed.",
      "description": "\nBehaves similarly to the xref:components:processors/for_each.adoc[`for_each`] processor, where a list of child processors are applied to individual messages of a batch. However, processors are only applied to messages that failed a processing step prior to the catch.\n\nFor example, with the following config:\n\n```yaml\npipeline:\n  processors:\n    - resource: foo\n    - catch:\n      - resource: bar\n      - resource: baz\n```\n\nIf the processor `foo` fails for a particular message, that message will be fed into the processors `bar` and `baz`. Messages that do not fail for the processor `foo` will skip these processors.\n\nWhen messages leave the catch block their fail flags are cleared. This processor is useful for when it's possible to recover failed messages, or when special actions (such as logging/metrics) are required before dropping them.\n\nMore information about error handling can be found in xref:configuration:error_handling.adoc[].",
      "config": {}
    },
    "classic_to_core": {
      "name": "classic_to_core",
      "type": "processor",
      "source": "benthos-umh",
      "summary": "Convert UMH Historian Data Contract format to Core format",
      "description": "The classic_to_core processor converts Historian Data Contract messages containing multiple values \nand tag groups into individual Core format messages, following the \"one tag, one message, one topic\" principle.\n\nInput format (Historian Data Contract):\n- Single message with timestamp_ms and multiple data fields or tag groups\n- Topic: umh.v1.\u003clocation\u003e._historian.\u003ccontext\u003e\n- Supports flat tags: {\"timestamp_ms\": 123, \"temperature\": 23.4}\n- Supports tag groups: {\"timestamp_ms\": 123, \"axis\": {\"x\": 1.0, \"y\": 2.0}}\n- Supports arrays: {\"timestamp_ms\": 123, \"values\": [10, 20, 30]}\n- Supports meta/metadata fields: {\"timestamp_ms\": 123, \"temperature\": 23.4, \"meta\": {\"sensor_id\": \"ABC123\"}}\n\nOutput format (Core):\n- Multiple messages, one per tag (including flattened tag groups and converted arrays)\n- Each with {\"value\": \u003cfield_value\u003e, \"timestamp_ms\": \u003ctimestamp\u003e}\n- Topics: umh.v1.\u003clocation\u003e.\u003ctarget_data_contract\u003e.\u003ccontext\u003e.\u003ctag_name\u003e\n- Tag groups flattened with dot separators: \"axis.x\", \"axis.y\"\n- Arrays converted to string format: \"values\": \"[10 20 30]\"\n- Meta/metadata fields applied as metadata to all output messages\n\nThe processor will:\n1. Extract the timestamp field from the payload\n2. Extract meta and metadata fields for applying to all output messages  \n3. Flatten any nested tag groups using dot separator for intuitive paths\n4. Convert arrays to string representation to ensure UMH-Core scalar-only compliance\n5. Create one output message per tag\n6. Construct new topics by appending tag names\n7. Preserve original metadata while updating topic-related fields\n8. Apply meta/metadata field contents as metadata to all generated messages",
      "config": {
        "target_data_contract": {
          "name": "target_data_contract",
          "type": "string",
          "kind": "scalar",
          "description": "Target data contract for output topics. If empty, uses the input's data contract (e.g., _historian)",
          "required": false,
          "default": ""
        }
      }
    },
    "command": {
      "name": "command",
      "type": "processor",
      "source": "upstream",
      "summary": "Executes a command for each message.",
      "description": "\nThe specified command is executed for each message processed, with the raw bytes of the message being fed into the stdin of the command process, and the resulting message having its contents replaced with the stdout of it.\n\n== Performance\n\nSince this processor executes a new process for each message performance will likely be an issue for high throughput streams. If this is the case then consider using the xref:components:processors/subprocess.adoc[`subprocess` processor] instead as it keeps the underlying process alive long term and uses codecs to insert and extract inputs and outputs to it via stdin/stdout.\n\n== Error handling\n\nIf a non-zero error code is returned by the command then an error containing the entirety of stderr (or a generic message if nothing is written) is set on the message. These failed messages will continue through the pipeline unchanged, but can be dropped or placed in a dead letter queue according to your config, you can read about xref:configuration:error_handling.adoc[these patterns].\n\nIf the command is successful but stderr is written to then a metadata field `command_stderr` is populated with its contents.\n",
      "config": {
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:guides:bloblang/about.adoc[Bloblang mapping] that, when specified, should resolve into an array of arguments to pass to the command. Command arguments are expressed this way in order to support dynamic behavior.",
          "required": false,
          "default": null,
          "examples": [
            "[ \"-c\", this.script_path ]"
          ]
        },
        "name": {
          "name": "name",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the command to execute.",
          "required": true,
          "default": null,
          "examples": [
            "bash",
            "go",
            "${! @command }"
          ]
        }
      }
    },
    "compress": {
      "name": "compress",
      "type": "processor",
      "source": "upstream",
      "summary": "Compresses messages according to the selected algorithm. Supported compression algorithms are: [flate gzip lz4 pgzip snappy zlib]",
      "description": "The 'level' field might not apply to all algorithms.",
      "config": {
        "algorithm": {
          "name": "algorithm",
          "type": "string",
          "kind": "scalar",
          "description": "The compression algorithm to use.",
          "required": true,
          "default": null,
          "options": [
            "flate",
            "gzip",
            "lz4",
            "pgzip",
            "snappy",
            "zlib"
          ]
        },
        "level": {
          "name": "level",
          "type": "int",
          "kind": "scalar",
          "description": "The level of compression to use. May not be applicable to all algorithms.",
          "required": true,
          "default": -1
        }
      }
    },
    "couchbase": {
      "name": "couchbase",
      "type": "processor",
      "source": "upstream",
      "summary": "Performs operations against Couchbase for each message, allowing you to store or retrieve data within message payloads.",
      "description": "When inserting, replacing or upserting documents, each must have the `content` property set.",
      "config": {
        "bucket": {
          "name": "bucket",
          "type": "string",
          "kind": "scalar",
          "description": "Couchbase bucket.",
          "required": true,
          "default": null
        },
        "collection": {
          "name": "collection",
          "type": "string",
          "kind": "scalar",
          "description": "Bucket collection.",
          "required": false,
          "default": "_default",
          "advanced": true
        },
        "content": {
          "name": "content",
          "type": "string",
          "kind": "scalar",
          "description": "Document content.",
          "required": false,
          "default": null
        },
        "id": {
          "name": "id",
          "type": "string",
          "kind": "scalar",
          "description": "Document id.",
          "required": true,
          "default": null,
          "examples": [
            "${! json(\"id\") }"
          ]
        },
        "operation": {
          "name": "operation",
          "type": "string",
          "kind": "scalar",
          "description": "Couchbase operation to perform.",
          "required": true,
          "default": "get"
        },
        "password": {
          "name": "password",
          "type": "string",
          "kind": "scalar",
          "description": "Password to connect to the cluster.",
          "required": false,
          "default": null
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "Operation timeout.",
          "required": true,
          "default": "15s",
          "advanced": true
        },
        "transcoder": {
          "name": "transcoder",
          "type": "string",
          "kind": "scalar",
          "description": "Couchbase transcoder to use.",
          "required": true,
          "default": "legacy",
          "advanced": true
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "Couchbase connection string.",
          "required": true,
          "default": null,
          "examples": [
            "couchbase://localhost:11210"
          ]
        },
        "username": {
          "name": "username",
          "type": "string",
          "kind": "scalar",
          "description": "Username to connect to the cluster.",
          "required": false,
          "default": null
        }
      }
    },
    "crash": {
      "name": "crash",
      "type": "processor",
      "source": "upstream",
      "summary": "Crashes the process using a fatal log message. The log message can be set using function interpolations described in  xref:configuration:interpolation.adoc#bloblang-queries[Bloblang queries] which allows you to log the contents and metadata of messages.",
      "config": {}
    },
    "decompress": {
      "name": "decompress",
      "type": "processor",
      "source": "upstream",
      "summary": "Decompresses messages according to the selected algorithm. Supported decompression algorithms are: [bzip2 flate gzip lz4 pgzip snappy zlib]",
      "config": {
        "algorithm": {
          "name": "algorithm",
          "type": "string",
          "kind": "scalar",
          "description": "The decompression algorithm to use.",
          "required": true,
          "default": null,
          "options": [
            "bzip2",
            "flate",
            "gzip",
            "lz4",
            "pgzip",
            "snappy",
            "zlib"
          ]
        }
      }
    },
    "dedupe": {
      "name": "dedupe",
      "type": "processor",
      "source": "upstream",
      "summary": "Deduplicates messages by storing a key value in a cache using the `add` operator. If the key already exists within the cache it is dropped.",
      "description": "\nCaches must be configured as resources, for more information check out the xref:components:caches/about.adoc[cache documentation].\n\nWhen using this processor with an output target that might fail you should always wrap the output within an indefinite xref:components:outputs/retry.adoc[`retry`] block. This ensures that during outages your messages aren't reprocessed after failures, which would result in messages being dropped.\n\n== Batch deduplication\n\nThis processor enacts on individual messages only, in order to perform a deduplication on behalf of a batch (or window) of messages instead use the xref:components:processors/cache.adoc#examples[`cache` processor].\n\n== Delivery guarantees\n\nPerforming deduplication on a stream using a distributed cache voids any at-least-once guarantees that it previously had. This is because the cache will preserve message signatures even if the message fails to leave the Redpanda Connect pipeline, which would cause message loss in the event of an outage at the output sink followed by a restart of the Redpanda Connect instance (or a server crash, etc).\n\nThis problem can be mitigated by using an in-memory cache and distributing messages to horizontally scaled Redpanda Connect pipelines partitioned by the deduplication key. However, in situations where at-least-once delivery guarantees are important it is worth avoiding deduplication in favour of implement idempotent behavior at the edge of your stream pipelines.",
      "config": {
        "cache": {
          "name": "cache",
          "type": "string",
          "kind": "scalar",
          "description": "The xref:components:caches/about.adoc[`cache` resource] to target with this processor.",
          "required": true,
          "default": null
        },
        "drop_on_err": {
          "name": "drop_on_err",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages should be dropped when the cache returns a general error such as a network issue.",
          "required": true,
          "default": true
        },
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "An interpolated string yielding the key to deduplicate by for each message.",
          "required": true,
          "default": null,
          "examples": [
            "${! meta(\"kafka_key\") }",
            "${! content().hash(\"xxhash64\") }"
          ]
        }
      }
    },
    "downsampler": {
      "name": "downsampler",
      "type": "processor",
      "source": "benthos-umh",
      "summary": "Downsamples time-series data using configurable algorithms",
      "description": "The downsampler reduces data volume by filtering out insignificant changes in time-series data using configurable algorithms.\n\nIt processes UMH-core time-series data with data_contract \"_historian\",\npassing all other messages through unchanged. Each message that passes the downsampling filter is annotated\nwith metadata indicating the algorithm used.\n\nIn typical UMH deployments, the downsampler is enabled by default with conservative settings to automatically\ncompress time-series data. The tag_processor can be used upstream to selectively bypass downsampling for\ncritical data by setting the ds_ignore metadata field.\n\nSupported format:\n- UMH-core: Single \"value\" field with timestamp (one tag, one message, one topic)\n- Requires \"umh_topic\" metadata field to identify the time series\n\nThe plugin maintains separate state for each time series (identified by umh_topic) and applies the configured algorithm\nto determine whether each data point represents a significant change worth preserving.\n\n## Data Type Handling\n\nThe downsampler handles different data types as follows:\n\n- **Numeric values** (int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64):\n  Converted to float64 for algorithm processing and output. This ensures consistent precision and compatibility\n  with all downsampling algorithms.\n\n- **Boolean values** (true, false):\n  Preserved as-is. Uses change-based logic - only emits when the boolean value changes.\n\n- **String values**:\n  Preserved as-is. Uses change-based logic - only emits when the string value changes.\n\n- **Other types**:\n  Rejected with an error to ensure data integrity.\n\n## Selective Bypass with ds_ignore\n\nThe ds_ignore metadata key allows selective bypass of downsampling on a per-message basis:\n\n- Any message with ds_ignore metadata (any non-empty value) completely bypasses all downsampling logic\n- Designed for use with tag_processor to identify critical data that must be preserved unchanged\n- Common use cases: emergency alarms, state changes, calibration data, precision measurements\n- Bypassed messages are marked with downsampled_by: \"ignored\" and counted in messages_ignored metric\n\nUse with tag_processor for UMH deployments to selectively bypass downsampling based on message characteristics.",
      "config": {
        "allow_meta_overrides": {
          "name": "allow_meta_overrides",
          "type": "bool",
          "kind": "scalar",
          "description": "Honour per-message ds_* metadata.",
          "required": true,
          "default": true
        },
        "default": {
          "name": "default",
          "type": "object",
          "kind": "scalar",
          "description": "Default algorithm parameters applied to all topics unless overridden.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "deadband",
              "type": "object",
              "kind": "scalar",
              "description": "Default deadband algorithm parameters.",
              "required": false,
              "default": null,
              "children": [
                {
                  "name": "threshold",
                  "type": "float",
                  "kind": "scalar",
                  "description": "Default threshold for deadband algorithm.",
                  "required": false,
                  "default": null
                },
                {
                  "name": "max_time",
                  "type": "string",
                  "kind": "scalar",
                  "description": "Default maximum time interval for deadband algorithm.",
                  "required": false,
                  "default": null
                },
                {
                  "name": "min_time",
                  "type": "string",
                  "kind": "scalar",
                  "description": "Default minimum time between emissions for deadband algorithm.",
                  "required": false,
                  "default": null
                }
              ]
            },
            {
              "name": "swinging_door",
              "type": "object",
              "kind": "scalar",
              "description": "Default swinging door algorithm parameters.",
              "required": false,
              "default": null,
              "children": [
                {
                  "name": "threshold",
                  "type": "float",
                  "kind": "scalar",
                  "description": "Default compression deviation for swinging door algorithm.",
                  "required": false,
                  "default": null
                },
                {
                  "name": "max_time",
                  "type": "string",
                  "kind": "scalar",
                  "description": "Default maximum time interval for swinging door algorithm.",
                  "required": false,
                  "default": null
                },
                {
                  "name": "min_time",
                  "type": "string",
                  "kind": "scalar",
                  "description": "Default minimum time between emissions for swinging door algorithm.",
                  "required": false,
                  "default": null
                }
              ]
            },
            {
              "name": "late_policy",
              "type": "string",
              "kind": "scalar",
              "description": "Default policy for handling late-arriving messages (passthrough=forward unchanged, drop=discard with warning).",
              "required": false,
              "default": "passthrough",
              "options": [
                "passthrough",
                "drop"
              ]
            }
          ]
        },
        "overrides": {
          "name": "overrides",
          "type": "object",
          "kind": "array",
          "description": "Topic-specific parameter overrides using pattern matching. Supports exact topic names and shell-style wildcards (* matches any sequence, ? matches any character).",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "pattern",
              "type": "string",
              "kind": "scalar",
              "description": "Topic pattern for matching (supports exact matches and shell-style wildcards with * and ?). Examples: 'umh.v1.acme._historian.temp.sensor1' (exact), '*.temperature.*' (wildcard), '*pressure*' (contains).",
              "required": true,
              "default": null
            },
            {
              "name": "deadband",
              "type": "object",
              "kind": "scalar",
              "description": "Deadband algorithm parameter overrides.",
              "required": false,
              "default": null,
              "children": [
                {
                  "name": "threshold",
                  "type": "float",
                  "kind": "scalar",
                  "description": "Override threshold for deadband algorithm.",
                  "required": false,
                  "default": null
                },
                {
                  "name": "max_time",
                  "type": "string",
                  "kind": "scalar",
                  "description": "Override maximum time interval for deadband algorithm.",
                  "required": false,
                  "default": null
                },
                {
                  "name": "min_time",
                  "type": "string",
                  "kind": "scalar",
                  "description": "Override minimum time between emissions for deadband algorithm.",
                  "required": false,
                  "default": null
                }
              ]
            },
            {
              "name": "swinging_door",
              "type": "object",
              "kind": "scalar",
              "description": "Swinging door algorithm parameter overrides.",
              "required": false,
              "default": null,
              "children": [
                {
                  "name": "threshold",
                  "type": "float",
                  "kind": "scalar",
                  "description": "Override compression deviation for swinging door algorithm.",
                  "required": false,
                  "default": null
                },
                {
                  "name": "max_time",
                  "type": "string",
                  "kind": "scalar",
                  "description": "Override maximum time interval for swinging door algorithm.",
                  "required": false,
                  "default": null
                },
                {
                  "name": "min_time",
                  "type": "string",
                  "kind": "scalar",
                  "description": "Override minimum time between emissions for swinging door algorithm.",
                  "required": false,
                  "default": null
                }
              ]
            },
            {
              "name": "late_policy",
              "type": "string",
              "kind": "scalar",
              "description": "Override policy for handling late-arriving messages (passthrough=forward unchanged, drop=discard with warning).",
              "required": false,
              "default": null,
              "options": [
                "passthrough",
                "drop"
              ]
            }
          ]
        }
      }
    },
    "for_each": {
      "name": "for_each",
      "type": "processor",
      "source": "upstream",
      "summary": "A processor that applies a list of child processors to messages of a batch as though they were each a batch of one message.",
      "description": "\nThis is useful for forcing batch wide processors such as xref:components:processors/dedupe.adoc[`dedupe`] or interpolations such as the `value` field of the `metadata` processor to execute on individual message parts of a batch instead.\n\nPlease note that most processors already process per message of a batch, and this processor is not needed in those cases.",
      "config": {}
    },
    "gcp_bigquery_select": {
      "name": "gcp_bigquery_select",
      "type": "processor",
      "source": "upstream",
      "summary": "Executes a `SELECT` query against BigQuery and replaces messages with the rows returned.",
      "config": {
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to an array of values matching in size to the number of placeholder arguments in the field `where`.",
          "required": false,
          "default": null,
          "examples": [
            "root = [ \"article\", now().ts_format(\"2006-01-02\") ]"
          ]
        },
        "columns": {
          "name": "columns",
          "type": "string",
          "kind": "array",
          "description": "A list of columns to query.",
          "required": true,
          "default": null
        },
        "credentials_json": {
          "name": "credentials_json",
          "type": "string",
          "kind": "scalar",
          "description": "An optional field to set Google Service Account Credentials json.",
          "required": true,
          "default": ""
        },
        "job_labels": {
          "name": "job_labels",
          "type": "string",
          "kind": "map",
          "description": "A list of labels to add to the query job.",
          "required": true,
          "default": {}
        },
        "prefix": {
          "name": "prefix",
          "type": "string",
          "kind": "scalar",
          "description": "An optional prefix to prepend to the select query (before SELECT).",
          "required": false,
          "default": null
        },
        "project": {
          "name": "project",
          "type": "string",
          "kind": "scalar",
          "description": "GCP project where the query job will execute.",
          "required": true,
          "default": null
        },
        "suffix": {
          "name": "suffix",
          "type": "string",
          "kind": "scalar",
          "description": "An optional suffix to append to the select query.",
          "required": false,
          "default": null
        },
        "table": {
          "name": "table",
          "type": "string",
          "kind": "scalar",
          "description": "Fully-qualified BigQuery table name to query.",
          "required": true,
          "default": null,
          "examples": [
            "bigquery-public-data.samples.shakespeare"
          ]
        },
        "where": {
          "name": "where",
          "type": "string",
          "kind": "scalar",
          "description": "An optional where clause to add. Placeholder arguments are populated with the `args_mapping` field. Placeholders should always be question marks (`?`).",
          "required": false,
          "default": null,
          "examples": [
            "type = ? and created_at \u003e ?",
            "user_id = ?"
          ]
        }
      }
    },
    "grok": {
      "name": "grok",
      "type": "processor",
      "source": "upstream",
      "summary": "Parses messages into a structured format by attempting to apply a list of Grok expressions, the first expression to result in at least one value replaces the original message with a JSON object containing the values.",
      "description": "\nType hints within patterns are respected, therefore with the pattern `%\\{WORD:first},%{INT:second:int}` and a payload of `foo,1` the resulting payload would be `\\{\"first\":\"foo\",\"second\":1}`.\n\n== Performance\n\nThis processor currently uses the https://golang.org/s/re2syntax[Go RE2^] regular expression engine, which is guaranteed to run in time linear to the size of the input. However, this property often makes it less performant than PCRE based implementations of grok. For more information, see https://swtch.com/~rsc/regexp/regexp1.html.",
      "config": {
        "expressions": {
          "name": "expressions",
          "type": "string",
          "kind": "array",
          "description": "One or more Grok expressions to attempt against incoming messages. The first expression to match at least one value will be used to form a result.",
          "required": true,
          "default": null
        },
        "named_captures_only": {
          "name": "named_captures_only",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to only capture values from named patterns.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "pattern_definitions": {
          "name": "pattern_definitions",
          "type": "string",
          "kind": "map",
          "description": "A map of pattern definitions that can be referenced within `patterns`.",
          "required": true,
          "default": {}
        },
        "pattern_paths": {
          "name": "pattern_paths",
          "type": "string",
          "kind": "array",
          "description": "A list of paths to load Grok patterns from. This field supports wildcards, including super globs (double star).",
          "required": true,
          "default": []
        },
        "remove_empty_values": {
          "name": "remove_empty_values",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to remove values that are empty from the resulting structure.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "use_default_patterns": {
          "name": "use_default_patterns",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to use a \u003c\u003cdefault-patterns, default set of patterns\u003e\u003e.",
          "required": true,
          "default": true,
          "advanced": true
        }
      }
    },
    "group_by": {
      "name": "group_by",
      "type": "processor",
      "source": "upstream",
      "summary": "Splits a xref:configuration:batching.adoc[batch of messages] into N batches, where each resulting batch contains a group of messages determined by a xref:guides:bloblang/about.adoc[Bloblang query].",
      "description": "\nOnce the groups are established a list of processors are applied to their respective grouped batch, which can be used to label the batch as per their grouping. Messages that do not pass the check of any specified group are placed in their own group.\n\nThe functionality of this processor depends on being applied across messages that are batched. You can find out more about batching xref:configuration:batching.adoc[in this doc].",
      "config": {
        "check": {
          "name": "check",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message belongs to a given group.",
          "required": true,
          "default": null,
          "examples": [
            "this.type == \"foo\"",
            "this.contents.urls.contains(\"https://benthos.dev/\")",
            "true"
          ]
        },
        "processors": {
          "name": "processors",
          "type": "processor",
          "kind": "array",
          "description": "A list of xref:components:processors/about.adoc[processors] to execute on the newly formed group.",
          "required": true,
          "default": []
        }
      }
    },
    "group_by_value": {
      "name": "group_by_value",
      "type": "processor",
      "source": "upstream",
      "summary": "Splits a batch of messages into N batches, where each resulting batch contains a group of messages determined by a xref:configuration:interpolation.adoc#bloblang-queries[function interpolated string] evaluated per message.",
      "description": "\nThis allows you to group messages using arbitrary fields within their content or metadata, process them individually, and send them to unique locations as per their group.\n\nThe functionality of this processor depends on being applied across messages that are batched. You can find out more about batching xref:configuration:batching.adoc[in this doc].",
      "config": {
        "value": {
          "name": "value",
          "type": "string",
          "kind": "scalar",
          "description": "The interpolated string to group based on.",
          "required": true,
          "default": null,
          "examples": [
            "${! meta(\"kafka_key\") }",
            "${! json(\"foo.bar\") }-${! meta(\"baz\") }"
          ]
        }
      }
    },
    "http": {
      "name": "http",
      "type": "processor",
      "source": "upstream",
      "summary": "Performs an HTTP request using a message batch as the request body, and replaces the original message parts with the body of the response.",
      "description": "\nThe `rate_limit` field can be used to specify a rate limit xref:components:rate_limits/about.adoc[resource] to cap the rate of requests across all parallel components service wide.\n\nThe URL and header values of this type can be dynamically set using function interpolations described xref:configuration:interpolation.adoc#bloblang-queries[here].\n\nIn order to map or encode the payload to a specific request body, and map the response back into the original payload instead of replacing it entirely, you can use the xref:components:processors/branch.adoc[`branch` processor].\n\n== Response codes\n\nRedpanda Connect considers any response code between 200 and 299 inclusive to indicate a successful response, you can add more success status codes with the field `successful_on`.\n\nWhen a request returns a response code within the `backoff_on` field it will be retried after increasing intervals.\n\nWhen a request returns a response code within the `drop_on` field it will not be reattempted and is immediately considered a failed request.\n\n== Add metadata\n\nIf the request returns an error response code this processor sets a metadata field `http_status_code` on the resulting message.\n\nUse the field `extract_headers` to specify rules for which other headers should be copied into the resulting message from the response.\n\n== Error handling\n\nWhen all retry attempts for a message are exhausted the processor cancels the attempt. These failed messages will continue through the pipeline unchanged, but can be dropped or placed in a dead letter queue according to your config, you can read about xref:configuration:error_handling.adoc[these patterns].",
      "config": {
        "backoff_on": {
          "name": "backoff_on",
          "type": "int",
          "kind": "array",
          "description": "A list of status codes whereby the request should be considered to have failed and retries should be attempted, but the period between them should be increased gradually.",
          "required": true,
          "default": [
            429
          ],
          "advanced": true
        },
        "basic_auth": {
          "name": "basic_auth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify basic authentication.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use basic authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "A username to authenticate as.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A password to authenticate with.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "batch_as_multipart": {
          "name": "batch_as_multipart",
          "type": "bool",
          "kind": "scalar",
          "description": "Send message batches as a single request using https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html[RFC1341^].",
          "required": true,
          "default": false,
          "advanced": true
        },
        "disable_http2": {
          "name": "disable_http2",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether or not to disable disable HTTP/2",
          "required": true,
          "default": false,
          "advanced": true
        },
        "drop_on": {
          "name": "drop_on",
          "type": "int",
          "kind": "array",
          "description": "A list of status codes whereby the request should be considered to have failed but retries should not be attempted. This is useful for preventing wasted retries for requests that will never succeed. Note that with these status codes the _request_ is dropped, but _message_ that caused the request will not be dropped.",
          "required": true,
          "default": [],
          "advanced": true
        },
        "dump_request_log_level": {
          "name": "dump_request_log_level",
          "type": "string",
          "kind": "scalar",
          "description": "EXPERIMENTAL: Optionally set a level at which the request and response payload of each request made will be logged.",
          "required": true,
          "default": "",
          "options": [
            "TRACE",
            "DEBUG",
            "INFO",
            "WARN",
            "ERROR",
            "FATAL",
            ""
          ],
          "advanced": true
        },
        "extract_headers": {
          "name": "extract_headers",
          "type": "object",
          "kind": "scalar",
          "description": "Specify which response headers should be added to resulting messages as metadata. Header keys are lowercased before matching, so ensure that your patterns target lowercased versions of the header keys that you expect.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "include_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  "foo_",
                  "bar_"
                ],
                [
                  "kafka_"
                ],
                [
                  "content-"
                ]
              ],
              "advanced": true
            },
            {
              "name": "include_patterns",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key regular expression (re2) patterns to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  ".*"
                ],
                [
                  "_timestamp_unix$"
                ]
              ],
              "advanced": true
            }
          ]
        },
        "follow_redirects": {
          "name": "follow_redirects",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether or not to transparently follow redirects, i.e. responses with 300-399 status codes. If disabled, the response message will contain the body, status, and headers from the redirect response and the processor will not make a request to the URL set in the Location header of the response.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "headers": {
          "name": "headers",
          "type": "string",
          "kind": "map",
          "description": "A map of headers to add to the request.",
          "required": true,
          "default": {},
          "examples": [
            {
              "Content-Type": "application/octet-stream",
              "traceparent": "${! tracing_span().traceparent }"
            }
          ]
        },
        "jwt": {
          "name": "jwt",
          "type": "object",
          "kind": "scalar",
          "description": "BETA: Allows you to specify JWT authentication.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use JWT authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "private_key_file",
              "type": "string",
              "kind": "scalar",
              "description": "A file with the PEM encoded via PKCS1 or PKCS8 as private key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "signing_method",
              "type": "string",
              "kind": "scalar",
              "description": "A method used to sign the token such as RS256, RS384, RS512 or EdDSA.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "claims",
              "type": "unknown",
              "kind": "map",
              "description": "A value used to identify the claims that issued the JWT.",
              "required": true,
              "default": {},
              "advanced": true
            },
            {
              "name": "headers",
              "type": "unknown",
              "kind": "map",
              "description": "Add optional key/value headers to the JWT.",
              "required": true,
              "default": {},
              "advanced": true
            }
          ]
        },
        "max_retry_backoff": {
          "name": "max_retry_backoff",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum period to wait between failed requests.",
          "required": true,
          "default": "300s",
          "advanced": true
        },
        "metadata": {
          "name": "metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Specify optional matching rules to determine which metadata keys should be added to the HTTP request as headers.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "include_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  "foo_",
                  "bar_"
                ],
                [
                  "kafka_"
                ],
                [
                  "content-"
                ]
              ],
              "advanced": true
            },
            {
              "name": "include_patterns",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key regular expression (re2) patterns to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  ".*"
                ],
                [
                  "_timestamp_unix$"
                ]
              ],
              "advanced": true
            }
          ]
        },
        "oauth": {
          "name": "oauth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify open authentication via OAuth version 1.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use OAuth version 1 in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "consumer_key",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to identify the client to the service provider.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "consumer_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret used to establish ownership of the consumer key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "access_token",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to gain access to the protected resources on behalf of the user.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "access_token_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret provided in order to establish ownership of a given access token.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "oauth2": {
          "name": "oauth2",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify open authentication via OAuth version 2 using the client credentials token flow.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use OAuth version 2 in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "client_key",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to identify the client to the token provider.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "client_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret used to establish ownership of the client key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token_url",
              "type": "string",
              "kind": "scalar",
              "description": "The URL of the token provider.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "scopes",
              "type": "string",
              "kind": "array",
              "description": "A list of optional requested permissions.",
              "required": true,
              "default": [],
              "advanced": true
            },
            {
              "name": "endpoint_params",
              "type": "unknown",
              "kind": "map",
              "description": "A list of optional endpoint parameters, values should be arrays of strings.",
              "required": false,
              "default": {},
              "examples": [
                {
                  "bar": [
                    "woof"
                  ],
                  "foo": [
                    "meow",
                    "quack"
                  ]
                }
              ],
              "advanced": true
            }
          ]
        },
        "parallel": {
          "name": "parallel",
          "type": "bool",
          "kind": "scalar",
          "description": "When processing batched messages, whether to send messages of the batch in parallel, otherwise they are sent serially.",
          "required": true,
          "default": false
        },
        "proxy_url": {
          "name": "proxy_url",
          "type": "string",
          "kind": "scalar",
          "description": "An optional HTTP proxy URL.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "rate_limit": {
          "name": "rate_limit",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:components:rate_limits/about.adoc[rate limit] to throttle requests by.",
          "required": false,
          "default": null
        },
        "retries": {
          "name": "retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retry attempts to make.",
          "required": true,
          "default": 3,
          "advanced": true
        },
        "retry_period": {
          "name": "retry_period",
          "type": "string",
          "kind": "scalar",
          "description": "The base period to wait between failed requests.",
          "required": true,
          "default": "1s",
          "advanced": true
        },
        "successful_on": {
          "name": "successful_on",
          "type": "int",
          "kind": "array",
          "description": "A list of status codes whereby the attempt should be considered successful, this is useful for dropping requests that return non-2XX codes indicating that the message has been dealt with, such as a 303 See Other or a 409 Conflict. All 2XX codes are considered successful unless they are present within `backoff_on` or `drop_on`, regardless of this field.",
          "required": true,
          "default": [],
          "advanced": true
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "A static timeout to apply to requests.",
          "required": true,
          "default": "5s"
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL to connect to.",
          "required": true,
          "default": null
        },
        "verb": {
          "name": "verb",
          "type": "string",
          "kind": "scalar",
          "description": "A verb to connect with",
          "required": true,
          "default": "POST",
          "examples": [
            "POST",
            "GET",
            "DELETE"
          ]
        }
      }
    },
    "insert_part": {
      "name": "insert_part",
      "type": "processor",
      "source": "upstream",
      "summary": "Insert a new message into a batch at an index. If the specified index is greater than the length of the existing batch it will be appended to the end.",
      "description": "\nThe index can be negative, and if so the message will be inserted from the end counting backwards starting from -1. E.g. if index = -1 then the new message will become the last of the batch, if index = -2 then the new message will be inserted before the last message, and so on. If the negative index is greater than the length of the existing batch it will be inserted at the beginning.\n\nThe new message will have metadata copied from the first pre-existing message of the batch.\n\nThis processor will interpolate functions within the 'content' field, you can find a list of functions xref:configuration:interpolation.adoc#bloblang-queries[here].",
      "config": {
        "content": {
          "name": "content",
          "type": "string",
          "kind": "scalar",
          "description": "The content of the message being inserted.",
          "required": true,
          "default": ""
        },
        "index": {
          "name": "index",
          "type": "int",
          "kind": "scalar",
          "description": "The index within the batch to insert the message at.",
          "required": true,
          "default": -1
        }
      }
    },
    "javascript": {
      "name": "javascript",
      "type": "processor",
      "source": "upstream",
      "summary": "Executes a provided JavaScript code block or file for each message.",
      "description": "\nThe https://github.com/dop251/goja[execution engine^] behind this processor provides full ECMAScript 5.1 support (including regex and strict mode). Most of the ECMAScript 6 spec is implemented but this is a work in progress.\n\nImports via `require` should work similarly to NodeJS, and access to the console is supported which will print via the Redpanda Connect logger. More caveats can be found on https://github.com/dop251/goja#known-incompatibilities-and-caveats[GitHub^].\n\nThis processor is implemented using the https://github.com/dop251/goja[github.com/dop251/goja^] library.",
      "config": {
        "code": {
          "name": "code",
          "type": "string",
          "kind": "scalar",
          "description": "An inline JavaScript program to run. One of `code` or `file` must be defined.",
          "required": false,
          "default": null
        },
        "file": {
          "name": "file",
          "type": "string",
          "kind": "scalar",
          "description": "A file containing a JavaScript program to run. One of `code` or `file` must be defined.",
          "required": false,
          "default": null
        },
        "global_folders": {
          "name": "global_folders",
          "type": "string",
          "kind": "array",
          "description": "List of folders that will be used to load modules from if the requested JS module is not found elsewhere.",
          "required": true,
          "default": []
        }
      }
    },
    "jmespath": {
      "name": "jmespath",
      "type": "processor",
      "source": "upstream",
      "summary": "Executes a http://jmespath.org/[JMESPath query] on JSON documents and replaces the message with the resulting document.",
      "description": "\n[TIP]\n.Try out Bloblang\n====\nFor better performance and improved capabilities try native Redpanda Connect mapping with the xref:components:processors/mapping.adoc[`mapping` processor].\n====\n",
      "config": {
        "query": {
          "name": "query",
          "type": "string",
          "kind": "scalar",
          "description": "The JMESPath query to apply to messages.",
          "required": true,
          "default": null
        }
      }
    },
    "jq": {
      "name": "jq",
      "type": "processor",
      "source": "upstream",
      "summary": "Transforms and filters messages using jq queries.",
      "description": "\n[TIP]\n.Try out Bloblang\n====\nFor better performance and improved capabilities try out native Redpanda Connect mapping with the xref:components:processors/mapping.adoc[`mapping` processor].\n====\n\nThe provided query is executed on each message, targeting either the contents as a structured JSON value or as a raw string using the field `raw`, and the message is replaced with the query result.\n\nMessage metadata is also accessible within the query from the variable `$metadata`.\n\nThis processor uses the https://github.com/itchyny/gojq[gojq library^], and therefore does not require jq to be installed as a dependency. However, this also means there are some https://github.com/itchyny/gojq#difference-to-jq[differences in how these queries are executed^] versus the jq cli.\n\nIf the query does not emit any value then the message is filtered, if the query returns multiple values then the resulting message will be an array containing all values.\n\nThe full query syntax is described in https://stedolan.github.io/jq/manual/[jq's documentation^].\n\n== Error handling\n\nQueries can fail, in which case the message remains unchanged, errors are logged, and the message is flagged as having failed, allowing you to use xref:configuration:error_handling.adoc[standard processor error handling patterns].",
      "config": {
        "output_raw": {
          "name": "output_raw",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to output raw text (unquoted) instead of JSON strings when the emitted values are string types.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "query": {
          "name": "query",
          "type": "string",
          "kind": "scalar",
          "description": "The jq query to filter and transform messages with.",
          "required": true,
          "default": null
        },
        "raw": {
          "name": "raw",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to process the input as a raw string instead of as JSON.",
          "required": true,
          "default": false,
          "advanced": true
        }
      }
    },
    "json_schema": {
      "name": "json_schema",
      "type": "processor",
      "source": "upstream",
      "summary": "Checks messages against a provided JSONSchema definition but does not change the payload under any circumstances. If a message does not match the schema it can be caught using xref:configuration:error_handling.adoc[error handling methods].",
      "description": "Please refer to the https://json-schema.org/[JSON Schema website^] for information and tutorials regarding the syntax of the schema.",
      "config": {
        "schema": {
          "name": "schema",
          "type": "string",
          "kind": "scalar",
          "description": "A schema to apply. Use either this or the `schema_path` field.",
          "required": false,
          "default": null
        },
        "schema_path": {
          "name": "schema_path",
          "type": "string",
          "kind": "scalar",
          "description": "The path of a schema document to apply. Use either this or the `schema` field.",
          "required": false,
          "default": null
        }
      }
    },
    "log": {
      "name": "log",
      "type": "processor",
      "source": "upstream",
      "summary": "Prints a log event for each message. Messages always remain unchanged. The log message can be set using function interpolations described in  xref:configuration:interpolation.adoc#bloblang-queries[Bloblang queries] which allows you to log the contents and metadata of messages.",
      "description": "\nThe `level` field determines the log level of the printed events and can be any of the following values: TRACE, DEBUG, INFO, WARN, ERROR.\n\n== Structured fields\n\nIt's also possible add custom fields to logs when the format is set to a structured form such as `json` or `logfmt` with the config field \u003c\u003cfields_mapping, `fields_mapping`\u003e\u003e:\n\n```yaml\npipeline:\n  processors:\n    - log:\n        level: DEBUG\n        message: hello world\n        fields_mapping: |\n          root.reason = \"cus I wana\"\n          root.id = this.id\n          root.age = this.user.age\n          root.kafka_topic = meta(\"kafka_topic\")\n```\n",
      "config": {
        "fields": {
          "name": "fields",
          "type": "string",
          "kind": "map",
          "description": "A map of fields to print along with the log message.",
          "required": false,
          "default": null
        },
        "fields_mapping": {
          "name": "fields_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:guides:bloblang/about.adoc[Bloblang mapping] that can be used to specify extra fields to add to the log. If log fields are also added with the `fields` field then those values will override matching keys from this mapping.",
          "required": false,
          "default": null,
          "examples": [
            "root.reason = \"cus I wana\"\nroot.id = this.id\nroot.age = this.user.age.number()\nroot.kafka_topic = meta(\"kafka_topic\")"
          ]
        },
        "level": {
          "name": "level",
          "type": "string",
          "kind": "scalar",
          "description": "The log level to use.",
          "required": true,
          "default": "INFO",
          "options": [
            "ERROR",
            "WARN",
            "INFO",
            "DEBUG",
            "TRACE"
          ]
        },
        "message": {
          "name": "message",
          "type": "string",
          "kind": "scalar",
          "description": "The message to print.",
          "required": true,
          "default": ""
        }
      }
    },
    "mapping": {
      "name": "mapping",
      "type": "processor",
      "source": "upstream",
      "summary": "Executes a xref:guides:bloblang/about.adoc[Bloblang] mapping on messages, creating a new document that replaces (or filters) the original message.",
      "description": "\nBloblang is a powerful language that enables a wide range of mapping, transformation and filtering tasks. For more information, see xref:guides:bloblang/about.adoc[].\n\nIf your mapping is large and you'd prefer for it to live in a separate file then you can execute a mapping directly from a file with the expression `from \"\u003cpath\u003e\"`, where the path must be absolute, or relative from the location that Redpanda Connect is executed from.\n\nNote: This processor is equivalent to the xref:components:processors/bloblang.adoc#component-rename[Bloblang] one. The latter will be deprecated in a future release.\n\n== Input document immutability\n\nMapping operates by creating an entirely new object during assignments, this has the advantage of treating the original referenced document as immutable and therefore queryable at any stage of your mapping. For example, with the following mapping:\n\n```coffeescript\nroot.id = this.id\nroot.invitees = this.invitees.filter(i -\u003e i.mood \u003e= 0.5)\nroot.rejected = this.invitees.filter(i -\u003e i.mood \u003c 0.5)\n```\n\nNotice that we mutate the value of `invitees` in the resulting document by filtering out objects with a lower mood. However, even after doing so we're still able to reference the unchanged original contents of this value from the input document in order to populate a second field. Within this mapping we also have the flexibility to reference the mutable mapped document by using the keyword `root` (i.e. `root.invitees`) on the right-hand side instead.\n\nMapping documents is advantageous in situations where the result is a document with a dramatically different shape to the input document, since we are effectively rebuilding the document in its entirety and might as well keep a reference to the unchanged input document throughout. However, in situations where we are only performing minor alterations to the input document, the rest of which is unchanged, it might be more efficient to use the xref:components:processors/mutation.adoc[`mutation` processor] instead.\n\n== Error handling\n\nBloblang mappings can fail, in which case the message remains unchanged, errors are logged, and the message is flagged as having failed, allowing you to use xref:configuration:error_handling.adoc[standard processor error handling patterns].\n\nHowever, Bloblang itself also provides powerful ways of ensuring your mappings do not fail by specifying desired xref:guides:bloblang/about.adoc#error-handling[fallback behavior].\n\t\t\t",
      "config": {}
    },
    "metric": {
      "name": "metric",
      "type": "processor",
      "source": "upstream",
      "summary": "Emit custom metrics by extracting values from messages.",
      "description": "\nThis processor works by evaluating an xref:configuration:interpolation.adoc#bloblang-queries[interpolated field `value`] for each message and updating a emitted metric according to the \u003c\u003ctypes, type\u003e\u003e.\n\nCustom metrics such as these are emitted along with Redpanda Connect internal metrics, where you can customize where metrics are sent, which metric names are emitted and rename them as/when appropriate. For more information see the xref:components:metrics/about.adoc[metrics docs].",
      "config": {
        "labels": {
          "name": "labels",
          "type": "string",
          "kind": "map",
          "description": "A map of label names and values that can be used to enrich metrics. Labels are not supported by some metric destinations, in which case the metrics series are combined.",
          "required": false,
          "default": null,
          "examples": [
            {
              "topic": "${! meta(\"kafka_topic\") }",
              "type": "${! json(\"doc.type\") }"
            }
          ]
        },
        "name": {
          "name": "name",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the metric to create, this must be unique across all Redpanda Connect components otherwise it will overwrite those other metrics.",
          "required": true,
          "default": null
        },
        "type": {
          "name": "type",
          "type": "string",
          "kind": "scalar",
          "description": "The metric \u003c\u003ctypes, type\u003e\u003e to create.",
          "required": true,
          "default": null,
          "options": [
            "counter",
            "counter_by",
            "gauge",
            "timing"
          ]
        },
        "value": {
          "name": "value",
          "type": "string",
          "kind": "scalar",
          "description": "For some metric types specifies a value to set, increment. Certain metrics exporters such as Prometheus support floating point values, but those that do not will cast a floating point value into an integer.",
          "required": true,
          "default": ""
        }
      }
    },
    "mongodb": {
      "name": "mongodb",
      "type": "processor",
      "source": "upstream",
      "summary": "Performs operations against MongoDB for each message, allowing you to store or retrieve data within message payloads.",
      "config": {
        "app_name": {
          "name": "app_name",
          "type": "string",
          "kind": "scalar",
          "description": "The client application name.",
          "required": true,
          "default": "benthos",
          "advanced": true
        },
        "backoff": {
          "name": "backoff",
          "type": "object",
          "kind": "scalar",
          "description": "Control time intervals between retry attempts.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "initial_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The initial period to wait between retry attempts.",
              "required": true,
              "default": "1s",
              "advanced": true
            },
            {
              "name": "max_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait between retry attempts.",
              "required": true,
              "default": "5s",
              "advanced": true
            },
            {
              "name": "max_elapsed_time",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait before retry attempts are abandoned. If zero then no limit is used.",
              "required": true,
              "default": "30s",
              "advanced": true
            }
          ]
        },
        "collection": {
          "name": "collection",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the target collection.",
          "required": true,
          "default": null
        },
        "database": {
          "name": "database",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the target MongoDB database.",
          "required": true,
          "default": null
        },
        "document_map": {
          "name": "document_map",
          "type": "string",
          "kind": "scalar",
          "description": "A bloblang map representing a document to store within MongoDB, expressed as https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/[extended JSON in canonical form^]. The document map is required for the operations insert-one, replace-one and update-one.",
          "required": true,
          "default": "",
          "examples": [
            "root.a = this.foo\nroot.b = this.bar"
          ]
        },
        "filter_map": {
          "name": "filter_map",
          "type": "string",
          "kind": "scalar",
          "description": "A bloblang map representing a filter for a MongoDB command, expressed as https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/[extended JSON in canonical form^]. The filter map is required for all operations except insert-one. It is used to find the document(s) for the operation. For example in a delete-one case, the filter map should have the fields required to locate the document to delete.",
          "required": true,
          "default": "",
          "examples": [
            "root.a = this.foo\nroot.b = this.bar"
          ]
        },
        "hint_map": {
          "name": "hint_map",
          "type": "string",
          "kind": "scalar",
          "description": "A bloblang map representing the hint for the MongoDB command, expressed as https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/[extended JSON in canonical form^]. This map is optional and is used with all operations except insert-one. It is used to improve performance of finding the documents in the mongodb.",
          "required": true,
          "default": "",
          "examples": [
            "root.a = this.foo\nroot.b = this.bar"
          ]
        },
        "json_marshal_mode": {
          "name": "json_marshal_mode",
          "type": "string",
          "kind": "scalar",
          "description": "The json_marshal_mode setting is optional and controls the format of the output message.",
          "required": true,
          "default": "canonical",
          "advanced": true
        },
        "max_retries": {
          "name": "max_retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retries before giving up on the request. If set to zero there is no discrete limit.",
          "required": true,
          "default": 3,
          "advanced": true
        },
        "operation": {
          "name": "operation",
          "type": "string",
          "kind": "scalar",
          "description": "The mongodb operation to perform.",
          "required": true,
          "default": "insert-one",
          "options": [
            "insert-one",
            "delete-one",
            "delete-many",
            "replace-one",
            "update-one",
            "find-one"
          ]
        },
        "password": {
          "name": "password",
          "type": "string",
          "kind": "scalar",
          "description": "The password to connect to the database.",
          "required": true,
          "default": ""
        },
        "upsert": {
          "name": "upsert",
          "type": "bool",
          "kind": "scalar",
          "description": "The upsert setting is optional and only applies for update-one and replace-one operations. If the filter specified in filter_map matches, the document is updated or replaced accordingly, otherwise it is created.",
          "required": true,
          "default": false
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL of the target MongoDB server.",
          "required": true,
          "default": null,
          "examples": [
            "mongodb://localhost:27017"
          ]
        },
        "username": {
          "name": "username",
          "type": "string",
          "kind": "scalar",
          "description": "The username to connect to the database.",
          "required": true,
          "default": ""
        },
        "write_concern": {
          "name": "write_concern",
          "type": "object",
          "kind": "scalar",
          "description": "The write concern settings for the mongo connection.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "w",
              "type": "string",
              "kind": "scalar",
              "description": "W requests acknowledgement that write operations propagate to the specified number of mongodb instances. Can be the string \"majority\" to wait for a calculated majority of nodes to acknowledge the write operation, or an integer value specifying an minimum number of nodes to acknowledge the operation, or a string specifying the name of a custom write concern configured in the cluster.",
              "required": true,
              "default": "majority"
            },
            {
              "name": "j",
              "type": "bool",
              "kind": "scalar",
              "description": "J requests acknowledgement from MongoDB that write operations are written to the journal.",
              "required": true,
              "default": false
            },
            {
              "name": "w_timeout",
              "type": "string",
              "kind": "scalar",
              "description": "The write concern timeout.",
              "required": true,
              "default": ""
            }
          ]
        }
      }
    },
    "msgpack": {
      "name": "msgpack",
      "type": "processor",
      "source": "upstream",
      "summary": "Converts messages to or from the https://msgpack.org/[MessagePack^] format.",
      "config": {
        "operator": {
          "name": "operator",
          "type": "string",
          "kind": "scalar",
          "description": "The operation to perform on messages.",
          "required": true,
          "default": null
        }
      }
    },
    "mutation": {
      "name": "mutation",
      "type": "processor",
      "source": "upstream",
      "summary": "Executes a xref:guides:bloblang/about.adoc[Bloblang] mapping and directly transforms the contents of messages, mutating (or deleting) them.",
      "description": "\nBloblang is a powerful language that enables a wide range of mapping, transformation and filtering tasks. For more information, see xref:guides:bloblang/about.adoc[].\n\nIf your mapping is large and you'd prefer for it to live in a separate file then you can execute a mapping directly from a file with the expression `from \"\u003cpath\u003e\"`, where the path must be absolute, or relative from the location that Redpanda Connect is executed from.\n\n== Input document mutability\n\nA mutation is a mapping that transforms input documents directly, this has the advantage of reducing the need to copy the data fed into the mapping. However, this also means that the referenced document is mutable and therefore changes throughout the mapping. For example, with the following Bloblang:\n\n```coffeescript\nroot.rejected = this.invitees.filter(i -\u003e i.mood \u003c 0.5)\nroot.invitees = this.invitees.filter(i -\u003e i.mood \u003e= 0.5)\n```\n\nNotice that we create a field `rejected` by copying the array field `invitees` and filtering out objects with a high mood. We then overwrite the field `invitees` by filtering out objects with a low mood, resulting in two array fields that are each a subset of the original. If we were to reverse the ordering of these assignments like so:\n\n```coffeescript\nroot.invitees = this.invitees.filter(i -\u003e i.mood \u003e= 0.5)\nroot.rejected = this.invitees.filter(i -\u003e i.mood \u003c 0.5)\n```\n\nThen the new field `rejected` would be empty as we have already mutated `invitees` to exclude the objects that it would be populated by. We can solve this problem either by carefully ordering our assignments or by capturing the original array using a variable (`let invitees = this.invitees`).\n\nMutations are advantageous over a standard mapping in situations where the result is a document with mostly the same shape as the input document, since we can avoid unnecessarily copying data from the referenced input document. However, in situations where we are creating an entirely new document shape it can be more convenient to use the traditional xref:components:processors/mapping.adoc[`mapping` processor] instead.\n\n== Error handling\n\nBloblang mappings can fail, in which case the error is logged and the message is flagged as having failed, allowing you to use xref:configuration:error_handling.adoc[standard processor error handling patterns].\n\nHowever, Bloblang itself also provides powerful ways of ensuring your mappings do not fail by specifying desired xref:guides:bloblang/about.adoc#error-handling[fallback behavior].\n\t\t\t",
      "config": {}
    },
    "nats_kv": {
      "name": "nats_kv",
      "type": "processor",
      "source": "upstream",
      "summary": "Perform operations on a NATS key-value bucket.",
      "description": "\n== KV operations\n\nThe NATS KV processor supports a multitude of KV operations via the \u003c\u003coperation\u003e\u003e field. Along with `get`, `put`, and `delete`, this processor supports atomic operations like `update` and `create`, as well as utility operations like `purge`, `history`, and `keys`.\n\n== Metadata\n\nThis processor adds the following metadata fields to each message, depending on the chosen `operation`:\n\n=== get, get_revision\n``` text\n- nats_kv_key\n- nats_kv_bucket\n- nats_kv_revision\n- nats_kv_delta\n- nats_kv_operation\n- nats_kv_created\n```\n\n=== create, update, delete, purge\n``` text\n- nats_kv_key\n- nats_kv_bucket\n- nats_kv_revision\n- nats_kv_operation\n```\n\n=== keys\n``` text\n- nats_kv_bucket\n```\n\n== Connection name\n\nWhen monitoring and managing a production NATS system, it is often useful to\nknow which connection a message was send/received from. This can be achieved by\nsetting the connection name option when creating a NATS connection.\n\nRedpanda Connect will automatically set the connection name based off the label of the given\nNATS component, so that monitoring tools between NATS and Redpanda Connect can stay in sync.\n\n\n== Authentication\n\nThere are several components within Redpanda Connect which uses NATS services. You will find that each of these components\nsupport optional advanced authentication parameters for https://docs.nats.io/nats-server/configuration/securing_nats/auth_intro/nkey_auth[NKeys^]\nand https://docs.nats.io/using-nats/developer/connecting/creds[User Credentials^].\n\nSee an https://docs.nats.io/running-a-nats-service/nats_admin/security/jwt[in-depth tutorial^].\n\n=== NKey file\n\nThe NATS server can use these NKeys in several ways for authentication. The simplest is for the server to be configured\nwith a list of known public keys and for the clients to respond to the challenge by signing it with its private NKey\nconfigured in the `nkey_file` or `nkey` field.\n\nhttps://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[More details^].\n\n=== User credentials\n\nNATS server supports decentralized authentication based on JSON Web Tokens (JWT). Clients need an https://docs.nats.io/nats-server/configuration/securing_nats/jwt#json-web-tokens[user JWT^]\nand a corresponding https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[NKey secret^] when connecting to a server\nwhich is configured to use this authentication scheme.\n\nThe `user_credentials_file` field should point to a file containing both the private key and the JWT and can be\ngenerated with the https://docs.nats.io/nats-tools/nsc[nsc tool^].\n\nAlternatively, the `user_jwt` field can contain a plain text JWT and the `user_nkey_seed`can contain\nthe plain text NKey Seed.\n\nhttps://docs.nats.io/using-nats/developer/connecting/creds[More details^].",
      "config": {
        "auth": {
          "name": "auth",
          "type": "object",
          "kind": "scalar",
          "description": "Optional configuration of NATS authentication parameters.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "nkey_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing a NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./seed.nk"
              ],
              "advanced": true
            },
            {
              "name": "nkey",
              "type": "string",
              "kind": "scalar",
              "description": "The NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "UDXU4RCSJNZOIQHZNWXHXORDPRTGNJAHAHFRGZNEEJCPQTT2M7NLCNF4"
              ],
              "advanced": true
            },
            {
              "name": "user_credentials_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing user credentials which consist of an user JWT and corresponding NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./user.creds"
              ],
              "advanced": true
            },
            {
              "name": "user_jwt",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user JWT (given along with the corresponding user NKey Seed).",
              "required": false,
              "default": null,
              "advanced": true
            },
            {
              "name": "user_nkey_seed",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user NKey Seed (given along with the corresponding user JWT).",
              "required": false,
              "default": null,
              "advanced": true
            }
          ]
        },
        "bucket": {
          "name": "bucket",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the KV bucket.",
          "required": true,
          "default": null,
          "examples": [
            "my_kv_bucket"
          ]
        },
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "The key for each message. Supports https://docs.nats.io/nats-concepts/subjects#wildcards[wildcards^] for the `history` and `keys` operations.",
          "required": true,
          "default": null,
          "examples": [
            "foo",
            "foo.bar.baz",
            "foo.*",
            "foo.\u003e",
            "foo.${! json(\"meta.type\") }"
          ]
        },
        "operation": {
          "name": "operation",
          "type": "string",
          "kind": "scalar",
          "description": "The operation to perform on the KV bucket.",
          "required": true,
          "default": null
        },
        "revision": {
          "name": "revision",
          "type": "string",
          "kind": "scalar",
          "description": "The revision of the key to operate on. Used for `get_revision` and `update` operations.",
          "required": false,
          "default": null,
          "examples": [
            "42",
            "${! @nats_kv_revision }"
          ],
          "advanced": true
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum period to wait on an operation before aborting and returning an error.",
          "required": true,
          "default": "5s",
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "nats://127.0.0.1:4222"
            ],
            [
              "nats://username:password@127.0.0.1:4222"
            ]
          ]
        }
      }
    },
    "nats_request_reply": {
      "name": "nats_request_reply",
      "type": "processor",
      "source": "upstream",
      "summary": "Sends a message to a NATS subject and expects a reply, from a NATS subscriber acting as a responder, back.",
      "description": "\n== Metadata\n\nThis input adds the following metadata fields to each message:\n\n```text\n- nats_subject\n- nats_sequence_stream\n- nats_sequence_consumer\n- nats_num_delivered\n- nats_num_pending\n- nats_domain\n- nats_timestamp_unix_nano\n```\n\nYou can access these metadata fields using xref:configuration:interpolation.adoc#bloblang-queries[function interpolation].\n\n== Connection name\n\nWhen monitoring and managing a production NATS system, it is often useful to\nknow which connection a message was send/received from. This can be achieved by\nsetting the connection name option when creating a NATS connection.\n\nRedpanda Connect will automatically set the connection name based off the label of the given\nNATS component, so that monitoring tools between NATS and Redpanda Connect can stay in sync.\n\n\n== Authentication\n\nThere are several components within Redpanda Connect which uses NATS services. You will find that each of these components\nsupport optional advanced authentication parameters for https://docs.nats.io/nats-server/configuration/securing_nats/auth_intro/nkey_auth[NKeys^]\nand https://docs.nats.io/using-nats/developer/connecting/creds[User Credentials^].\n\nSee an https://docs.nats.io/running-a-nats-service/nats_admin/security/jwt[in-depth tutorial^].\n\n=== NKey file\n\nThe NATS server can use these NKeys in several ways for authentication. The simplest is for the server to be configured\nwith a list of known public keys and for the clients to respond to the challenge by signing it with its private NKey\nconfigured in the `nkey_file` or `nkey` field.\n\nhttps://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[More details^].\n\n=== User credentials\n\nNATS server supports decentralized authentication based on JSON Web Tokens (JWT). Clients need an https://docs.nats.io/nats-server/configuration/securing_nats/jwt#json-web-tokens[user JWT^]\nand a corresponding https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[NKey secret^] when connecting to a server\nwhich is configured to use this authentication scheme.\n\nThe `user_credentials_file` field should point to a file containing both the private key and the JWT and can be\ngenerated with the https://docs.nats.io/nats-tools/nsc[nsc tool^].\n\nAlternatively, the `user_jwt` field can contain a plain text JWT and the `user_nkey_seed`can contain\nthe plain text NKey Seed.\n\nhttps://docs.nats.io/using-nats/developer/connecting/creds[More details^].",
      "config": {
        "auth": {
          "name": "auth",
          "type": "object",
          "kind": "scalar",
          "description": "Optional configuration of NATS authentication parameters.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "nkey_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing a NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./seed.nk"
              ],
              "advanced": true
            },
            {
              "name": "nkey",
              "type": "string",
              "kind": "scalar",
              "description": "The NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "UDXU4RCSJNZOIQHZNWXHXORDPRTGNJAHAHFRGZNEEJCPQTT2M7NLCNF4"
              ],
              "advanced": true
            },
            {
              "name": "user_credentials_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing user credentials which consist of an user JWT and corresponding NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./user.creds"
              ],
              "advanced": true
            },
            {
              "name": "user_jwt",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user JWT (given along with the corresponding user NKey Seed).",
              "required": false,
              "default": null,
              "advanced": true
            },
            {
              "name": "user_nkey_seed",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user NKey Seed (given along with the corresponding user JWT).",
              "required": false,
              "default": null,
              "advanced": true
            }
          ]
        },
        "headers": {
          "name": "headers",
          "type": "string",
          "kind": "map",
          "description": "Explicit message headers to add to messages.",
          "required": true,
          "default": {},
          "examples": [
            {
              "Content-Type": "application/json",
              "Timestamp": "${!meta(\"Timestamp\")}"
            }
          ]
        },
        "inbox_prefix": {
          "name": "inbox_prefix",
          "type": "string",
          "kind": "scalar",
          "description": "Set an explicit inbox prefix for the response subject",
          "required": false,
          "default": null,
          "examples": [
            "_INBOX_joe"
          ],
          "advanced": true
        },
        "metadata": {
          "name": "metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Determine which (if any) metadata values should be added to messages as headers.",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "include_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  "foo_",
                  "bar_"
                ],
                [
                  "kafka_"
                ],
                [
                  "content-"
                ]
              ]
            },
            {
              "name": "include_patterns",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key regular expression (re2) patterns to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  ".*"
                ],
                [
                  "_timestamp_unix$"
                ]
              ]
            }
          ]
        },
        "subject": {
          "name": "subject",
          "type": "string",
          "kind": "scalar",
          "description": "A subject to write to.",
          "required": true,
          "default": null,
          "examples": [
            "foo.bar.baz",
            "${! meta(\"kafka_topic\") }",
            "foo.${! json(\"meta.type\") }"
          ]
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as 300ms, -1.5h or 2h45m. Valid time units are ns, us (or s), ms, s, m, h.",
          "required": false,
          "default": "3s"
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "nats://127.0.0.1:4222"
            ],
            [
              "nats://username:password@127.0.0.1:4222"
            ]
          ]
        }
      }
    },
    "nodered_js": {
      "name": "nodered_js",
      "type": "processor",
      "source": "benthos-umh",
      "summary": "A Node-RED style JavaScript processor.",
      "description": "Executes user-defined JavaScript code to process messages in a format similar to Node-RED functions.",
      "config": {
        "code": {
          "name": "code",
          "type": "string",
          "kind": "scalar",
          "description": "The JavaScript code to execute. The code should be a function that processes the message.",
          "required": true,
          "default": null,
          "examples": [
            "// Node-RED style function that returns the modified message\n// Example 1: Return message as-is\nreturn msg;\n\n// Example 2: Modify message payload\nmsg.payload = msg.payload.toString().length;\nreturn msg;\n\n// Example 3: Create new message\nvar newMsg = { payload: msg.payload.length };\nreturn newMsg;\n\n// Example 4: Drop/stop processing this message\nconsole.log(\"Dropping message\");\nreturn null;\n\n// Example 5: Log message content\nconsole.log(\"Processing message with payload:\", msg.payload);\nconsole.log(\"Message metadata:\", msg.meta);\n\n// Example 6: Modify metadata\nmsg.meta.processed = true;\nmsg.meta.count = (msg.meta.count || 0) + 1;\nreturn msg;"
          ]
        }
      }
    },
    "noop": {
      "name": "noop",
      "type": "processor",
      "source": "upstream",
      "summary": "Noop is a processor that does nothing, the message passes through unchanged. Why? Sometimes doing nothing is the braver option.",
      "config": {}
    },
    "parallel": {
      "name": "parallel",
      "type": "processor",
      "source": "upstream",
      "summary": "A processor that applies a list of child processors to messages of a batch as though they were each a batch of one message (similar to the xref:components:processors/for_each.adoc[`for_each`] processor), but where each message is processed in parallel.",
      "description": "\nThe field `cap`, if greater than zero, caps the maximum number of parallel processing threads.\n\nThe functionality of this processor depends on being applied across messages that are batched. You can find out more about batching in xref:configuration:batching.adoc[].",
      "config": {
        "cap": {
          "name": "cap",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have processing at a given time.",
          "required": true,
          "default": 0
        },
        "processors": {
          "name": "processors",
          "type": "processor",
          "kind": "array",
          "description": "A list of child processors to apply.",
          "required": true,
          "default": null
        }
      }
    },
    "parquet": {
      "name": "parquet",
      "type": "processor",
      "source": "upstream",
      "summary": "Converts batches of documents to or from https://parquet.apache.org/docs/[Parquet files^].",
      "description": "\n== Alternatives\n\nThis processor is now deprecated, it's recommended that you use the new xref:components:processors/parquet_decode.adoc[`parquet_decode`] and xref:components:processors/parquet_encode.adoc[`parquet_encode`] processors as they provide a number of advantages, the most important of which is better error messages for when schemas are mismatched or files could not be consumed.\n\n== Troubleshooting\n\nThis processor is experimental and the error messages that it provides are often vague and unhelpful. An error message of the form `interface \\{} is nil, not \u003cvalue type\u003e` implies that a field of the given type was expected but not found in the processed message when writing parquet files.\n\nUnfortunately the name of the field will sometimes be missing from the error, in which case it's worth double checking the schema you provided to make sure that there are no typos in the field names, and if that doesn't reveal the issue it can help to mark fields as OPTIONAL in the schema and gradually change them back to REQUIRED until the error returns.\n\n== Define the schema\n\nThe schema must be specified as a JSON string, containing an object that describes the fields expected at the root of each document. Each field can itself have more fields defined, allowing for nested structures:\n\n```json\n{\n  \"Tag\": \"name=root, repetitiontype=REQUIRED\",\n  \"Fields\": [\n    {\"Tag\": \"name=name, inname=NameIn, type=BYTE_ARRAY, convertedtype=UTF8, repetitiontype=REQUIRED\"},\n    {\"Tag\": \"name=age, inname=Age, type=INT32, repetitiontype=REQUIRED\"},\n    {\"Tag\": \"name=id, inname=Id, type=INT64, repetitiontype=REQUIRED\"},\n    {\"Tag\": \"name=weight, inname=Weight, type=FLOAT, repetitiontype=REQUIRED\"},\n    {\n      \"Tag\": \"name=favPokemon, inname=FavPokemon, type=LIST, repetitiontype=OPTIONAL\",\n      \"Fields\": [\n        {\"Tag\": \"name=name, inname=PokeName, type=BYTE_ARRAY, convertedtype=UTF8, repetitiontype=REQUIRED\"},\n        {\"Tag\": \"name=coolness, inname=Coolness, type=FLOAT, repetitiontype=REQUIRED\"}\n      ]\n    }\n  ]\n}\n```\n\nA schema can be derived from a source file using https://github.com/xitongsys/parquet-go/tree/master/tool/parquet-tools:\n\n```sh\n./parquet-tools -cmd schema -file foo.parquet\n```",
      "config": {
        "compression": {
          "name": "compression",
          "type": "string",
          "kind": "scalar",
          "description": "The type of compression to use when writing parquet files, this field is ignored when consuming parquet files.",
          "required": true,
          "default": "snappy",
          "options": [
            "uncompressed",
            "snappy",
            "gzip",
            "lz4",
            "zstd"
          ]
        },
        "operator": {
          "name": "operator",
          "type": "string",
          "kind": "scalar",
          "description": "Determines whether the processor converts messages into a parquet file or expands parquet files into messages. Converting into JSON allows subsequent processors and mappings to convert the data into any other format.",
          "required": true,
          "default": null
        },
        "schema": {
          "name": "schema",
          "type": "string",
          "kind": "scalar",
          "description": "A schema used to describe the parquet files being generated or consumed, the format of the schema is a JSON document detailing the tag and fields of documents. The schema can be found at: https://pkg.go.dev/github.com/xitongsys/parquet-go#readme-json. Either a `schema_file` or `schema` field must be specified when creating Parquet files via the `from_json` operator.",
          "required": false,
          "default": null,
          "examples": [
            "{\n  \"Tag\": \"name=root, repetitiontype=REQUIRED\",\n  \"Fields\": [\n    {\"Tag\":\"name=name,inname=NameIn,type=BYTE_ARRAY,convertedtype=UTF8, repetitiontype=REQUIRED\"},\n    {\"Tag\":\"name=age,inname=Age,type=INT32,repetitiontype=REQUIRED\"}\n  ]\n}"
          ]
        },
        "schema_file": {
          "name": "schema_file",
          "type": "string",
          "kind": "scalar",
          "description": "A file path containing a schema used to describe the parquet files being generated or consumed, the format of the schema is a JSON document detailing the tag and fields of documents. The schema can be found at: https://pkg.go.dev/github.com/xitongsys/parquet-go#readme-json. Either a `schema_file` or `schema` field must be specified when creating Parquet files via the `from_json` operator.",
          "required": false,
          "default": null,
          "examples": [
            "schemas/foo.json"
          ]
        }
      }
    },
    "parquet_decode": {
      "name": "parquet_decode",
      "type": "processor",
      "source": "upstream",
      "summary": "Decodes https://parquet.apache.org/docs/[Parquet files^] into a batch of structured messages.",
      "description": "\nThis processor uses https://github.com/parquet-go/parquet-go[https://github.com/parquet-go/parquet-go^], which is itself experimental. Therefore changes could be made into how this processor functions outside of major version releases.",
      "config": {
        "byte_array_as_string": {
          "name": "byte_array_as_string",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to extract BYTE_ARRAY and FIXED_LEN_BYTE_ARRAY values as strings rather than byte slices in all cases. Values with a logical type of UTF8 will automatically be extracted as strings irrespective of this field. Enabling this field makes serializing the data as JSON more intuitive as `[]byte` values are serialized as base64 encoded strings by default.",
          "required": true,
          "default": false
        }
      }
    },
    "parquet_encode": {
      "name": "parquet_encode",
      "type": "processor",
      "source": "upstream",
      "summary": "Encodes https://parquet.apache.org/docs/[Parquet files^] from a batch of structured messages.",
      "description": "\nThis processor uses https://github.com/parquet-go/parquet-go[https://github.com/parquet-go/parquet-go^], which is itself experimental. Therefore changes could be made into how this processor functions outside of major version releases.\n",
      "config": {
        "default_compression": {
          "name": "default_compression",
          "type": "string",
          "kind": "scalar",
          "description": "The default compression type to use for fields.",
          "required": true,
          "default": "uncompressed",
          "options": [
            "uncompressed",
            "snappy",
            "gzip",
            "brotli",
            "zstd",
            "lz4raw"
          ]
        },
        "default_encoding": {
          "name": "default_encoding",
          "type": "string",
          "kind": "scalar",
          "description": "The default encoding type to use for fields. A custom default encoding is only necessary when consuming data with libraries that do not support `DELTA_LENGTH_BYTE_ARRAY` and is therefore best left unset where possible.",
          "required": true,
          "default": "DELTA_LENGTH_BYTE_ARRAY",
          "options": [
            "DELTA_LENGTH_BYTE_ARRAY",
            "PLAIN"
          ],
          "advanced": true
        },
        "schema": {
          "name": "schema",
          "type": "object",
          "kind": "array",
          "description": "Parquet schema.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "name",
              "type": "string",
              "kind": "scalar",
              "description": "The name of the column.",
              "required": true,
              "default": null
            },
            {
              "name": "type",
              "type": "string",
              "kind": "scalar",
              "description": "The type of the column, only applicable for leaf columns with no child fields. Some logical types can be specified here such as UTF8.",
              "required": false,
              "default": null,
              "options": [
                "BOOLEAN",
                "INT32",
                "INT64",
                "FLOAT",
                "DOUBLE",
                "BYTE_ARRAY",
                "UTF8"
              ]
            },
            {
              "name": "repeated",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether the field is repeated.",
              "required": true,
              "default": false
            },
            {
              "name": "optional",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether the field is optional.",
              "required": true,
              "default": false
            },
            {
              "name": "fields",
              "type": "unknown",
              "kind": "array",
              "description": "A list of child fields.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "name": "foo",
                    "type": "INT64"
                  },
                  {
                    "name": "bar",
                    "type": "BYTE_ARRAY"
                  }
                ]
              ]
            }
          ]
        }
      }
    },
    "parse_log": {
      "name": "parse_log",
      "type": "processor",
      "source": "upstream",
      "summary": "Parses common log \u003c\u003cformats\u003e\u003e into \u003c\u003ccodecs, structured data\u003e\u003e. This is easier and often much faster than xref:components:processors/grok.adoc[`grok`].",
      "config": {
        "allow_rfc3339": {
          "name": "allow_rfc3339",
          "type": "bool",
          "kind": "scalar",
          "description": "Also accept timestamps in rfc3339 format while parsing. Applicable to format `syslog_rfc3164`.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "best_effort": {
          "name": "best_effort",
          "type": "bool",
          "kind": "scalar",
          "description": "Still returns partially parsed messages even if an error occurs.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "codec": {
          "name": "codec",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": null
        },
        "default_timezone": {
          "name": "default_timezone",
          "type": "string",
          "kind": "scalar",
          "description": "Sets the strategy to decide the timezone for rfc3164 timestamps. Applicable to format `syslog_rfc3164`. This value should follow the https://golang.org/pkg/time/#LoadLocation[time.LoadLocation^] format.",
          "required": true,
          "default": "UTC",
          "advanced": true
        },
        "default_year": {
          "name": "default_year",
          "type": "string",
          "kind": "scalar",
          "description": "Sets the strategy used to set the year for rfc3164 timestamps. Applicable to format `syslog_rfc3164`. When set to `current` the current year will be set, when set to an integer that value will be used. Leave this field empty to not set a default year at all.",
          "required": true,
          "default": "current",
          "advanced": true
        },
        "format": {
          "name": "format",
          "type": "string",
          "kind": "scalar",
          "description": "A common log \u003c\u003cformats, format\u003e\u003e to parse.",
          "required": true,
          "default": null,
          "options": [
            "syslog_rfc5424",
            "syslog_rfc3164"
          ]
        }
      }
    },
    "processors": {
      "name": "processors",
      "type": "processor",
      "source": "upstream",
      "summary": "A processor grouping several sub-processors.",
      "description": "This processor is useful in situations where you want to collect several processors under a single resource identifier, whether it is for making your configuration easier to read and navigate, or for improving the testability of your configuration. The behavior of child processors will match exactly the behavior they would have under any other processors block.",
      "config": {}
    },
    "protobuf": {
      "name": "protobuf",
      "type": "processor",
      "source": "upstream",
      "summary": "\nPerforms conversions to or from a protobuf message. This processor uses reflection, meaning conversions can be made directly from the target .proto files.\n",
      "description": "\nThe main functionality of this processor is to map to and from JSON documents, you can read more about JSON mapping of protobuf messages here: https://developers.google.com/protocol-buffers/docs/proto3#json[https://developers.google.com/protocol-buffers/docs/proto3#json^]\n\nUsing reflection for processing protobuf messages in this way is less performant than generating and using native code. Therefore when performance is critical it is recommended that you use Redpanda Connect plugins instead for processing protobuf messages natively, you can find an example of Redpanda Connect plugins at https://github.com/benthosdev/benthos-plugin-example[https://github.com/benthosdev/benthos-plugin-example^]\n\n== Operators\n\n=== `to_json`\n\nConverts protobuf messages into a generic JSON structure. This makes it easier to manipulate the contents of the document within Benthos.\n\n=== `from_json`\n\nAttempts to create a target protobuf message from a generic JSON structure.\n",
      "config": {
        "discard_unknown": {
          "name": "discard_unknown",
          "type": "bool",
          "kind": "scalar",
          "description": "If `true`, the `from_json` operator discards fields that are unknown to the schema.",
          "required": true,
          "default": false
        },
        "import_paths": {
          "name": "import_paths",
          "type": "string",
          "kind": "array",
          "description": "A list of directories containing .proto files, including all definitions required for parsing the target message. If left empty the current directory is used. Each directory listed will be walked with all found .proto files imported.",
          "required": true,
          "default": []
        },
        "message": {
          "name": "message",
          "type": "string",
          "kind": "scalar",
          "description": "The fully qualified name of the protobuf message to convert to/from.",
          "required": true,
          "default": null
        },
        "operator": {
          "name": "operator",
          "type": "string",
          "kind": "scalar",
          "description": "The \u003c\u003coperators, operator\u003e\u003e to execute",
          "required": true,
          "default": null,
          "options": [
            "to_json",
            "from_json"
          ]
        },
        "use_proto_names": {
          "name": "use_proto_names",
          "type": "bool",
          "kind": "scalar",
          "description": "If `true`, the `to_json` operator deserializes fields exactly as named in schema file.",
          "required": true,
          "default": false
        }
      }
    },
    "rate_limit": {
      "name": "rate_limit",
      "type": "processor",
      "source": "upstream",
      "summary": "Throttles the throughput of a pipeline according to a specified xref:components:rate_limits/about.adoc[`rate_limit`] resource. Rate limits are shared across components and therefore apply globally to all processing pipelines.",
      "config": {
        "resource": {
          "name": "resource",
          "type": "string",
          "kind": "scalar",
          "description": "The target xref:components:rate_limits/about.adoc[`rate_limit` resource].",
          "required": true,
          "default": null
        }
      }
    },
    "redis": {
      "name": "redis",
      "type": "processor",
      "source": "upstream",
      "summary": "Performs actions against Redis that aren't possible using a xref:components:processors/cache.adoc[`cache`] processor. Actions are\nperformed for each message and the message contents are replaced with the result. In order to merge the result into the original message compose this processor within a xref:components:processors/branch.adoc[`branch` processor].",
      "config": {
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to an array of values matching in size to the number of arguments required for the specified Redis command.",
          "required": false,
          "default": null,
          "examples": [
            "root = [ this.key ]",
            "root = [ meta(\"kafka_key\"), this.count ]"
          ]
        },
        "command": {
          "name": "command",
          "type": "string",
          "kind": "scalar",
          "description": "The command to execute.",
          "required": false,
          "default": null,
          "examples": [
            "scard",
            "incrby",
            "${! meta(\"command\") }"
          ]
        },
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "A key to use for the target operator.",
          "required": false,
          "default": null
        },
        "kind": {
          "name": "kind",
          "type": "string",
          "kind": "scalar",
          "description": "Specifies a simple, cluster-aware, or failover-aware redis client.",
          "required": true,
          "default": "simple",
          "options": [
            "simple",
            "cluster",
            "failover"
          ],
          "advanced": true
        },
        "master": {
          "name": "master",
          "type": "string",
          "kind": "scalar",
          "description": "Name of the redis master when `kind` is `failover`",
          "required": true,
          "default": "",
          "examples": [
            "mymaster"
          ],
          "advanced": true
        },
        "operator": {
          "name": "operator",
          "type": "string",
          "kind": "scalar",
          "description": "The operator to apply.",
          "required": false,
          "default": null
        },
        "retries": {
          "name": "retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retries before abandoning a request.",
          "required": true,
          "default": 3,
          "advanced": true
        },
        "retry_period": {
          "name": "retry_period",
          "type": "string",
          "kind": "scalar",
          "description": "The time to wait before consecutive retry attempts.",
          "required": true,
          "default": "500ms",
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.\n\n**Troubleshooting**\n\nSome cloud hosted instances of Redis (such as Azure Cache) might need some hand holding in order to establish stable connections. Unfortunately, it is often the case that TLS issues will manifest as generic error messages such as \"i/o timeout\". If you're using TLS and are seeing connectivity problems consider setting `enable_renegotiation` to `true`, and ensuring that the server supports at least TLS version 1.2.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL of the target Redis server. Database is optional and is supplied as the URL path.",
          "required": true,
          "default": null,
          "examples": [
            "redis://:6379",
            "redis://localhost:6379",
            "redis://foousername:foopassword@redisplace:6379",
            "redis://:foopassword@redisplace:6379",
            "redis://localhost:6379/1",
            "redis://localhost:6379/1,redis://localhost:6380/1"
          ]
        }
      }
    },
    "redis_script": {
      "name": "redis_script",
      "type": "processor",
      "source": "upstream",
      "summary": "Performs actions against Redis using https://redis.io/docs/manual/programmability/eval-intro/[LUA scripts^].",
      "description": "Actions are performed for each message and the message contents are replaced with the result.\n\nIn order to merge the result into the original message compose this processor within a xref:components:processors/branch.adoc[`branch` processor].",
      "config": {
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to an array of values matching in size to the number of arguments required for the specified Redis script.",
          "required": true,
          "default": null,
          "examples": [
            "root = [ this.key ]",
            "root = [ meta(\"kafka_key\"), \"hardcoded_value\" ]"
          ]
        },
        "keys_mapping": {
          "name": "keys_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to an array of keys matching in size to the number of arguments required for the specified Redis script.",
          "required": true,
          "default": null,
          "examples": [
            "root = [ this.key ]",
            "root = [ meta(\"kafka_key\"), this.count ]"
          ]
        },
        "kind": {
          "name": "kind",
          "type": "string",
          "kind": "scalar",
          "description": "Specifies a simple, cluster-aware, or failover-aware redis client.",
          "required": true,
          "default": "simple",
          "options": [
            "simple",
            "cluster",
            "failover"
          ],
          "advanced": true
        },
        "master": {
          "name": "master",
          "type": "string",
          "kind": "scalar",
          "description": "Name of the redis master when `kind` is `failover`",
          "required": true,
          "default": "",
          "examples": [
            "mymaster"
          ],
          "advanced": true
        },
        "retries": {
          "name": "retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retries before abandoning a request.",
          "required": true,
          "default": 3,
          "advanced": true
        },
        "retry_period": {
          "name": "retry_period",
          "type": "string",
          "kind": "scalar",
          "description": "The time to wait before consecutive retry attempts.",
          "required": true,
          "default": "500ms",
          "advanced": true
        },
        "script": {
          "name": "script",
          "type": "string",
          "kind": "scalar",
          "description": "A script to use for the target operator. It has precedence over the 'command' field.",
          "required": true,
          "default": null,
          "examples": [
            "return redis.call('set', KEYS[1], ARGV[1])"
          ]
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.\n\n**Troubleshooting**\n\nSome cloud hosted instances of Redis (such as Azure Cache) might need some hand holding in order to establish stable connections. Unfortunately, it is often the case that TLS issues will manifest as generic error messages such as \"i/o timeout\". If you're using TLS and are seeing connectivity problems consider setting `enable_renegotiation` to `true`, and ensuring that the server supports at least TLS version 1.2.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL of the target Redis server. Database is optional and is supplied as the URL path.",
          "required": true,
          "default": null,
          "examples": [
            "redis://:6379",
            "redis://localhost:6379",
            "redis://foousername:foopassword@redisplace:6379",
            "redis://:foopassword@redisplace:6379",
            "redis://localhost:6379/1",
            "redis://localhost:6379/1,redis://localhost:6380/1"
          ]
        }
      }
    },
    "redpanda_data_transform": {
      "name": "redpanda_data_transform",
      "type": "processor",
      "source": "upstream",
      "summary": "Executes a Redpanda Data Transform as a processor",
      "description": "\nThis processor executes a Redpanda Data Transform WebAssembly module, calling OnRecordWritten for each message being processed.\n\nYou can find out about how transforms work here: https://docs.redpanda.com/current/develop/data-transforms/how-transforms-work/[https://docs.redpanda.com/current/develop/data-transforms/how-transforms-work/^]\n",
      "config": {
        "input_headers": {
          "name": "input_headers",
          "type": "object",
          "kind": "scalar",
          "description": "Determine which (if any) metadata values should be added to messages as headers.",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "include_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  "foo_",
                  "bar_"
                ],
                [
                  "kafka_"
                ],
                [
                  "content-"
                ]
              ]
            },
            {
              "name": "include_patterns",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key regular expression (re2) patterns to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  ".*"
                ],
                [
                  "_timestamp_unix$"
                ]
              ]
            }
          ]
        },
        "input_key": {
          "name": "input_key",
          "type": "string",
          "kind": "scalar",
          "description": "An optional key to populate for each message.",
          "required": false,
          "default": null
        },
        "max_memory_pages": {
          "name": "max_memory_pages",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum amount of wasm memory pages (64KiB) that an individual wasm module instance can use",
          "required": true,
          "default": 1600,
          "advanced": true
        },
        "module_path": {
          "name": "module_path",
          "type": "string",
          "kind": "scalar",
          "description": "The path of the target WASM module to execute.",
          "required": true,
          "default": null
        },
        "output_key": {
          "name": "output_key",
          "type": "string",
          "kind": "scalar",
          "description": "An optional name of metadata for an output message key.",
          "required": false,
          "default": null
        },
        "output_metadata": {
          "name": "output_metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Determine which (if any) message headers should be added to the output as metadata.",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "include_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  "foo_",
                  "bar_"
                ],
                [
                  "kafka_"
                ],
                [
                  "content-"
                ]
              ]
            },
            {
              "name": "include_patterns",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key regular expression (re2) patterns to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  ".*"
                ],
                [
                  "_timestamp_unix$"
                ]
              ]
            }
          ]
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum period of time for a message to be processed",
          "required": true,
          "default": "10s",
          "advanced": true
        },
        "timestamp": {
          "name": "timestamp",
          "type": "string",
          "kind": "scalar",
          "description": "An optional timestamp to set for each message. When left empty, the current timestamp is used.",
          "required": false,
          "default": null,
          "examples": [
            "${! timestamp_unix() }",
            "${! metadata(\"kafka_timestamp_ms\") }"
          ],
          "advanced": true
        }
      }
    },
    "resource": {
      "name": "resource",
      "type": "processor",
      "source": "upstream",
      "summary": "Resource is a processor type that runs a processor resource identified by its label.",
      "description": "\nThis processor allows you to reference the same configured processor resource in multiple places, and can also tidy up large nested configs. For example, the config:\n\n```yaml\npipeline:\n  processors:\n    - mapping: |\n        root.message = this\n        root.meta.link_count = this.links.length()\n        root.user.age = this.user.age.number()\n```\n\nIs equivalent to:\n\n```yaml\npipeline:\n  processors:\n    - resource: foo_proc\n\nprocessor_resources:\n  - label: foo_proc\n    mapping: |\n      root.message = this\n      root.meta.link_count = this.links.length()\n      root.user.age = this.user.age.number()\n```\n\nYou can find out more about resources in xref:configuration:resources.adoc[]",
      "config": {}
    },
    "retry": {
      "name": "retry",
      "type": "processor",
      "source": "upstream",
      "summary": "Attempts to execute a series of child processors until success.",
      "description": "\nExecutes child processors and if a resulting message is errored then, after a specified backoff period, the same original message will be attempted again through those same processors. If the child processors result in more than one message then the retry mechanism will kick in if _any_ of the resulting messages are errored.\n\nIt is important to note that any mutations performed on the message during these child processors will be discarded for the next retry, and therefore it is safe to assume that each execution of the child processors will always be performed on the data as it was when it first reached the retry processor.\n\nBy default the retry backoff has a specified \u003c\u003cbackoffmax_elapsed_time,`max_elapsed_time`\u003e\u003e, if this time period is reached during retries and an error still occurs these errored messages will proceed through to the next processor after the retry (or your outputs). Normal xref:configuration:error_handling.adoc[error handling patterns] can be used on these messages.\n\nIn order to avoid permanent loops any error associated with messages as they first enter a retry processor will be cleared.\n\n== Metadata\n\nThis processor adds the following metadata fields to each message:\n\n```text\n- retry_count - The number of retry attempts.\n- backoff_duration - The total time elapsed while performing retries.\n```\n\n[CAUTION]\n.Batching\n====\nIf you wish to wrap a batch-aware series of processors then take a look at the \u003c\u003cbatching, batching section\u003e\u003e.\n====\n",
      "config": {
        "backoff": {
          "name": "backoff",
          "type": "object",
          "kind": "scalar",
          "description": "Determine time intervals and cut offs for retry attempts.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "initial_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The initial period to wait between retry attempts.",
              "required": true,
              "default": "500ms",
              "examples": [
                "50ms",
                "1s"
              ]
            },
            {
              "name": "max_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait between retry attempts",
              "required": true,
              "default": "10s",
              "examples": [
                "5s",
                "1m"
              ]
            },
            {
              "name": "max_elapsed_time",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum overall period of time to spend on retry attempts before the request is aborted. Setting this value to a zeroed duration (such as `0s`) will result in unbounded retries.",
              "required": true,
              "default": "1m",
              "examples": [
                "1m",
                "1h"
              ]
            }
          ]
        },
        "max_retries": {
          "name": "max_retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retry attempts before the request is aborted. Setting this value to `0` will result in unbounded number of retries.",
          "required": true,
          "default": 0
        },
        "parallel": {
          "name": "parallel",
          "type": "bool",
          "kind": "scalar",
          "description": "When processing batches of messages these batches are ignored and the processors apply to each message sequentially. However, when this field is set to `true` each message will be processed in parallel. Caution should be made to ensure that batch sizes do not surpass a point where this would cause resource (CPU, memory, API limits) contention.",
          "required": true,
          "default": false
        },
        "processors": {
          "name": "processors",
          "type": "processor",
          "kind": "array",
          "description": "A list of xref:components:processors/about.adoc[processors] to execute on each message.",
          "required": true,
          "default": null
        }
      }
    },
    "schema_registry_decode": {
      "name": "schema_registry_decode",
      "type": "processor",
      "source": "upstream",
      "summary": "Automatically decodes and validates messages with schemas from a Confluent Schema Registry service.",
      "description": "\nDecodes messages automatically from a schema stored within a https://docs.confluent.io/platform/current/schema-registry/index.html[Confluent Schema Registry service^] by extracting a schema ID from the message and obtaining the associated schema from the registry. If a message fails to match against the schema then it will remain unchanged and the error can be caught using xref:configuration:error_handling.adoc[error handling methods].\n\nAvro, Protobuf and Json schemas are supported, all are capable of expanding from schema references as of v4.22.0.\n\n== Avro JSON format\n\nThis processor creates documents formatted as https://avro.apache.org/docs/current/specification/_print/#json-encoding[Avro JSON^] when decoding with Avro schemas. In this format the value of a union is encoded in JSON as follows:\n\n- if its type is `null`, then it is encoded as a JSON `null`;\n- otherwise it is encoded as a JSON object with one name/value pair whose name is the type's name and whose value is the recursively encoded value. For Avro's named types (record, fixed or enum) the user-specified name is used, for other types the type name is used.\n\nFor example, the union schema `[\"null\",\"string\",\"Foo\"]`, where `Foo` is a record name, would encode:\n\n- `null` as `null`;\n- the string `\"a\"` as `{\"string\": \"a\"}`; and\n- a `Foo` instance as `{\"Foo\": {...}}`, where `{...}` indicates the JSON encoding of a `Foo` instance.\n\nHowever, it is possible to instead create documents in https://pkg.go.dev/github.com/linkedin/goavro/v2#NewCodecForStandardJSONFull[standard/raw JSON format^] by setting the field \u003c\u003cavro_raw_json, `avro_raw_json`\u003e\u003e to `true`.\n\n== Protobuf format\n\nThis processor decodes protobuf messages to JSON documents, you can read more about JSON mapping of protobuf messages here: https://developers.google.com/protocol-buffers/docs/proto3#json\n\n== Metadata\n\nThis processor also adds the following metadata to each outgoing message:\n\nschema_id: the ID of the schema in the schema registry that was associated with the message.\n",
      "config": {
        "avro": {
          "name": "avro",
          "type": "object",
          "kind": "scalar",
          "description": "Configuration for how to decode schemas that are of type AVRO.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "raw_unions",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether avro messages should be decoded into normal JSON (\"json that meets the expectations of regular internet json\") rather than https://avro.apache.org/docs/current/specification/_print/#json-encoding[JSON as specified in the Avro Spec^].\n\nFor example, if there is a union schema `[\"null\", \"string\", \"Foo\"]` where `Foo` is a record name, with raw_unions as false (the default) you get:\n- `null` as `null`;\n- the string `\"a\"` as `{\"string\": \"a\"}`; and\n- a `Foo` instance as `{\"Foo\": {...}}`, where `{...}` indicates the JSON encoding of a `Foo` instance.\n\nWhen raw_unions is set to true then the above union schema is decoded as the following:\n- `null` as `null`;\n- the string `\"a\"` as `\"a\"`; and\n- a `Foo` instance as `{...}`, where `{...}` indicates the JSON encoding of a `Foo` instance.\n",
              "required": false,
              "default": null
            },
            {
              "name": "preserve_logical_types",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether logical types should be preserved or transformed back into their primitive type. By default, decimals are decoded as raw bytes and timestamps are decoded as plain integers. Setting this field to true keeps decimal types as numbers in bloblang and timestamps as time values.",
              "required": true,
              "default": false
            },
            {
              "name": "mapping",
              "type": "string",
              "kind": "scalar",
              "description": "A custom mapping to apply to Avro schemas JSON representation. This is useful to transform custom types emitted by other tools into standard avro.",
              "required": false,
              "default": null,
              "examples": [
                "\nmap isDebeziumTimestampType {\n  root = this.type == \"long\" \u0026\u0026 this.\"connect.name\" == \"io.debezium.time.Timestamp\" \u0026\u0026 !this.exists(\"logicalType\")\n}\nmap debeziumTimestampToAvroTimestamp {\n  let mapped_fields = this.fields.or([]).map_each(item -\u003e item.apply(\"debeziumTimestampToAvroTimestamp\"))\n  root = match {\n    this.type == \"record\" =\u003e this.assign({\"fields\": $mapped_fields})\n    this.type.type() == \"array\" =\u003e this.assign({\"type\": this.type.map_each(item -\u003e item.apply(\"debeziumTimestampToAvroTimestamp\"))})\n    # Add a logical type so that it's decoded as a timestamp instead of a long.\n    this.type.type() == \"object\" \u0026\u0026 this.type.apply(\"isDebeziumTimestampType\") =\u003e this.merge({\"type\":{\"logicalType\": \"timestamp-millis\"}})\n    _ =\u003e this\n  }\n}\nroot = this.apply(\"debeziumTimestampToAvroTimestamp\")\n"
              ],
              "advanced": true
            }
          ]
        },
        "avro_raw_json": {
          "name": "avro_raw_json",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether Avro messages should be decoded into normal JSON (\"json that meets the expectations of regular internet json\") rather than https://avro.apache.org/docs/current/specification/_print/#json-encoding[Avro JSON^]. If `true` the schema returned from the subject should be decoded as https://pkg.go.dev/github.com/linkedin/goavro/v2#NewCodecForStandardJSONFull[standard json^] instead of as https://pkg.go.dev/github.com/linkedin/goavro/v2#NewCodec[avro json^]. There is a https://github.com/linkedin/goavro/blob/5ec5a5ee7ec82e16e6e2b438d610e1cab2588393/union.go#L224-L249[comment in goavro^], the https://github.com/linkedin/goavro[underlining library used for avro serialization^], that explains in more detail the difference between the standard json and avro json.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "basic_auth": {
          "name": "basic_auth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify basic authentication.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use basic authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "A username to authenticate as.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A password to authenticate with.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "jwt": {
          "name": "jwt",
          "type": "object",
          "kind": "scalar",
          "description": "BETA: Allows you to specify JWT authentication.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use JWT authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "private_key_file",
              "type": "string",
              "kind": "scalar",
              "description": "A file with the PEM encoded via PKCS1 or PKCS8 as private key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "signing_method",
              "type": "string",
              "kind": "scalar",
              "description": "A method used to sign the token such as RS256, RS384, RS512 or EdDSA.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "claims",
              "type": "unknown",
              "kind": "map",
              "description": "A value used to identify the claims that issued the JWT.",
              "required": true,
              "default": {},
              "advanced": true
            },
            {
              "name": "headers",
              "type": "unknown",
              "kind": "map",
              "description": "Add optional key/value headers to the JWT.",
              "required": true,
              "default": {},
              "advanced": true
            }
          ]
        },
        "oauth": {
          "name": "oauth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify open authentication via OAuth version 1.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use OAuth version 1 in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "consumer_key",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to identify the client to the service provider.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "consumer_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret used to establish ownership of the consumer key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "access_token",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to gain access to the protected resources on behalf of the user.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "access_token_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret provided in order to establish ownership of a given access token.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The base URL of the schema registry service.",
          "required": true,
          "default": null
        }
      }
    },
    "schema_registry_encode": {
      "name": "schema_registry_encode",
      "type": "processor",
      "source": "upstream",
      "summary": "Automatically encodes and validates messages with schemas from a Confluent Schema Registry service.",
      "description": "\nEncodes messages automatically from schemas obtains from a https://docs.confluent.io/platform/current/schema-registry/index.html[Confluent Schema Registry service^] by polling the service for the latest schema version for target subjects.\n\nIf a message fails to encode under the schema then it will remain unchanged and the error can be caught using xref:configuration:error_handling.adoc[error handling methods].\n\nAvro, Protobuf and Json schemas are supported, all are capable of expanding from schema references as of v4.22.0.\n\n== Avro JSON format\n\nBy default this processor expects documents formatted as https://avro.apache.org/docs/current/specification/_print/#json-encoding[Avro JSON^] when encoding with Avro schemas. In this format the value of a union is encoded in JSON as follows:\n\n- if its type is `null`, then it is encoded as a JSON `null`;\n- otherwise it is encoded as a JSON object with one name/value pair whose name is the type's name and whose value is the recursively encoded value. For Avro's named types (record, fixed or enum) the user-specified name is used, for other types the type name is used.\n\nFor example, the union schema `[\"null\",\"string\",\"Foo\"]`, where `Foo` is a record name, would encode:\n\n- `null` as `null`;\n- the string `\"a\"` as `\\{\"string\": \"a\"}`; and\n- a `Foo` instance as `\\{\"Foo\": {...}}`, where `{...}` indicates the JSON encoding of a `Foo` instance.\n\nHowever, it is possible to instead consume documents in https://pkg.go.dev/github.com/linkedin/goavro/v2#NewCodecForStandardJSONFull[standard/raw JSON format^] by setting the field \u003c\u003cavro_raw_json, `avro_raw_json`\u003e\u003e to `true`.\n\n=== Known issues\n\nImportant! There is an outstanding issue in the https://github.com/linkedin/goavro[avro serializing library^] that Redpanda Connect uses which means it https://github.com/linkedin/goavro/issues/252[doesn't encode logical types correctly^]. It's still possible to encode logical types that are in-line with the spec if `avro_raw_json` is set to true, though now of course non-logical types will not be in-line with the spec.\n\n== Protobuf format\n\nThis processor encodes protobuf messages either from any format parsed within Redpanda Connect (encoded as JSON by default), or from raw JSON documents, you can read more about JSON mapping of protobuf messages here: https://developers.google.com/protocol-buffers/docs/proto3#json\n\n=== Multiple message support\n\nWhen a target subject presents a protobuf schema that contains multiple messages it becomes ambiguous which message definition a given input data should be encoded against. In such scenarios Redpanda Connect will attempt to encode the data against each of them and select the first to successfully match against the data, this process currently *ignores all nested message definitions*. In order to speed up this exhaustive search the last known successful message will be attempted first for each subsequent input.\n\nWe will be considering alternative approaches in future so please https://redpanda.com/slack[get in touch^] with thoughts and feedback.\n",
      "config": {
        "avro_raw_json": {
          "name": "avro_raw_json",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages encoded in Avro format should be parsed as normal JSON (\"json that meets the expectations of regular internet json\") rather than https://avro.apache.org/docs/current/specification/_print/#json-encoding[Avro JSON^]. If `true` the schema returned from the subject should be parsed as https://pkg.go.dev/github.com/linkedin/goavro/v2#NewCodecForStandardJSONFull[standard json^] instead of as https://pkg.go.dev/github.com/linkedin/goavro/v2#NewCodec[avro json^]. There is a https://github.com/linkedin/goavro/blob/5ec5a5ee7ec82e16e6e2b438d610e1cab2588393/union.go#L224-L249[comment in goavro^], the https://github.com/linkedin/goavro[underlining library used for avro serialization^], that explains in more detail the difference between standard json and avro json.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "basic_auth": {
          "name": "basic_auth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify basic authentication.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use basic authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "A username to authenticate as.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A password to authenticate with.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "jwt": {
          "name": "jwt",
          "type": "object",
          "kind": "scalar",
          "description": "BETA: Allows you to specify JWT authentication.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use JWT authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "private_key_file",
              "type": "string",
              "kind": "scalar",
              "description": "A file with the PEM encoded via PKCS1 or PKCS8 as private key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "signing_method",
              "type": "string",
              "kind": "scalar",
              "description": "A method used to sign the token such as RS256, RS384, RS512 or EdDSA.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "claims",
              "type": "unknown",
              "kind": "map",
              "description": "A value used to identify the claims that issued the JWT.",
              "required": true,
              "default": {},
              "advanced": true
            },
            {
              "name": "headers",
              "type": "unknown",
              "kind": "map",
              "description": "Add optional key/value headers to the JWT.",
              "required": true,
              "default": {},
              "advanced": true
            }
          ]
        },
        "oauth": {
          "name": "oauth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify open authentication via OAuth version 1.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use OAuth version 1 in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "consumer_key",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to identify the client to the service provider.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "consumer_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret used to establish ownership of the consumer key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "access_token",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to gain access to the protected resources on behalf of the user.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "access_token_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret provided in order to establish ownership of a given access token.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "refresh_period": {
          "name": "refresh_period",
          "type": "string",
          "kind": "scalar",
          "description": "The period after which a schema is refreshed for each subject, this is done by polling the schema registry service.",
          "required": true,
          "default": "10m",
          "examples": [
            "60s",
            "1h"
          ]
        },
        "subject": {
          "name": "subject",
          "type": "string",
          "kind": "scalar",
          "description": "The schema subject to derive schemas from.",
          "required": true,
          "default": null,
          "examples": [
            "foo",
            "${! meta(\"kafka_topic\") }"
          ]
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The base URL of the schema registry service.",
          "required": true,
          "default": null
        }
      }
    },
    "select_parts": {
      "name": "select_parts",
      "type": "processor",
      "source": "upstream",
      "summary": "Cherry pick a set of messages from a batch by their index. Indexes larger than the number of messages are simply ignored.",
      "description": "\nThe selected parts are added to the new message batch in the same order as the selection array. E.g. with 'parts' set to [ 2, 0, 1 ] and the message parts [ '0', '1', '2', '3' ], the output will be [ '2', '0', '1' ].\n\nIf none of the selected parts exist in the input batch (resulting in an empty output message) the batch is dropped entirely.\n\nMessage indexes can be negative, and if so the part will be selected from the end counting backwards starting from -1. E.g. if index = -1 then the selected part will be the last part of the message, if index = -2 then the part before the last element with be selected, and so on.\n\nThis processor is only applicable to xref:configuration:batching.adoc[batched messages].",
      "config": {
        "parts": {
          "name": "parts",
          "type": "int",
          "kind": "array",
          "description": "An array of message indexes of a batch. Indexes can be negative, and if so the part will be selected from the end counting backwards starting from -1.",
          "required": true,
          "default": []
        }
      }
    },
    "sentry_capture": {
      "name": "sentry_capture",
      "type": "processor",
      "source": "upstream",
      "summary": "Captures log events from messages and submits them to https://sentry.io/[Sentry^].",
      "config": {
        "context": {
          "name": "context",
          "type": "string",
          "kind": "scalar",
          "description": "A mapping that must evaluate to an object-of-objects or `deleted()`. If this mapping produces a value, then it is set on a sentry event as additional context.",
          "required": false,
          "default": null,
          "examples": [
            "root = {\"order\": {\"product_id\": \"P93174\", \"quantity\": 5}}",
            "root = deleted()"
          ]
        },
        "dsn": {
          "name": "dsn",
          "type": "string",
          "kind": "scalar",
          "description": "The DSN address to send sentry events to. If left empty, then SENTRY_DSN is used.",
          "required": true,
          "default": ""
        },
        "environment": {
          "name": "environment",
          "type": "string",
          "kind": "scalar",
          "description": "The environment to be sent with events. If left empty, then SENTRY_ENVIRONMENT is used.",
          "required": true,
          "default": ""
        },
        "flush_timeout": {
          "name": "flush_timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The duration to wait when closing the processor to flush any remaining enqueued events.",
          "required": true,
          "default": "5s"
        },
        "level": {
          "name": "level",
          "type": "string",
          "kind": "scalar",
          "description": "Sets the level on sentry events similar to logging levels.",
          "required": true,
          "default": "INFO",
          "options": [
            "DEBUG",
            "INFO",
            "WARN",
            "ERROR",
            "FATAL"
          ]
        },
        "message": {
          "name": "message",
          "type": "string",
          "kind": "scalar",
          "description": "A message to set on the sentry event",
          "required": true,
          "default": null,
          "examples": [
            "webhook event received",
            "failed to find product in database: ${! error() }"
          ]
        },
        "release": {
          "name": "release",
          "type": "string",
          "kind": "scalar",
          "description": "The version of the code deployed to an environment. If left empty, then the Sentry client will attempt to detect the release from the environment.",
          "required": true,
          "default": ""
        },
        "sampling_rate": {
          "name": "sampling_rate",
          "type": "float",
          "kind": "scalar",
          "description": "The rate at which events are sent to the server. A value of 0 disables capturing sentry events entirely. A value of 1 results in sending all events to Sentry. Any value in between results sending some percentage of events.",
          "required": true,
          "default": 1
        },
        "tags": {
          "name": "tags",
          "type": "string",
          "kind": "map",
          "description": "Sets key/value string tags on an event. Unlike context, these are indexed and searchable on Sentry but have length limitations.",
          "required": false,
          "default": null
        },
        "transport_mode": {
          "name": "transport_mode",
          "type": "string",
          "kind": "scalar",
          "description": "Determines how events are sent. A sync transport will block when sending each event until a response is received from the Sentry server. The recommended async transport will enqueue events in a buffer and send them in the background.",
          "required": true,
          "default": "async",
          "options": [
            "async",
            "sync"
          ]
        }
      }
    },
    "sleep": {
      "name": "sleep",
      "type": "processor",
      "source": "upstream",
      "summary": "Sleep for a period of time specified as a duration string for each message. This processor will interpolate functions within the `duration` field, you can find a list of functions xref:configuration:interpolation.adoc#bloblang-queries[here].",
      "config": {
        "duration": {
          "name": "duration",
          "type": "string",
          "kind": "scalar",
          "description": "The duration of time to sleep for each execution.",
          "required": true,
          "default": null
        }
      }
    },
    "split": {
      "name": "split",
      "type": "processor",
      "source": "upstream",
      "summary": "Breaks message batches (synonymous with multiple part messages) into smaller batches. The size of the resulting batches are determined either by a discrete size or, if the field `byte_size` is non-zero, then by total size in bytes (which ever limit is reached first).",
      "description": "\nThis processor is for breaking batches down into smaller ones. In order to break a single message out into multiple messages use the xref:components:processors/unarchive.adoc[`unarchive` processor].\n\nIf there is a remainder of messages after splitting a batch the remainder is also sent as a single batch. For example, if your target size was 10, and the processor received a batch of 95 message parts, the result would be 9 batches of 10 messages followed by a batch of 5 messages.",
      "config": {
        "byte_size": {
          "name": "byte_size",
          "type": "int",
          "kind": "scalar",
          "description": "An optional target of total message bytes.",
          "required": true,
          "default": 0
        },
        "size": {
          "name": "size",
          "type": "int",
          "kind": "scalar",
          "description": "The target number of messages.",
          "required": true,
          "default": 1
        }
      }
    },
    "sql": {
      "name": "sql",
      "type": "processor",
      "source": "upstream",
      "summary": "Runs an arbitrary SQL query against a database and (optionally) returns the result as an array of objects, one for each row returned.",
      "description": "\nIf the query fails to execute then the message will remain unchanged and the error can be caught using xref:configuration:error_handling.adoc[error handling methods].\n\n== Alternatives\n\nFor basic inserts or select queries use either the xref:components:processors/sql_insert.adoc[`sql_insert`] or the xref:components:processors/sql_select.adoc[`sql_select`] processor. For more complex queries use the xref:components:processors/sql_raw.adoc[`sql_raw`] processor.",
      "config": {
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to an array of values matching in size to the number of placeholder arguments in the field `query`.",
          "required": false,
          "default": null,
          "examples": [
            "root = [ this.cat.meow, this.doc.woofs[0] ]",
            "root = [ meta(\"user.id\") ]"
          ]
        },
        "data_source_name": {
          "name": "data_source_name",
          "type": "string",
          "kind": "scalar",
          "description": "Data source name.",
          "required": true,
          "default": null
        },
        "driver": {
          "name": "driver",
          "type": "string",
          "kind": "scalar",
          "description": "A database \u003c\u003cdrivers, driver\u003e\u003e to use.",
          "required": true,
          "default": null,
          "options": [
            "mysql",
            "postgres",
            "clickhouse",
            "mssql",
            "sqlite",
            "oracle",
            "snowflake",
            "trino",
            "gocosmos",
            "spanner"
          ]
        },
        "query": {
          "name": "query",
          "type": "string",
          "kind": "scalar",
          "description": "The query to execute. The style of placeholder to use depends on the driver, some drivers require question marks (`?`) whereas others expect incrementing dollar signs (`$1`, `$2`, and so on) or colons (`:1`, `:2` and so on). The style to use is outlined in this table:\n\n| Driver | Placeholder Style |\n|---|---|\n| `clickhouse` | Dollar sign |\n| `mysql` | Question mark |\n| `postgres` | Dollar sign |\n| `mssql` | Question mark |\n| `sqlite` | Question mark |\n| `oracle` | Colon |\n| `snowflake` | Question mark |\n| `trino` | Question mark |\n| `gocosmos` | Colon |\n",
          "required": true,
          "default": null,
          "examples": [
            "INSERT INTO footable (foo, bar, baz) VALUES (?, ?, ?);"
          ]
        },
        "result_codec": {
          "name": "result_codec",
          "type": "string",
          "kind": "scalar",
          "description": "Result codec.",
          "required": true,
          "default": "none"
        },
        "unsafe_dynamic_query": {
          "name": "unsafe_dynamic_query",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to enable xref:configuration:interpolation.adoc#bloblang-queries[interpolation functions] in the query. Great care should be made to ensure your queries are defended against injection attacks.",
          "required": true,
          "default": false,
          "advanced": true
        }
      }
    },
    "sql_insert": {
      "name": "sql_insert",
      "type": "processor",
      "source": "upstream",
      "summary": "Inserts rows into an SQL database for each message, and leaves the message unchanged.",
      "description": "\nIf the insert fails to execute then the message will still remain unchanged and the error can be caught using xref:configuration:error_handling.adoc[error handling methods].",
      "config": {
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to an array of values matching in size to the number of columns specified.",
          "required": true,
          "default": null,
          "examples": [
            "root = [ this.cat.meow, this.doc.woofs[0] ]",
            "root = [ meta(\"user.id\") ]"
          ]
        },
        "columns": {
          "name": "columns",
          "type": "string",
          "kind": "array",
          "description": "A list of columns to insert.",
          "required": true,
          "default": null,
          "examples": [
            [
              "foo",
              "bar",
              "baz"
            ]
          ]
        },
        "conn_max_idle": {
          "name": "conn_max_idle",
          "type": "int",
          "kind": "scalar",
          "description": "An optional maximum number of connections in the idle connection pool. If conn_max_open is greater than 0 but less than the new conn_max_idle, then the new conn_max_idle will be reduced to match the conn_max_open limit. If `value \u003c= 0`, no idle connections are retained. The default max idle connections is currently 2. This may change in a future release.",
          "required": false,
          "default": 2,
          "advanced": true
        },
        "conn_max_idle_time": {
          "name": "conn_max_idle_time",
          "type": "string",
          "kind": "scalar",
          "description": "An optional maximum amount of time a connection may be idle. Expired connections may be closed lazily before reuse. If `value \u003c= 0`, connections are not closed due to a connections idle time.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "conn_max_life_time": {
          "name": "conn_max_life_time",
          "type": "string",
          "kind": "scalar",
          "description": "An optional maximum amount of time a connection may be reused. Expired connections may be closed lazily before reuse. If `value \u003c= 0`, connections are not closed due to a connections age.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "conn_max_open": {
          "name": "conn_max_open",
          "type": "int",
          "kind": "scalar",
          "description": "An optional maximum number of open connections to the database. If conn_max_idle is greater than 0 and the new conn_max_open is less than conn_max_idle, then conn_max_idle will be reduced to match the new conn_max_open limit. If `value \u003c= 0`, then there is no limit on the number of open connections. The default is 0 (unlimited).",
          "required": false,
          "default": null,
          "advanced": true
        },
        "driver": {
          "name": "driver",
          "type": "string",
          "kind": "scalar",
          "description": "A database \u003c\u003cdrivers, driver\u003e\u003e to use.",
          "required": true,
          "default": null,
          "options": [
            "mysql",
            "postgres",
            "clickhouse",
            "mssql",
            "sqlite",
            "oracle",
            "snowflake",
            "trino",
            "gocosmos",
            "spanner"
          ]
        },
        "dsn": {
          "name": "dsn",
          "type": "string",
          "kind": "scalar",
          "description": "A Data Source Name to identify the target database.\n\n==== Drivers\n\n:driver-support: mysql=certified, postgres=certified, clickhouse=community, mssql=community, sqlite=certified, oracle=certified, snowflake=community, trino=community, gocosmos=community, spanner=community\n\nThe following is a list of supported drivers, their placeholder style, and their respective DSN formats:\n\n|===\n| Driver | Data Source Name Format\n\n| `clickhouse` \n| https://github.com/ClickHouse/clickhouse-go#dsn[`clickhouse://[username[:password\\]@\\][netloc\\][:port\\]/dbname[?param1=value1\u0026...\u0026paramN=valueN\\]`^] \n\n| `mysql` \n| `[username[:password]@][protocol[(address)]]/dbname[?param1=value1\u0026...\u0026paramN=valueN]` \n\n| `postgres` \n| `postgres://[user[:password]@][netloc][:port][/dbname][?param1=value1\u0026...]` \n\n| `mssql` \n| `sqlserver://[user[:password]@][netloc][:port][?database=dbname\u0026param1=value1\u0026...]` \n\n| `sqlite` \n| `file:/path/to/filename.db[?param\u0026=value1\u0026...]` \n\n| `oracle` \n| `oracle://[username[:password]@][netloc][:port]/service_name?server=server2\u0026server=server3` \n\n| `snowflake` \n| `username[:password]@account_identifier/dbname/schemaname[?param1=value\u0026...\u0026paramN=valueN]` \n\n| `trino` \n| https://github.com/trinodb/trino-go-client#dsn-data-source-name[`http[s\\]://user[:pass\\]@host[:port\\][?parameters\\]`^] \n\n| `gocosmos` \n| https://pkg.go.dev/github.com/microsoft/gocosmos#readme-example-usage[`AccountEndpoint=\u003ccosmosdb-endpoint\u003e;AccountKey=\u003ccosmosdb-account-key\u003e[;TimeoutMs=\u003ctimeout-in-ms\u003e\\][;Version=\u003ccosmosdb-api-version\u003e\\][;DefaultDb/Db=\u003cdb-name\u003e\\][;AutoId=\u003ctrue/false\u003e\\][;InsecureSkipVerify=\u003ctrue/false\u003e\\]`^] \n\n| `spanner` \n| projects/[PROJECT]/instances/[INSTANCE]/databases/[DATABASE] \n|===\n\nPlease note that the `postgres` driver enforces SSL by default, you can override this with the parameter `sslmode=disable` if required.\n\nThe `snowflake` driver supports multiple DSN formats. Please consult https://pkg.go.dev/github.com/snowflakedb/gosnowflake#hdr-Connection_String[the docs^] for more details. For https://docs.snowflake.com/en/user-guide/key-pair-auth.html#configuring-key-pair-authentication[key pair authentication^], the DSN has the following format: `\u003csnowflake_user\u003e@\u003csnowflake_account\u003e/\u003cdb_name\u003e/\u003cschema_name\u003e?warehouse=\u003cwarehouse\u003e\u0026role=\u003crole\u003e\u0026authenticator=snowflake_jwt\u0026privateKey=\u003cbase64_url_encoded_private_key\u003e`, where the value for the `privateKey` parameter can be constructed from an unencrypted RSA private key file `rsa_key.p8` using `openssl enc -d -base64 -in rsa_key.p8 | basenc --base64url -w0` (you can use `gbasenc` insted of `basenc` on OSX if you install `coreutils` via Homebrew). If you have a password-encrypted private key, you can decrypt it using `openssl pkcs8 -in rsa_key_encrypted.p8 -out rsa_key.p8`. Also, make sure fields such as the username are URL-encoded.\n\nThe https://pkg.go.dev/github.com/microsoft/gocosmos[`gocosmos`^] driver is still experimental, but it has support for https://learn.microsoft.com/en-us/azure/cosmos-db/hierarchical-partition-keys[hierarchical partition keys^] as well as https://learn.microsoft.com/en-us/azure/cosmos-db/nosql/how-to-query-container#cross-partition-query[cross-partition queries^]. Please refer to the https://github.com/microsoft/gocosmos/blob/main/SQL.md[SQL notes^] for details.",
          "required": true,
          "default": null,
          "examples": [
            "clickhouse://username:password@host1:9000,host2:9000/database?dial_timeout=200ms\u0026max_execution_time=60",
            "foouser:foopassword@tcp(localhost:3306)/foodb",
            "postgres://foouser:foopass@localhost:5432/foodb?sslmode=disable",
            "oracle://foouser:foopass@localhost:1521/service_name"
          ]
        },
        "init_files": {
          "name": "init_files",
          "type": "string",
          "kind": "array",
          "description": "\nAn optional list of file paths containing SQL statements to execute immediately upon the first connection to the target database. This is a useful way to initialise tables before processing data. Glob patterns are supported, including super globs (double star).\n\nCare should be taken to ensure that the statements are idempotent, and therefore would not cause issues when run multiple times after service restarts. If both `init_statement` and `init_files` are specified the `init_statement` is executed _after_ the `init_files`.\n\nIf a statement fails for any reason a warning log will be emitted but the operation of this component will not be stopped.\n",
          "required": false,
          "default": null,
          "examples": [
            [
              "./init/*.sql"
            ],
            [
              "./foo.sql",
              "./bar.sql"
            ]
          ],
          "advanced": true
        },
        "init_statement": {
          "name": "init_statement",
          "type": "string",
          "kind": "scalar",
          "description": "\nAn optional SQL statement to execute immediately upon the first connection to the target database. This is a useful way to initialise tables before processing data. Care should be taken to ensure that the statement is idempotent, and therefore would not cause issues when run multiple times after service restarts.\n\nIf both `init_statement` and `init_files` are specified the `init_statement` is executed _after_ the `init_files`.\n\nIf the statement fails for any reason a warning log will be emitted but the operation of this component will not be stopped.\n",
          "required": false,
          "default": null,
          "examples": [
            "\nCREATE TABLE IF NOT EXISTS some_table (\n  foo varchar(50) not null,\n  bar integer,\n  baz varchar(50),\n  primary key (foo)\n) WITHOUT ROWID;\n"
          ],
          "advanced": true
        },
        "options": {
          "name": "options",
          "type": "string",
          "kind": "array",
          "description": "A list of keyword options to add before the INTO clause of the query.",
          "required": false,
          "default": null,
          "examples": [
            [
              "DELAYED",
              "IGNORE"
            ]
          ],
          "advanced": true
        },
        "prefix": {
          "name": "prefix",
          "type": "string",
          "kind": "scalar",
          "description": "An optional prefix to prepend to the insert query (before INSERT).",
          "required": false,
          "default": null,
          "advanced": true
        },
        "suffix": {
          "name": "suffix",
          "type": "string",
          "kind": "scalar",
          "description": "An optional suffix to append to the insert query.",
          "required": false,
          "default": null,
          "examples": [
            "ON CONFLICT (name) DO NOTHING"
          ],
          "advanced": true
        },
        "table": {
          "name": "table",
          "type": "string",
          "kind": "scalar",
          "description": "The table to insert to.",
          "required": true,
          "default": null,
          "examples": [
            "foo"
          ]
        }
      }
    },
    "sql_raw": {
      "name": "sql_raw",
      "type": "processor",
      "source": "upstream",
      "summary": "Runs an arbitrary SQL query against a database and (optionally) returns the result as an array of objects, one for each row returned.",
      "description": "\nIf the query fails to execute then the message will remain unchanged and the error can be caught using xref:configuration:error_handling.adoc[error handling methods].",
      "config": {
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to an array of values matching in size to the number of placeholder arguments in the field `query`.",
          "required": false,
          "default": null,
          "examples": [
            "root = [ this.cat.meow, this.doc.woofs[0] ]",
            "root = [ meta(\"user.id\") ]"
          ]
        },
        "conn_max_idle": {
          "name": "conn_max_idle",
          "type": "int",
          "kind": "scalar",
          "description": "An optional maximum number of connections in the idle connection pool. If conn_max_open is greater than 0 but less than the new conn_max_idle, then the new conn_max_idle will be reduced to match the conn_max_open limit. If `value \u003c= 0`, no idle connections are retained. The default max idle connections is currently 2. This may change in a future release.",
          "required": false,
          "default": 2,
          "advanced": true
        },
        "conn_max_idle_time": {
          "name": "conn_max_idle_time",
          "type": "string",
          "kind": "scalar",
          "description": "An optional maximum amount of time a connection may be idle. Expired connections may be closed lazily before reuse. If `value \u003c= 0`, connections are not closed due to a connections idle time.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "conn_max_life_time": {
          "name": "conn_max_life_time",
          "type": "string",
          "kind": "scalar",
          "description": "An optional maximum amount of time a connection may be reused. Expired connections may be closed lazily before reuse. If `value \u003c= 0`, connections are not closed due to a connections age.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "conn_max_open": {
          "name": "conn_max_open",
          "type": "int",
          "kind": "scalar",
          "description": "An optional maximum number of open connections to the database. If conn_max_idle is greater than 0 and the new conn_max_open is less than conn_max_idle, then conn_max_idle will be reduced to match the new conn_max_open limit. If `value \u003c= 0`, then there is no limit on the number of open connections. The default is 0 (unlimited).",
          "required": false,
          "default": null,
          "advanced": true
        },
        "driver": {
          "name": "driver",
          "type": "string",
          "kind": "scalar",
          "description": "A database \u003c\u003cdrivers, driver\u003e\u003e to use.",
          "required": true,
          "default": null,
          "options": [
            "mysql",
            "postgres",
            "clickhouse",
            "mssql",
            "sqlite",
            "oracle",
            "snowflake",
            "trino",
            "gocosmos",
            "spanner"
          ]
        },
        "dsn": {
          "name": "dsn",
          "type": "string",
          "kind": "scalar",
          "description": "A Data Source Name to identify the target database.\n\n==== Drivers\n\n:driver-support: mysql=certified, postgres=certified, clickhouse=community, mssql=community, sqlite=certified, oracle=certified, snowflake=community, trino=community, gocosmos=community, spanner=community\n\nThe following is a list of supported drivers, their placeholder style, and their respective DSN formats:\n\n|===\n| Driver | Data Source Name Format\n\n| `clickhouse` \n| https://github.com/ClickHouse/clickhouse-go#dsn[`clickhouse://[username[:password\\]@\\][netloc\\][:port\\]/dbname[?param1=value1\u0026...\u0026paramN=valueN\\]`^] \n\n| `mysql` \n| `[username[:password]@][protocol[(address)]]/dbname[?param1=value1\u0026...\u0026paramN=valueN]` \n\n| `postgres` \n| `postgres://[user[:password]@][netloc][:port][/dbname][?param1=value1\u0026...]` \n\n| `mssql` \n| `sqlserver://[user[:password]@][netloc][:port][?database=dbname\u0026param1=value1\u0026...]` \n\n| `sqlite` \n| `file:/path/to/filename.db[?param\u0026=value1\u0026...]` \n\n| `oracle` \n| `oracle://[username[:password]@][netloc][:port]/service_name?server=server2\u0026server=server3` \n\n| `snowflake` \n| `username[:password]@account_identifier/dbname/schemaname[?param1=value\u0026...\u0026paramN=valueN]` \n\n| `trino` \n| https://github.com/trinodb/trino-go-client#dsn-data-source-name[`http[s\\]://user[:pass\\]@host[:port\\][?parameters\\]`^] \n\n| `gocosmos` \n| https://pkg.go.dev/github.com/microsoft/gocosmos#readme-example-usage[`AccountEndpoint=\u003ccosmosdb-endpoint\u003e;AccountKey=\u003ccosmosdb-account-key\u003e[;TimeoutMs=\u003ctimeout-in-ms\u003e\\][;Version=\u003ccosmosdb-api-version\u003e\\][;DefaultDb/Db=\u003cdb-name\u003e\\][;AutoId=\u003ctrue/false\u003e\\][;InsecureSkipVerify=\u003ctrue/false\u003e\\]`^] \n\n| `spanner` \n| projects/[PROJECT]/instances/[INSTANCE]/databases/[DATABASE] \n|===\n\nPlease note that the `postgres` driver enforces SSL by default, you can override this with the parameter `sslmode=disable` if required.\n\nThe `snowflake` driver supports multiple DSN formats. Please consult https://pkg.go.dev/github.com/snowflakedb/gosnowflake#hdr-Connection_String[the docs^] for more details. For https://docs.snowflake.com/en/user-guide/key-pair-auth.html#configuring-key-pair-authentication[key pair authentication^], the DSN has the following format: `\u003csnowflake_user\u003e@\u003csnowflake_account\u003e/\u003cdb_name\u003e/\u003cschema_name\u003e?warehouse=\u003cwarehouse\u003e\u0026role=\u003crole\u003e\u0026authenticator=snowflake_jwt\u0026privateKey=\u003cbase64_url_encoded_private_key\u003e`, where the value for the `privateKey` parameter can be constructed from an unencrypted RSA private key file `rsa_key.p8` using `openssl enc -d -base64 -in rsa_key.p8 | basenc --base64url -w0` (you can use `gbasenc` insted of `basenc` on OSX if you install `coreutils` via Homebrew). If you have a password-encrypted private key, you can decrypt it using `openssl pkcs8 -in rsa_key_encrypted.p8 -out rsa_key.p8`. Also, make sure fields such as the username are URL-encoded.\n\nThe https://pkg.go.dev/github.com/microsoft/gocosmos[`gocosmos`^] driver is still experimental, but it has support for https://learn.microsoft.com/en-us/azure/cosmos-db/hierarchical-partition-keys[hierarchical partition keys^] as well as https://learn.microsoft.com/en-us/azure/cosmos-db/nosql/how-to-query-container#cross-partition-query[cross-partition queries^]. Please refer to the https://github.com/microsoft/gocosmos/blob/main/SQL.md[SQL notes^] for details.",
          "required": true,
          "default": null,
          "examples": [
            "clickhouse://username:password@host1:9000,host2:9000/database?dial_timeout=200ms\u0026max_execution_time=60",
            "foouser:foopassword@tcp(localhost:3306)/foodb",
            "postgres://foouser:foopass@localhost:5432/foodb?sslmode=disable",
            "oracle://foouser:foopass@localhost:1521/service_name"
          ]
        },
        "exec_only": {
          "name": "exec_only",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether the query result should be discarded. When set to `true` the message contents will remain unchanged, which is useful in cases where you are executing inserts, updates, etc. By default this is true for the last query, and previous queries don't change the results. If set to true for any query but the last one, the subsequent `args_mappings` input is overwritten.",
          "required": false,
          "default": null
        },
        "init_files": {
          "name": "init_files",
          "type": "string",
          "kind": "array",
          "description": "\nAn optional list of file paths containing SQL statements to execute immediately upon the first connection to the target database. This is a useful way to initialise tables before processing data. Glob patterns are supported, including super globs (double star).\n\nCare should be taken to ensure that the statements are idempotent, and therefore would not cause issues when run multiple times after service restarts. If both `init_statement` and `init_files` are specified the `init_statement` is executed _after_ the `init_files`.\n\nIf a statement fails for any reason a warning log will be emitted but the operation of this component will not be stopped.\n",
          "required": false,
          "default": null,
          "examples": [
            [
              "./init/*.sql"
            ],
            [
              "./foo.sql",
              "./bar.sql"
            ]
          ],
          "advanced": true
        },
        "init_statement": {
          "name": "init_statement",
          "type": "string",
          "kind": "scalar",
          "description": "\nAn optional SQL statement to execute immediately upon the first connection to the target database. This is a useful way to initialise tables before processing data. Care should be taken to ensure that the statement is idempotent, and therefore would not cause issues when run multiple times after service restarts.\n\nIf both `init_statement` and `init_files` are specified the `init_statement` is executed _after_ the `init_files`.\n\nIf the statement fails for any reason a warning log will be emitted but the operation of this component will not be stopped.\n",
          "required": false,
          "default": null,
          "examples": [
            "\nCREATE TABLE IF NOT EXISTS some_table (\n  foo varchar(50) not null,\n  bar integer,\n  baz varchar(50),\n  primary key (foo)\n) WITHOUT ROWID;\n"
          ],
          "advanced": true
        },
        "queries": {
          "name": "queries",
          "type": "object",
          "kind": "array",
          "description": "A list of statements to run in addition to `query`. When specifying multiple statements, they are all executed within a transaction. The output of the processor is always the last query that runs, unless `exec_only` is used.",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "query",
              "type": "string",
              "kind": "scalar",
              "description": "The query to execute. The style of placeholder to use depends on the driver, some drivers require question marks (`?`) whereas others expect incrementing dollar signs (`$1`, `$2`, and so on) or colons (`:1`, `:2` and so on). The style to use is outlined in this table:\n\n| Driver | Placeholder Style |\n|---|---|\n| `clickhouse` | Dollar sign |\n| `mysql` | Question mark |\n| `postgres` | Dollar sign |\n| `mssql` | Question mark |\n| `sqlite` | Question mark |\n| `oracle` | Colon |\n| `snowflake` | Question mark |\n| `trino` | Question mark |\n| `gocosmos` | Colon |\n",
              "required": true,
              "default": null
            },
            {
              "name": "args_mapping",
              "type": "string",
              "kind": "scalar",
              "description": "An optional xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to an array of values matching in size to the number of placeholder arguments in the field `query`.",
              "required": false,
              "default": null,
              "examples": [
                "root = [ this.cat.meow, this.doc.woofs[0] ]",
                "root = [ meta(\"user.id\") ]"
              ]
            },
            {
              "name": "exec_only",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether the query result should be discarded. When set to `true` the message contents will remain unchanged, which is useful in cases where you are executing inserts, updates, etc. By default this is true for the last query, and previous queries don't change the results. If set to true for any query but the last one, the subsequent `args_mappings` input is overwritten.",
              "required": false,
              "default": null
            }
          ]
        },
        "query": {
          "name": "query",
          "type": "string",
          "kind": "scalar",
          "description": "The query to execute. The style of placeholder to use depends on the driver, some drivers require question marks (`?`) whereas others expect incrementing dollar signs (`$1`, `$2`, and so on) or colons (`:1`, `:2` and so on). The style to use is outlined in this table:\n\n| Driver | Placeholder Style |\n|---|---|\n| `clickhouse` | Dollar sign |\n| `mysql` | Question mark |\n| `postgres` | Dollar sign |\n| `mssql` | Question mark |\n| `sqlite` | Question mark |\n| `oracle` | Colon |\n| `snowflake` | Question mark |\n| `trino` | Question mark |\n| `gocosmos` | Colon |\n",
          "required": false,
          "default": null,
          "examples": [
            "INSERT INTO footable (foo, bar, baz) VALUES (?, ?, ?);",
            "SELECT * FROM footable WHERE user_id = $1;"
          ]
        },
        "unsafe_dynamic_query": {
          "name": "unsafe_dynamic_query",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to enable xref:configuration:interpolation.adoc#bloblang-queries[interpolation functions] in the query. Great care should be made to ensure your queries are defended against injection attacks.",
          "required": true,
          "default": false,
          "advanced": true
        }
      }
    },
    "sql_select": {
      "name": "sql_select",
      "type": "processor",
      "source": "upstream",
      "summary": "Runs an SQL select query against a database and returns the result as an array of objects, one for each row returned, containing a key for each column queried and its value.",
      "description": "\nIf the query fails to execute then the message will remain unchanged and the error can be caught using xref:configuration:error_handling.adoc[error handling methods].",
      "config": {
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to an array of values matching in size to the number of placeholder arguments in the field `where`.",
          "required": false,
          "default": null,
          "examples": [
            "root = [ this.cat.meow, this.doc.woofs[0] ]",
            "root = [ meta(\"user.id\") ]"
          ]
        },
        "columns": {
          "name": "columns",
          "type": "string",
          "kind": "array",
          "description": "A list of columns to query.",
          "required": true,
          "default": null,
          "examples": [
            [
              "*"
            ],
            [
              "foo",
              "bar",
              "baz"
            ]
          ]
        },
        "conn_max_idle": {
          "name": "conn_max_idle",
          "type": "int",
          "kind": "scalar",
          "description": "An optional maximum number of connections in the idle connection pool. If conn_max_open is greater than 0 but less than the new conn_max_idle, then the new conn_max_idle will be reduced to match the conn_max_open limit. If `value \u003c= 0`, no idle connections are retained. The default max idle connections is currently 2. This may change in a future release.",
          "required": false,
          "default": 2,
          "advanced": true
        },
        "conn_max_idle_time": {
          "name": "conn_max_idle_time",
          "type": "string",
          "kind": "scalar",
          "description": "An optional maximum amount of time a connection may be idle. Expired connections may be closed lazily before reuse. If `value \u003c= 0`, connections are not closed due to a connections idle time.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "conn_max_life_time": {
          "name": "conn_max_life_time",
          "type": "string",
          "kind": "scalar",
          "description": "An optional maximum amount of time a connection may be reused. Expired connections may be closed lazily before reuse. If `value \u003c= 0`, connections are not closed due to a connections age.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "conn_max_open": {
          "name": "conn_max_open",
          "type": "int",
          "kind": "scalar",
          "description": "An optional maximum number of open connections to the database. If conn_max_idle is greater than 0 and the new conn_max_open is less than conn_max_idle, then conn_max_idle will be reduced to match the new conn_max_open limit. If `value \u003c= 0`, then there is no limit on the number of open connections. The default is 0 (unlimited).",
          "required": false,
          "default": null,
          "advanced": true
        },
        "driver": {
          "name": "driver",
          "type": "string",
          "kind": "scalar",
          "description": "A database \u003c\u003cdrivers, driver\u003e\u003e to use.",
          "required": true,
          "default": null,
          "options": [
            "mysql",
            "postgres",
            "clickhouse",
            "mssql",
            "sqlite",
            "oracle",
            "snowflake",
            "trino",
            "gocosmos",
            "spanner"
          ]
        },
        "dsn": {
          "name": "dsn",
          "type": "string",
          "kind": "scalar",
          "description": "A Data Source Name to identify the target database.\n\n==== Drivers\n\n:driver-support: mysql=certified, postgres=certified, clickhouse=community, mssql=community, sqlite=certified, oracle=certified, snowflake=community, trino=community, gocosmos=community, spanner=community\n\nThe following is a list of supported drivers, their placeholder style, and their respective DSN formats:\n\n|===\n| Driver | Data Source Name Format\n\n| `clickhouse` \n| https://github.com/ClickHouse/clickhouse-go#dsn[`clickhouse://[username[:password\\]@\\][netloc\\][:port\\]/dbname[?param1=value1\u0026...\u0026paramN=valueN\\]`^] \n\n| `mysql` \n| `[username[:password]@][protocol[(address)]]/dbname[?param1=value1\u0026...\u0026paramN=valueN]` \n\n| `postgres` \n| `postgres://[user[:password]@][netloc][:port][/dbname][?param1=value1\u0026...]` \n\n| `mssql` \n| `sqlserver://[user[:password]@][netloc][:port][?database=dbname\u0026param1=value1\u0026...]` \n\n| `sqlite` \n| `file:/path/to/filename.db[?param\u0026=value1\u0026...]` \n\n| `oracle` \n| `oracle://[username[:password]@][netloc][:port]/service_name?server=server2\u0026server=server3` \n\n| `snowflake` \n| `username[:password]@account_identifier/dbname/schemaname[?param1=value\u0026...\u0026paramN=valueN]` \n\n| `trino` \n| https://github.com/trinodb/trino-go-client#dsn-data-source-name[`http[s\\]://user[:pass\\]@host[:port\\][?parameters\\]`^] \n\n| `gocosmos` \n| https://pkg.go.dev/github.com/microsoft/gocosmos#readme-example-usage[`AccountEndpoint=\u003ccosmosdb-endpoint\u003e;AccountKey=\u003ccosmosdb-account-key\u003e[;TimeoutMs=\u003ctimeout-in-ms\u003e\\][;Version=\u003ccosmosdb-api-version\u003e\\][;DefaultDb/Db=\u003cdb-name\u003e\\][;AutoId=\u003ctrue/false\u003e\\][;InsecureSkipVerify=\u003ctrue/false\u003e\\]`^] \n\n| `spanner` \n| projects/[PROJECT]/instances/[INSTANCE]/databases/[DATABASE] \n|===\n\nPlease note that the `postgres` driver enforces SSL by default, you can override this with the parameter `sslmode=disable` if required.\n\nThe `snowflake` driver supports multiple DSN formats. Please consult https://pkg.go.dev/github.com/snowflakedb/gosnowflake#hdr-Connection_String[the docs^] for more details. For https://docs.snowflake.com/en/user-guide/key-pair-auth.html#configuring-key-pair-authentication[key pair authentication^], the DSN has the following format: `\u003csnowflake_user\u003e@\u003csnowflake_account\u003e/\u003cdb_name\u003e/\u003cschema_name\u003e?warehouse=\u003cwarehouse\u003e\u0026role=\u003crole\u003e\u0026authenticator=snowflake_jwt\u0026privateKey=\u003cbase64_url_encoded_private_key\u003e`, where the value for the `privateKey` parameter can be constructed from an unencrypted RSA private key file `rsa_key.p8` using `openssl enc -d -base64 -in rsa_key.p8 | basenc --base64url -w0` (you can use `gbasenc` insted of `basenc` on OSX if you install `coreutils` via Homebrew). If you have a password-encrypted private key, you can decrypt it using `openssl pkcs8 -in rsa_key_encrypted.p8 -out rsa_key.p8`. Also, make sure fields such as the username are URL-encoded.\n\nThe https://pkg.go.dev/github.com/microsoft/gocosmos[`gocosmos`^] driver is still experimental, but it has support for https://learn.microsoft.com/en-us/azure/cosmos-db/hierarchical-partition-keys[hierarchical partition keys^] as well as https://learn.microsoft.com/en-us/azure/cosmos-db/nosql/how-to-query-container#cross-partition-query[cross-partition queries^]. Please refer to the https://github.com/microsoft/gocosmos/blob/main/SQL.md[SQL notes^] for details.",
          "required": true,
          "default": null,
          "examples": [
            "clickhouse://username:password@host1:9000,host2:9000/database?dial_timeout=200ms\u0026max_execution_time=60",
            "foouser:foopassword@tcp(localhost:3306)/foodb",
            "postgres://foouser:foopass@localhost:5432/foodb?sslmode=disable",
            "oracle://foouser:foopass@localhost:1521/service_name"
          ]
        },
        "init_files": {
          "name": "init_files",
          "type": "string",
          "kind": "array",
          "description": "\nAn optional list of file paths containing SQL statements to execute immediately upon the first connection to the target database. This is a useful way to initialise tables before processing data. Glob patterns are supported, including super globs (double star).\n\nCare should be taken to ensure that the statements are idempotent, and therefore would not cause issues when run multiple times after service restarts. If both `init_statement` and `init_files` are specified the `init_statement` is executed _after_ the `init_files`.\n\nIf a statement fails for any reason a warning log will be emitted but the operation of this component will not be stopped.\n",
          "required": false,
          "default": null,
          "examples": [
            [
              "./init/*.sql"
            ],
            [
              "./foo.sql",
              "./bar.sql"
            ]
          ],
          "advanced": true
        },
        "init_statement": {
          "name": "init_statement",
          "type": "string",
          "kind": "scalar",
          "description": "\nAn optional SQL statement to execute immediately upon the first connection to the target database. This is a useful way to initialise tables before processing data. Care should be taken to ensure that the statement is idempotent, and therefore would not cause issues when run multiple times after service restarts.\n\nIf both `init_statement` and `init_files` are specified the `init_statement` is executed _after_ the `init_files`.\n\nIf the statement fails for any reason a warning log will be emitted but the operation of this component will not be stopped.\n",
          "required": false,
          "default": null,
          "examples": [
            "\nCREATE TABLE IF NOT EXISTS some_table (\n  foo varchar(50) not null,\n  bar integer,\n  baz varchar(50),\n  primary key (foo)\n) WITHOUT ROWID;\n"
          ],
          "advanced": true
        },
        "prefix": {
          "name": "prefix",
          "type": "string",
          "kind": "scalar",
          "description": "An optional prefix to prepend to the query (before SELECT).",
          "required": false,
          "default": null,
          "advanced": true
        },
        "suffix": {
          "name": "suffix",
          "type": "string",
          "kind": "scalar",
          "description": "An optional suffix to append to the select query.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "table": {
          "name": "table",
          "type": "string",
          "kind": "scalar",
          "description": "The table to query.",
          "required": true,
          "default": null,
          "examples": [
            "foo"
          ]
        },
        "where": {
          "name": "where",
          "type": "string",
          "kind": "scalar",
          "description": "An optional where clause to add. Placeholder arguments are populated with the `args_mapping` field. Placeholders should always be question marks, and will automatically be converted to dollar syntax when the postgres or clickhouse drivers are used.",
          "required": false,
          "default": null,
          "examples": [
            "meow = ? and woof = ?",
            "user_id = ?"
          ]
        }
      }
    },
    "stream_processor": {
      "name": "stream_processor",
      "type": "processor",
      "source": "benthos-umh",
      "summary": "A processor for collecting timeseries data from multiple UNS sources and generating transformed messages",
      "description": "The stream_processor is a specialized Benthos processor designed to collect timeseries data from multiple UNS sources,\nmaintain state for variable mappings, and generate transformed messages using JavaScript expressions. It operates exclusively with UNS input/output.\n\nThe processor implements dependency-based evaluation:\n- Static mappings (no variable dependencies) are evaluated on every incoming message\n- Dynamic mappings are only evaluated when their dependent variables are received\n\nConfiguration structure:\n- mode: Processing mode (currently only \"timeseries\" is supported)\n- model: Model name and version for data contract generation\n- output_topic: Base topic for output messages\n- sources: Map of variable aliases to UNS topic paths\n- mapping: JavaScript expressions for field transformations\n\nOutput topics are constructed as: \u003coutput_topic\u003e.\u003cdata_contract\u003e.\u003cvirtual_path\u003e\nWhere data_contract is \"_\u003cmodel_name\u003e_\u003cmodel_version\u003e\" and virtual_path is the mapping field path.",
      "config": {
        "mapping": {
          "name": "mapping",
          "type": "object",
          "kind": "scalar",
          "description": "JavaScript expressions for field transformations",
          "required": false,
          "default": null
        },
        "mode": {
          "name": "mode",
          "type": "string",
          "kind": "scalar",
          "description": "Processing mode",
          "required": true,
          "default": "timeseries"
        },
        "model": {
          "name": "model",
          "type": "object",
          "kind": "scalar",
          "description": "Model configuration for data contract",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "name",
              "type": "string",
              "kind": "scalar",
              "description": "Model name for data contract generation",
              "required": true,
              "default": null
            },
            {
              "name": "version",
              "type": "string",
              "kind": "scalar",
              "description": "Model version for data contract generation",
              "required": true,
              "default": null
            }
          ]
        },
        "output_topic": {
          "name": "output_topic",
          "type": "string",
          "kind": "scalar",
          "description": "Base topic for output messages",
          "required": true,
          "default": null
        },
        "sources": {
          "name": "sources",
          "type": "string",
          "kind": "map",
          "description": "Map of variable aliases to UNS topic paths",
          "required": true,
          "default": null
        }
      }
    },
    "subprocess": {
      "name": "subprocess",
      "type": "processor",
      "source": "upstream",
      "summary": "Executes a command as a subprocess and, for each message, will pipe its contents to the stdin stream of the process followed by a newline.",
      "description": "\n[NOTE]\n====\nThis processor keeps the subprocess alive and requires very specific behavior from the command executed. If you wish to simply execute a command for each message take a look at the xref:components:processors/command.adoc[`command` processor] instead.\n====\n\nThe subprocess must then either return a line over stdout or stderr. If a response is returned over stdout then its contents will replace the message. If a response is instead returned from stderr it will be logged and the message will continue unchanged and will be xref:configuration:error_handling.adoc[marked as failed].\n\nRather than separating data by a newline it's possible to specify alternative \u003c\u003ccodec_send,`codec_send`\u003e\u003e and \u003c\u003ccodec_recv,`codec_recv`\u003e\u003e values, which allow binary messages to be encoded for logical separation.\n\nThe execution environment of the subprocess is the same as the Redpanda Connect instance, including environment variables and the current working directory.\n\nThe field `max_buffer` defines the maximum response size able to be read from the subprocess. This value should be set significantly above the real expected maximum response size.\n\n== Subprocess requirements\n\nIt is required that subprocesses flush their stdout and stderr pipes for each line. Redpanda Connect will attempt to keep the process alive for as long as the pipeline is running. If the process exits early it will be restarted.\n\n== Messages containing line breaks\n\nIf a message contains line breaks each line of the message is piped to the subprocess and flushed, and a response is expected from the subprocess before another line is fed in.",
      "config": {
        "args": {
          "name": "args",
          "type": "string",
          "kind": "array",
          "description": "A list of arguments to provide the command.",
          "required": true,
          "default": []
        },
        "codec_recv": {
          "name": "codec_recv",
          "type": "string",
          "kind": "scalar",
          "description": "Determines how messages read from the subprocess are decoded, which allows them to be logically separated.",
          "required": true,
          "default": "lines",
          "options": [
            "lines",
            "length_prefixed_uint32_be",
            "netstring"
          ],
          "advanced": true
        },
        "codec_send": {
          "name": "codec_send",
          "type": "string",
          "kind": "scalar",
          "description": "Determines how messages written to the subprocess are encoded, which allows them to be logically separated.",
          "required": true,
          "default": "lines",
          "options": [
            "lines",
            "length_prefixed_uint32_be",
            "netstring"
          ],
          "advanced": true
        },
        "max_buffer": {
          "name": "max_buffer",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum expected response size.",
          "required": true,
          "default": 65536,
          "advanced": true
        },
        "name": {
          "name": "name",
          "type": "string",
          "kind": "scalar",
          "description": "The command to execute as a subprocess.",
          "required": true,
          "default": null,
          "examples": [
            "cat",
            "sed",
            "awk"
          ]
        }
      }
    },
    "switch": {
      "name": "switch",
      "type": "processor",
      "source": "upstream",
      "summary": "Conditionally processes messages based on their contents.",
      "description": "For each switch case a xref:guides:bloblang/about.adoc[Bloblang query] is checked and, if the result is true (or the check is empty) the child processors are executed on the message.",
      "config": {
        "check": {
          "name": "check",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should have the processors of this case executed on it. If left empty the case always passes. If the check mapping throws an error the message will be flagged xref:configuration:error_handling.adoc[as having failed] and will not be tested against any other cases.",
          "required": true,
          "default": "",
          "examples": [
            "this.type == \"foo\"",
            "this.contents.urls.contains(\"https://benthos.dev/\")"
          ]
        },
        "fallthrough": {
          "name": "fallthrough",
          "type": "bool",
          "kind": "scalar",
          "description": "Indicates whether, if this case passes for a message, the next case should also be executed.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "processors": {
          "name": "processors",
          "type": "processor",
          "kind": "array",
          "description": "A list of xref:components:processors/about.adoc[processors] to execute on a message.",
          "required": true,
          "default": []
        }
      }
    },
    "sync_response": {
      "name": "sync_response",
      "type": "processor",
      "source": "upstream",
      "summary": "Adds the payload in its current state as a synchronous response to the input source, where it is dealt with according to that specific input type.",
      "description": "\nFor most inputs this mechanism is ignored entirely, in which case the sync response is dropped without penalty. It is therefore safe to use this processor even when combining input types that might not have support for sync responses. An example of an input able to utilize this is the `http_server`.\n\nFor more information please read xref:guides:sync_responses.adoc[synchronous responses].",
      "config": {}
    },
    "tag_processor": {
      "name": "tag_processor",
      "type": "processor",
      "source": "benthos-umh",
      "summary": "A processor for standardizing tag metadata and topics",
      "description": "The tagProcessor sets up a canonical metadata structure for constructing standardized topic and payload schemas.\nIt applies defaults, conditional transformations, and optional advanced processing using a Node-RED style JavaScript environment.\n\nRequired metadata fields:\n- location_path: Hierarchical location path in dot notation (e.g., \"enterprise.site.area.line.workcell.plc123\")\n- data_contract: Data schema identifier (e.g., \"_historian\", \"_analytics\")\n- tag_name: Name of the tag/variable (e.g., \"temperature\")\n\nOptional metadata fields:\n- virtual_path: Logical, non-physical grouping path in dot notation (e.g., \"axis.x.position\")\n\nThe final topic will be constructed as:\numh.v1.\u003clocation_path\u003e.\u003cdata_contract\u003e.\u003cvirtual_path\u003e.\u003ctag_name\u003e\n\nEmpty or undefined fields will be omitted from the topic.",
      "config": {
        "advancedProcessing": {
          "name": "advancedProcessing",
          "type": "string",
          "kind": "scalar",
          "description": "Optional JavaScript code for advanced message processing",
          "required": false,
          "default": ""
        },
        "conditions": {
          "name": "conditions",
          "type": "object",
          "kind": "array",
          "description": "List of conditions to evaluate",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "if",
              "type": "string",
              "kind": "scalar",
              "description": "JavaScript condition expression",
              "required": true,
              "default": null
            },
            {
              "name": "then",
              "type": "string",
              "kind": "scalar",
              "description": "JavaScript code to execute if condition is true",
              "required": true,
              "default": null
            }
          ]
        },
        "defaults": {
          "name": "defaults",
          "type": "string",
          "kind": "scalar",
          "description": "JavaScript code to set initial metadata values",
          "required": true,
          "default": ""
        }
      }
    },
    "topic_browser": {
      "name": "topic_browser",
      "type": "processor",
      "source": "benthos-umh",
      "summary": "",
      "description": "The topic browser processor processes messages into UNS bundles for the topic browser.\n\nThe processor will read the message headers and body to extract the UNS information and event table entries.\n\nThe processor will then return a message with the UNS bundle as the body, encoded as a protobuf.\n\nThe processor requires that the following metadata fields are set:\n\n- topic: The topic of the message.\n",
      "config": {
        "emit_interval": {
          "name": "emit_interval",
          "type": "string",
          "kind": "scalar",
          "description": "Maximum time to buffer messages before emission",
          "required": true,
          "default": "1s",
          "advanced": true
        },
        "lru_size": {
          "name": "lru_size",
          "type": "int",
          "kind": "scalar",
          "description": "The size of the LRU cache used to deduplicate topic names and store topic information.",
          "required": true,
          "default": 50000,
          "advanced": true
        },
        "max_buffer_size": {
          "name": "max_buffer_size",
          "type": "int",
          "kind": "scalar",
          "description": "Maximum number of messages to buffer (safety limit)",
          "required": true,
          "default": 10000,
          "advanced": true
        },
        "max_events_per_topic_per_interval": {
          "name": "max_events_per_topic_per_interval",
          "type": "int",
          "kind": "scalar",
          "description": "Maximum events per topic per emit interval",
          "required": true,
          "default": 1,
          "advanced": true
        }
      }
    },
    "try": {
      "name": "try",
      "type": "processor",
      "source": "upstream",
      "summary": "Executes a list of child processors on messages only if no prior processors have failed (or the errors have been cleared).",
      "description": "\nThis processor behaves similarly to the xref:components:processors/for_each.adoc[`for_each`] processor, where a list of child processors are applied to individual messages of a batch. However, if a message has failed any prior processor (before or during the try block) then that message will skip all following processors.\n\nFor example, with the following config:\n\n```yaml\npipeline:\n  processors:\n    - resource: foo\n    - try:\n      - resource: bar\n      - resource: baz\n      - resource: buz\n```\n\nIf the processor `bar` fails for a particular message, that message will skip the processors `baz` and `buz`. Similarly, if `bar` succeeds but `baz` does not then `buz` will be skipped. If the processor `foo` fails for a message then none of `bar`, `baz` or `buz` are executed on that message.\n\nThis processor is useful for when child processors depend on the successful output of previous processors. This processor can be followed with a xref:components:processors/catch.adoc[catch] processor for defining child processors to be applied only to failed messages.\n\nMore information about error handing can be found in xref:configuration:error_handling.adoc[].\n\n== Nest within a catch block\n\nIn some cases it might be useful to nest a try block within a catch block, since the xref:components:processors/catch.adoc[`catch` processor] only clears errors _after_ executing its child processors this means a nested try processor will not execute unless the errors are explicitly cleared beforehand.\n\nThis can be done by inserting an empty catch block before the try block like as follows:\n\n```yaml\npipeline:\n  processors:\n    - resource: foo\n    - catch:\n      - log:\n          level: ERROR\n          message: \"Foo failed due to: ${! error() }\"\n      - catch: [] # Clear prior error\n      - try:\n        - resource: bar\n        - resource: baz\n```",
      "config": {}
    },
    "unarchive": {
      "name": "unarchive",
      "type": "processor",
      "source": "upstream",
      "summary": "Unarchives messages according to the selected archive format into multiple messages within a xref:configuration:batching.adoc[batch].",
      "description": "\nWhen a message is unarchived the new messages replace the original message in the batch. Messages that are selected but fail to unarchive (invalid format) will remain unchanged in the message batch but will be flagged as having failed, allowing you to xref:configuration:error_handling.adoc[error handle them].\n\n== Metadata\n\nThe metadata found on the messages handled by this processor will be copied into the resulting messages. For the unarchive formats that contain file information (tar, zip), a metadata field is also added to each message called `archive_filename` with the extracted filename.\n",
      "config": {
        "format": {
          "name": "format",
          "type": "string",
          "kind": "scalar",
          "description": "The unarchiving format to apply.",
          "required": true,
          "default": null
        }
      }
    },
    "wasm": {
      "name": "wasm",
      "type": "processor",
      "source": "upstream",
      "summary": "Executes a function exported by a WASM module for each message.",
      "description": "\nThis processor uses https://github.com/tetratelabs/wazero[Wazero^] to execute a WASM module (with support for WASI), calling a specific function for each message being processed. From within the WASM module it is possible to query and mutate the message being processed via a suite of functions exported to the module.\n\nThis ecosystem is delicate as WASM doesn't have a single clearly defined way to pass strings back and forth between the host and the module. In order to remedy this we're gradually working on introducing libraries and examples for multiple languages which can be found in https://github.com/redpanda-data/benthos/tree/main/public/wasm/README.md[the codebase^].\n\nThese examples, as well as the processor itself, is a work in progress.\n\n== Parallelism\n\nIt's not currently possible to execute a single WASM runtime across parallel threads with this processor. Therefore, in order to support parallel processing this processor implements pooling of module runtimes. Ideally your WASM module shouldn't depend on any global state, but if it does then you need to ensure the processor xref:configuration:processing_pipelines.adoc[is only run on a single thread].\n",
      "config": {
        "function": {
          "name": "function",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the function exported by the target WASM module to run for each message.",
          "required": true,
          "default": "process"
        },
        "module_path": {
          "name": "module_path",
          "type": "string",
          "kind": "scalar",
          "description": "The path of the target WASM module to execute.",
          "required": true,
          "default": null
        }
      }
    },
    "while": {
      "name": "while",
      "type": "processor",
      "source": "upstream",
      "summary": "A processor that checks a xref:guides:bloblang/about.adoc[Bloblang query] against each batch of messages and executes child processors on them for as long as the query resolves to true.",
      "description": "\nThe field `at_least_once`, if true, ensures that the child processors are always executed at least one time (like a do .. while loop.)\n\nThe field `max_loops`, if greater than zero, caps the number of loops for a message batch to this value.\n\nIf following a loop execution the number of messages in a batch is reduced to zero the loop is exited regardless of the condition result. If following a loop execution there are more than 1 message batches the query is checked against the first batch only.\n\nThe conditions of this processor are applied across entire message batches. You can find out more about batching xref:configuration:batching.adoc[in this doc].",
      "config": {
        "at_least_once": {
          "name": "at_least_once",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to always run the child processors at least one time.",
          "required": true,
          "default": false
        },
        "check": {
          "name": "check",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether the while loop should execute again.",
          "required": true,
          "default": "",
          "examples": [
            "errored()",
            "this.urls.unprocessed.length() \u003e 0"
          ]
        },
        "max_loops": {
          "name": "max_loops",
          "type": "int",
          "kind": "scalar",
          "description": "An optional maximum number of loops to execute. Helps protect against accidentally creating infinite loops.",
          "required": true,
          "default": 0,
          "advanced": true
        },
        "processors": {
          "name": "processors",
          "type": "processor",
          "kind": "array",
          "description": "A list of child processors to execute on each loop.",
          "required": true,
          "default": null
        }
      }
    },
    "workflow": {
      "name": "workflow",
      "type": "processor",
      "source": "upstream",
      "summary": "Executes a topology of xref:components:processors/branch.adoc[`branch` processors], performing them in parallel where possible.",
      "description": "\n== Why use a workflow\n\n=== Performance\n\nMost of the time the best way to compose processors is also the simplest, just configure them in series. This is because processors are often CPU bound, low-latency, and you can gain vertical scaling by increasing the number of processor pipeline threads, allowing Redpanda Connect to process xref:configuration:processing_pipelines.adoc[multiple messages in parallel].\n\nHowever, some processors such as xref:components:processors/http.adoc[`http`], xref:components:processors/aws_lambda.adoc[`aws_lambda`] or xref:components:processors/cache.adoc[`cache`] interact with external services and therefore spend most of their time waiting for a response. These processors tend to be high-latency and low CPU activity, which causes messages to process slowly.\n\nWhen a processing pipeline contains multiple network processors that aren't dependent on each other we can benefit from performing these processors in parallel for each individual message, reducing the overall message processing latency.\n\n=== Simplifying processor topology\n\nA workflow is often expressed as a https://en.wikipedia.org/wiki/Directed_acyclic_graph[DAG^] of processing stages, where each stage can result in N possible next stages, until finally the flow ends at an exit node.\n\nFor example, if we had processing stages A, B, C and D, where stage A could result in either stage B or C being next, always followed by D, it might look something like this:\n\n```text\n     /--\u003e B --\\\nA --|          |--\u003e D\n     \\--\u003e C --/\n```\n\nThis flow would be easy to express in a standard Redpanda Connect config, we could simply use a xref:components:processors/switch.adoc[`switch` processor] to route to either B or C depending on a condition on the result of A. However, this method of flow control quickly becomes unfeasible as the DAG gets more complicated, imagine expressing this flow using switch processors:\n\n```text\n      /--\u003e B -------------|--\u003e D\n     /                   /\nA --|          /--\u003e E --|\n     \\--\u003e C --|          \\\n               \\----------|--\u003e F\n```\n\nAnd imagine doing so knowing that the diagram is subject to change over time. Yikes! Instead, with a workflow we can either trust it to automatically resolve the DAG or express it manually as simply as `order: [ [ A ], [ B, C ], [ E ], [ D, F ] ]`, and the conditional logic for determining if a stage is executed is defined as part of the branch itself.",
      "config": {
        "branch_resources": {
          "name": "branch_resources",
          "type": "string",
          "kind": "array",
          "description": "An optional list of xref:components:processors/branch.adoc[`branch` processor] names that are configured as \u003c\u003cresources\u003e\u003e. These resources will be included in the workflow with any branches configured inline within the \u003c\u003cbranches, `branches`\u003e\u003e field. The order and parallelism in which branches are executed is automatically resolved based on the mappings of each branch. When using resources with an explicit order it is not necessary to list resources in this field.",
          "required": true,
          "default": [],
          "advanced": true
        },
        "branches": {
          "name": "branches",
          "type": "object",
          "kind": "map",
          "description": "An object of named xref:components:processors/branch.adoc[`branch` processors] that make up the workflow. The order and parallelism in which branches are executed can either be made explicit with the field `order`, or if omitted an attempt is made to automatically resolve an ordering based on the mappings of each branch.",
          "required": true,
          "default": {},
          "children": [
            {
              "name": "request_map",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] that describes how to create a request payload suitable for the child processors of this branch. If left empty then the branch will begin with an exact copy of the origin message (including metadata).",
              "required": true,
              "default": "",
              "examples": [
                "root = {\n\t\"id\": this.doc.id,\n\t\"content\": this.doc.body.text\n}",
                "root = if this.type == \"foo\" {\n\tthis.foo.request\n} else {\n\tdeleted()\n}"
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of processors to apply to mapped requests. When processing message batches the resulting batch must match the size and ordering of the input batch, therefore filtering, grouping should not be performed within these processors.",
              "required": true,
              "default": null
            },
            {
              "name": "result_map",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] that describes how the resulting messages from branched processing should be mapped back into the original payload. If left empty the origin message will remain unchanged (including metadata).",
              "required": true,
              "default": "",
              "examples": [
                "meta foo_code = metadata(\"code\")\nroot.foo_result = this",
                "meta = metadata()\nroot.bar.body = this.body\nroot.bar.id = this.user.id",
                "root.raw_result = content().string()",
                "root.enrichments.foo = if metadata(\"request_failed\") != null {\n  throw(metadata(\"request_failed\"))\n} else {\n  this\n}",
                "# Retain only the updated metadata fields which were present in the origin message\nmeta = metadata().filter(v -\u003e @.get(v.key) != null)"
              ]
            }
          ]
        },
        "meta_path": {
          "name": "meta_path",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:configuration:field_paths.adoc[dot path] indicating where to store and reference \u003c\u003cstructured-metadata, structured metadata\u003e\u003e about the workflow execution.",
          "required": true,
          "default": "meta.workflow"
        },
        "order": {
          "name": "order",
          "type": "string",
          "kind": "2darray",
          "description": "An explicit declaration of branch ordered tiers, which describes the order in which parallel tiers of branches should be executed. Branches should be identified by the name as they are configured in the field `branches`. It's also possible to specify branch processors configured \u003c\u003cresources, as a resource\u003e\u003e.",
          "required": true,
          "default": [],
          "examples": [
            [
              [
                "foo",
                "bar"
              ],
              [
                "baz"
              ]
            ],
            [
              [
                "foo"
              ],
              [
                "bar"
              ],
              [
                "baz"
              ]
            ]
          ]
        }
      }
    },
    "xml": {
      "name": "xml",
      "type": "processor",
      "source": "upstream",
      "summary": "Parses messages as an XML document, performs a mutation on the data, and then overwrites the previous contents with the new value.",
      "description": "\n== Operators\n\n=== `to_json`\n\nConverts an XML document into a JSON structure, where elements appear as keys of an object according to the following rules:\n\n- If an element contains attributes they are parsed by prefixing a hyphen, `-`, to the attribute label.\n- If the element is a simple element and has attributes, the element value is given the key `#text`.\n- XML comments, directives, and process instructions are ignored.\n- When elements are repeated the resulting JSON value is an array.\n\nFor example, given the following XML:\n\n```xml\n\u003croot\u003e\n  \u003ctitle\u003eThis is a title\u003c/title\u003e\n  \u003cdescription tone=\"boring\"\u003eThis is a description\u003c/description\u003e\n  \u003celements id=\"1\"\u003efoo1\u003c/elements\u003e\n  \u003celements id=\"2\"\u003efoo2\u003c/elements\u003e\n  \u003celements\u003efoo3\u003c/elements\u003e\n\u003c/root\u003e\n```\n\nThe resulting JSON structure would look like this:\n\n```json\n{\n  \"root\":{\n    \"title\":\"This is a title\",\n    \"description\":{\n      \"#text\":\"This is a description\",\n      \"-tone\":\"boring\"\n    },\n    \"elements\":[\n      {\"#text\":\"foo1\",\"-id\":\"1\"},\n      {\"#text\":\"foo2\",\"-id\":\"2\"},\n      \"foo3\"\n    ]\n  }\n}\n```\n\nWith cast set to true, the resulting JSON structure would look like this:\n\n```json\n{\n  \"root\":{\n    \"title\":\"This is a title\",\n    \"description\":{\n      \"#text\":\"This is a description\",\n      \"-tone\":\"boring\"\n    },\n    \"elements\":[\n      {\"#text\":\"foo1\",\"-id\":1},\n      {\"#text\":\"foo2\",\"-id\":2},\n      \"foo3\"\n    ]\n  }\n}\n```",
      "config": {
        "cast": {
          "name": "cast",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to try to cast values that are numbers and booleans to the right type. Default: all values are strings.",
          "required": true,
          "default": false
        },
        "operator": {
          "name": "operator",
          "type": "string",
          "kind": "scalar",
          "description": "An XML \u003c\u003coperators, operation\u003e\u003e to apply to messages.",
          "required": true,
          "default": "",
          "options": [
            "to_json"
          ]
        }
      }
    }
  },
  "outputs": {
    "amqp_0_9": {
      "name": "amqp_0_9",
      "type": "output",
      "source": "upstream",
      "summary": "Sends messages to an AMQP (0.91) exchange. AMQP is a messaging protocol used by various message brokers, including RabbitMQ.Connects to an AMQP (0.91) queue. AMQP is a messaging protocol used by various message brokers, including RabbitMQ.",
      "description": "The metadata from each message are delivered as headers.\n\nIt's possible for this output type to create the target exchange by setting `exchange_declare.enabled` to `true`, if the exchange already exists then the declaration passively verifies that the settings match.\n\nTLS is automatic when connecting to an `amqps` URL, but custom settings can be enabled in the `tls` section.\n\nThe fields 'key', 'exchange' and 'type' can be dynamically set using xref:configuration:interpolation.adoc#bloblang-queries[function interpolations].",
      "config": {
        "app_id": {
          "name": "app_id",
          "type": "string",
          "kind": "scalar",
          "description": "Set the application ID of each message with a dynamic interpolated expression.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "content_encoding": {
          "name": "content_encoding",
          "type": "string",
          "kind": "scalar",
          "description": "The content encoding attribute to set for each message.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "content_type": {
          "name": "content_type",
          "type": "string",
          "kind": "scalar",
          "description": "The content type attribute to set for each message.",
          "required": true,
          "default": "application/octet-stream",
          "advanced": true
        },
        "correlation_id": {
          "name": "correlation_id",
          "type": "string",
          "kind": "scalar",
          "description": "Set the correlation ID of each message with a dynamic interpolated expression.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "exchange": {
          "name": "exchange",
          "type": "string",
          "kind": "scalar",
          "description": "An AMQP exchange to publish to.",
          "required": true,
          "default": null
        },
        "exchange_declare": {
          "name": "exchange_declare",
          "type": "object",
          "kind": "scalar",
          "description": "Optionally declare the target exchange (passive).",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to declare the exchange.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "type",
              "type": "string",
              "kind": "scalar",
              "description": "The type of the exchange.",
              "required": true,
              "default": "direct",
              "options": [
                "direct",
                "fanout",
                "topic",
                "x-custom"
              ],
              "advanced": true
            },
            {
              "name": "durable",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether the exchange should be durable.",
              "required": true,
              "default": true,
              "advanced": true
            },
            {
              "name": "arguments",
              "type": "string",
              "kind": "map",
              "description": "Optional arguments specific to the server's implementation of the exchange that can be sent for exchange types which require extra parameters.",
              "required": false,
              "default": null,
              "examples": [
                {
                  "alternate-exchange": "my-ae"
                }
              ],
              "advanced": true
            }
          ]
        },
        "expiration": {
          "name": "expiration",
          "type": "string",
          "kind": "scalar",
          "description": "Set the per-message TTL",
          "required": true,
          "default": "",
          "advanced": true
        },
        "immediate": {
          "name": "immediate",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to set the immediate flag on published messages. When set if there are no ready consumers of a queue then the message is dropped instead of waiting.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "The binding key to set for each message.",
          "required": true,
          "default": ""
        },
        "mandatory": {
          "name": "mandatory",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to set the mandatory flag on published messages. When set if a published message is routed to zero queues it is returned.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "message_id": {
          "name": "message_id",
          "type": "string",
          "kind": "scalar",
          "description": "Set the message ID of each message with a dynamic interpolated expression.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "metadata": {
          "name": "metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Specify criteria for which metadata values are attached to messages as headers.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "exclude_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to be excluded when adding metadata to sent messages.",
              "required": true,
              "default": []
            }
          ]
        },
        "persistent": {
          "name": "persistent",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether message delivery should be persistent (transient by default).",
          "required": true,
          "default": false,
          "advanced": true
        },
        "priority": {
          "name": "priority",
          "type": "string",
          "kind": "scalar",
          "description": "Set the priority of each message with a dynamic interpolated expression.",
          "required": true,
          "default": "",
          "examples": [
            "0",
            "${! meta(\"amqp_priority\") }",
            "${! json(\"doc.priority\") }"
          ],
          "advanced": true
        },
        "reply_to": {
          "name": "reply_to",
          "type": "string",
          "kind": "scalar",
          "description": "Carries response queue name - set with a dynamic interpolated expression.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum period to wait before abandoning it and reattempting. If not set, wait indefinitely.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "type": {
          "name": "type",
          "type": "string",
          "kind": "scalar",
          "description": "The type property to set for each message.",
          "required": true,
          "default": ""
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. The first URL to successfully establish a connection will be used until the connection is closed. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "amqp://guest:guest@127.0.0.1:5672/"
            ],
            [
              "amqp://127.0.0.1:5672/,amqp://127.0.0.2:5672/"
            ],
            [
              "amqp://127.0.0.1:5672/",
              "amqp://127.0.0.2:5672/"
            ]
          ]
        },
        "user_id": {
          "name": "user_id",
          "type": "string",
          "kind": "scalar",
          "description": "Set the user ID to the name of the publisher.  If this property is set by a publisher, its value must be equal to the name of the user used to open the connection.",
          "required": true,
          "default": "",
          "advanced": true
        }
      }
    },
    "amqp_1": {
      "name": "amqp_1",
      "type": "output",
      "source": "upstream",
      "summary": "Sends messages to an AMQP (1.0) server.",
      "description": "\n== Metadata\n\nMessage metadata is added to each AMQP message as string annotations. In order to control which metadata keys are added use the `metadata` config field.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.",
      "config": {
        "application_properties_map": {
          "name": "application_properties_map",
          "type": "string",
          "kind": "scalar",
          "description": "An optional Bloblang mapping that can be defined in order to set the `application-properties` on output messages.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "content_type": {
          "name": "content_type",
          "type": "string",
          "kind": "scalar",
          "description": "Specify the message body content type. The option `string` will transfer the message as an AMQP value of type string. Consider choosing the option `string` if your intention is to transfer UTF-8 string messages (like JSON messages) to the destination.",
          "required": true,
          "default": "opaque_binary",
          "options": [
            "opaque_binary",
            "string"
          ],
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "metadata": {
          "name": "metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Specify criteria for which metadata values are attached to messages as headers.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "exclude_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to be excluded when adding metadata to sent messages.",
              "required": true,
              "default": []
            }
          ]
        },
        "sasl": {
          "name": "sasl",
          "type": "object",
          "kind": "scalar",
          "description": "Enables SASL authentication.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "mechanism",
              "type": "string",
              "kind": "scalar",
              "description": "The SASL authentication mechanism to use.",
              "required": true,
              "default": "none",
              "advanced": true
            },
            {
              "name": "user",
              "type": "string",
              "kind": "scalar",
              "description": "A SASL plain text username. It is recommended that you use environment variables to populate this field.",
              "required": true,
              "default": "",
              "examples": [
                "${USER}"
              ],
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A SASL plain text password. It is recommended that you use environment variables to populate this field.",
              "required": true,
              "default": "",
              "examples": [
                "${PASSWORD}"
              ],
              "advanced": true
            }
          ]
        },
        "target_address": {
          "name": "target_address",
          "type": "string",
          "kind": "scalar",
          "description": "The target address to write to.",
          "required": true,
          "default": null,
          "examples": [
            "/foo",
            "queue:/bar",
            "topic:/baz"
          ]
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "A URL to connect to.",
          "required": false,
          "default": null,
          "examples": [
            "amqp://localhost:5672/",
            "amqps://guest:guest@localhost:5672/"
          ]
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. The first URL to successfully establish a connection will be used until the connection is closed. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": false,
          "default": null,
          "examples": [
            [
              "amqp://guest:guest@127.0.0.1:5672/"
            ],
            [
              "amqp://127.0.0.1:5672/,amqp://127.0.0.2:5672/"
            ],
            [
              "amqp://127.0.0.1:5672/",
              "amqp://127.0.0.2:5672/"
            ]
          ]
        }
      }
    },
    "aws_dynamodb": {
      "name": "aws_dynamodb",
      "type": "output",
      "source": "upstream",
      "summary": "Inserts items into a DynamoDB table.",
      "description": "\nThe field `string_columns` is a map of column names to string values, where the values are xref:configuration:interpolation.adoc#bloblang-queries[function interpolated] per message of a batch. This allows you to populate string columns of an item by extracting fields within the document payload or metadata like follows:\n\n```yml\nstring_columns:\n  id: ${!json(\"id\")}\n  title: ${!json(\"body.title\")}\n  topic: ${!meta(\"kafka_topic\")}\n  full_content: ${!content()}\n```\n\nThe field `json_map_columns` is a map of column names to json paths, where the xref:configuration:field_paths.adoc[dot path] is extracted from each document and converted into a map value. Both an empty path and the path `.` are interpreted as the root of the document. This allows you to populate map columns of an item like follows:\n\n```yml\njson_map_columns:\n  user: path.to.user\n  whole_document: .\n```\n\nA column name can be empty:\n\n```yml\njson_map_columns:\n  \"\": .\n```\n\nIn which case the top level document fields will be written at the root of the item, potentially overwriting previously defined column values. If a path is not found within a document the column will not be populated.\n\n== Credentials\n\nBy default Redpanda Connect will use a shared credentials file when connecting to AWS services. It's also possible to set them explicitly at the component level, allowing you to transfer data across accounts. You can find out more in xref:guides:cloud/aws.adoc[].\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].\n",
      "config": {
        "backoff": {
          "name": "backoff",
          "type": "object",
          "kind": "scalar",
          "description": "Control time intervals between retry attempts.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "initial_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The initial period to wait between retry attempts.",
              "required": true,
              "default": "1s",
              "advanced": true
            },
            {
              "name": "max_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait between retry attempts.",
              "required": true,
              "default": "5s",
              "advanced": true
            },
            {
              "name": "max_elapsed_time",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait before retry attempts are abandoned. If zero then no limit is used.",
              "required": true,
              "default": "30s",
              "advanced": true
            }
          ]
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "credentials": {
          "name": "credentials",
          "type": "object",
          "kind": "scalar",
          "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "profile",
              "type": "string",
              "kind": "scalar",
              "description": "A profile from `~/.aws/credentials` to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "id",
              "type": "string",
              "kind": "scalar",
              "description": "The ID of credentials to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "secret",
              "type": "string",
              "kind": "scalar",
              "description": "The secret for the credentials being used.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token",
              "type": "string",
              "kind": "scalar",
              "description": "The token for the credentials being used, required when using short term credentials.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "from_ec2_role",
              "type": "bool",
              "kind": "scalar",
              "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "role",
              "type": "string",
              "kind": "scalar",
              "description": "A role ARN to assume.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "role_external_id",
              "type": "string",
              "kind": "scalar",
              "description": "An external ID to provide when assuming a role.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "Allows you to specify a custom endpoint for the AWS API.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "json_map_columns": {
          "name": "json_map_columns",
          "type": "string",
          "kind": "map",
          "description": "A map of column keys to xref:configuration:field_paths.adoc[field paths] pointing to value data within messages.",
          "required": true,
          "default": {},
          "examples": [
            {
              "user": "path.to.user",
              "whole_document": "."
            },
            {
              "": "."
            }
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "max_retries": {
          "name": "max_retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retries before giving up on the request. If set to zero there is no discrete limit.",
          "required": true,
          "default": 3,
          "advanced": true
        },
        "region": {
          "name": "region",
          "type": "string",
          "kind": "scalar",
          "description": "The AWS region to target.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "string_columns": {
          "name": "string_columns",
          "type": "string",
          "kind": "map",
          "description": "A map of column keys to string values to store.",
          "required": true,
          "default": {},
          "examples": [
            {
              "full_content": "${!content()}",
              "id": "${!json(\"id\")}",
              "title": "${!json(\"body.title\")}",
              "topic": "${!meta(\"kafka_topic\")}"
            }
          ]
        },
        "table": {
          "name": "table",
          "type": "string",
          "kind": "scalar",
          "description": "The table to store messages in.",
          "required": true,
          "default": null
        },
        "ttl": {
          "name": "ttl",
          "type": "string",
          "kind": "scalar",
          "description": "An optional TTL to set for items, calculated from the moment the message is sent.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "ttl_key": {
          "name": "ttl_key",
          "type": "string",
          "kind": "scalar",
          "description": "The column key to place the TTL value within.",
          "required": true,
          "default": "",
          "advanced": true
        }
      }
    },
    "aws_kinesis": {
      "name": "aws_kinesis",
      "type": "output",
      "source": "upstream",
      "summary": "Sends messages to a Kinesis stream.",
      "description": "\nBoth the `partition_key`(required) and `hash_key` (optional) fields can be dynamically set using function interpolations described xref:configuration:interpolation.adoc#bloblang-queries[here]. When sending batched messages the interpolations are performed per message part.\n\n== Credentials\n\nBy default Redpanda Connect will use a shared credentials file when connecting to AWS services. It's also possible to set them explicitly at the component level, allowing you to transfer data across accounts. You can find out more in xref:guides:cloud/aws.adoc[].\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "backoff": {
          "name": "backoff",
          "type": "object",
          "kind": "scalar",
          "description": "Control time intervals between retry attempts.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "initial_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The initial period to wait between retry attempts.",
              "required": true,
              "default": "1s",
              "advanced": true
            },
            {
              "name": "max_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait between retry attempts.",
              "required": true,
              "default": "5s",
              "advanced": true
            },
            {
              "name": "max_elapsed_time",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait before retry attempts are abandoned. If zero then no limit is used.",
              "required": true,
              "default": "30s",
              "advanced": true
            }
          ]
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "credentials": {
          "name": "credentials",
          "type": "object",
          "kind": "scalar",
          "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "profile",
              "type": "string",
              "kind": "scalar",
              "description": "A profile from `~/.aws/credentials` to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "id",
              "type": "string",
              "kind": "scalar",
              "description": "The ID of credentials to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "secret",
              "type": "string",
              "kind": "scalar",
              "description": "The secret for the credentials being used.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token",
              "type": "string",
              "kind": "scalar",
              "description": "The token for the credentials being used, required when using short term credentials.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "from_ec2_role",
              "type": "bool",
              "kind": "scalar",
              "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "role",
              "type": "string",
              "kind": "scalar",
              "description": "A role ARN to assume.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "role_external_id",
              "type": "string",
              "kind": "scalar",
              "description": "An external ID to provide when assuming a role.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "Allows you to specify a custom endpoint for the AWS API.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "hash_key": {
          "name": "hash_key",
          "type": "string",
          "kind": "scalar",
          "description": "A optional hash key for partitioning messages.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of parallel message batches to have in flight at any given time.",
          "required": true,
          "default": 64
        },
        "max_retries": {
          "name": "max_retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retries before giving up on the request. If set to zero there is no discrete limit.",
          "required": true,
          "default": 0,
          "advanced": true
        },
        "partition_key": {
          "name": "partition_key",
          "type": "string",
          "kind": "scalar",
          "description": "A required key for partitioning messages.",
          "required": true,
          "default": null
        },
        "region": {
          "name": "region",
          "type": "string",
          "kind": "scalar",
          "description": "The AWS region to target.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "stream": {
          "name": "stream",
          "type": "string",
          "kind": "scalar",
          "description": "The stream to publish messages to. Streams can either be specified by their name or full ARN.",
          "required": true,
          "default": null,
          "examples": [
            "foo",
            "arn:aws:kinesis:*:111122223333:stream/my-stream"
          ]
        }
      }
    },
    "aws_kinesis_firehose": {
      "name": "aws_kinesis_firehose",
      "type": "output",
      "source": "upstream",
      "summary": "Sends messages to a Kinesis Firehose delivery stream.",
      "description": "\n== Credentials\n\nBy default Redpanda Connect will use a shared credentials file when connecting to AWS services. It's also possible to set them explicitly at the component level, allowing you to transfer data across accounts. You can find out more in xref:guides:cloud/aws.adoc[].\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].\n",
      "config": {
        "backoff": {
          "name": "backoff",
          "type": "object",
          "kind": "scalar",
          "description": "Control time intervals between retry attempts.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "initial_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The initial period to wait between retry attempts.",
              "required": true,
              "default": "1s",
              "advanced": true
            },
            {
              "name": "max_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait between retry attempts.",
              "required": true,
              "default": "5s",
              "advanced": true
            },
            {
              "name": "max_elapsed_time",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait before retry attempts are abandoned. If zero then no limit is used.",
              "required": true,
              "default": "30s",
              "advanced": true
            }
          ]
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "credentials": {
          "name": "credentials",
          "type": "object",
          "kind": "scalar",
          "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "profile",
              "type": "string",
              "kind": "scalar",
              "description": "A profile from `~/.aws/credentials` to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "id",
              "type": "string",
              "kind": "scalar",
              "description": "The ID of credentials to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "secret",
              "type": "string",
              "kind": "scalar",
              "description": "The secret for the credentials being used.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token",
              "type": "string",
              "kind": "scalar",
              "description": "The token for the credentials being used, required when using short term credentials.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "from_ec2_role",
              "type": "bool",
              "kind": "scalar",
              "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "role",
              "type": "string",
              "kind": "scalar",
              "description": "A role ARN to assume.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "role_external_id",
              "type": "string",
              "kind": "scalar",
              "description": "An external ID to provide when assuming a role.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "Allows you to specify a custom endpoint for the AWS API.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "max_retries": {
          "name": "max_retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retries before giving up on the request. If set to zero there is no discrete limit.",
          "required": true,
          "default": 0,
          "advanced": true
        },
        "region": {
          "name": "region",
          "type": "string",
          "kind": "scalar",
          "description": "The AWS region to target.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "stream": {
          "name": "stream",
          "type": "string",
          "kind": "scalar",
          "description": "The stream to publish messages to.",
          "required": true,
          "default": null
        }
      }
    },
    "aws_s3": {
      "name": "aws_s3",
      "type": "output",
      "source": "upstream",
      "summary": "Sends message parts as objects to an Amazon S3 bucket. Each object is uploaded with the path specified with the `path` field.",
      "description": "\nIn order to have a different path for each object you should use function interpolations described in xref:configuration:interpolation.adoc#bloblang-queries[Bloblang queries], which are calculated per message of a batch.\n\n== Metadata\n\nMetadata fields on messages will be sent as headers, in order to mutate these values (or remove them) check out the xref:configuration:metadata.adoc[metadata docs].\n\n== Tags\n\nThe tags field allows you to specify key/value pairs to attach to objects as tags, where the values support xref:configuration:interpolation.adoc#bloblang-queries[interpolation functions]:\n\n```yaml\noutput:\n  aws_s3:\n    bucket: TODO\n    path: ${!counter()}-${!timestamp_unix_nano()}.tar.gz\n    tags:\n      Key1: Value1\n      Timestamp: ${!meta(\"Timestamp\")}\n```\n\n=== Credentials\n\nBy default Redpanda Connect will use a shared credentials file when connecting to AWS services. It's also possible to set them explicitly at the component level, allowing you to transfer data across accounts. You can find out more in xref:guides:cloud/aws.adoc[].\n\n== Batching\n\nIt's common to want to upload messages to S3 as batched archives, the easiest way to do this is to batch your messages at the output level and join the batch of messages with an xref:components:processors/archive.adoc[`archive`] and/or xref:components:processors/compress.adoc[`compress`] processor.\n\nFor example, if we wished to upload messages as a .tar.gz archive of documents we could achieve that with the following config:\n\n```yaml\noutput:\n  aws_s3:\n    bucket: TODO\n    path: ${!counter()}-${!timestamp_unix_nano()}.tar.gz\n    batching:\n      count: 100\n      period: 10s\n      processors:\n        - archive:\n            format: tar\n        - compress:\n            algorithm: gzip\n```\n\nAlternatively, if we wished to upload JSON documents as a single large document containing an array of objects we can do that with:\n\n```yaml\noutput:\n  aws_s3:\n    bucket: TODO\n    path: ${!counter()}-${!timestamp_unix_nano()}.json\n    batching:\n      count: 100\n      processors:\n        - archive:\n            format: json_array\n```\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.",
      "config": {
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "bucket": {
          "name": "bucket",
          "type": "string",
          "kind": "scalar",
          "description": "The bucket to upload messages to.",
          "required": true,
          "default": null
        },
        "cache_control": {
          "name": "cache_control",
          "type": "string",
          "kind": "scalar",
          "description": "The cache control to set for each object.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "checksum_algorithm": {
          "name": "checksum_algorithm",
          "type": "string",
          "kind": "scalar",
          "description": "The algorithm used to create the checksum for each object.",
          "required": true,
          "default": "",
          "options": [
            "CRC32",
            "CRC32C",
            "SHA1",
            "SHA256"
          ],
          "advanced": true
        },
        "content_disposition": {
          "name": "content_disposition",
          "type": "string",
          "kind": "scalar",
          "description": "The content disposition to set for each object.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "content_encoding": {
          "name": "content_encoding",
          "type": "string",
          "kind": "scalar",
          "description": "An optional content encoding to set for each object.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "content_language": {
          "name": "content_language",
          "type": "string",
          "kind": "scalar",
          "description": "The content language to set for each object.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "content_md5": {
          "name": "content_md5",
          "type": "string",
          "kind": "scalar",
          "description": "The content MD5 to set for each object.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "content_type": {
          "name": "content_type",
          "type": "string",
          "kind": "scalar",
          "description": "The content type to set for each object.",
          "required": true,
          "default": "application/octet-stream"
        },
        "credentials": {
          "name": "credentials",
          "type": "object",
          "kind": "scalar",
          "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "profile",
              "type": "string",
              "kind": "scalar",
              "description": "A profile from `~/.aws/credentials` to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "id",
              "type": "string",
              "kind": "scalar",
              "description": "The ID of credentials to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "secret",
              "type": "string",
              "kind": "scalar",
              "description": "The secret for the credentials being used.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token",
              "type": "string",
              "kind": "scalar",
              "description": "The token for the credentials being used, required when using short term credentials.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "from_ec2_role",
              "type": "bool",
              "kind": "scalar",
              "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "role",
              "type": "string",
              "kind": "scalar",
              "description": "A role ARN to assume.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "role_external_id",
              "type": "string",
              "kind": "scalar",
              "description": "An external ID to provide when assuming a role.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "Allows you to specify a custom endpoint for the AWS API.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "force_path_style_urls": {
          "name": "force_path_style_urls",
          "type": "bool",
          "kind": "scalar",
          "description": "Forces the client API to use path style URLs, which helps when connecting to custom endpoints.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "kms_key_id": {
          "name": "kms_key_id",
          "type": "string",
          "kind": "scalar",
          "description": "An optional server side encryption key.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "metadata": {
          "name": "metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Specify criteria for which metadata values are attached to objects as headers.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "exclude_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to be excluded when adding metadata to sent messages.",
              "required": true,
              "default": []
            }
          ]
        },
        "path": {
          "name": "path",
          "type": "string",
          "kind": "scalar",
          "description": "The path of each message to upload.",
          "required": true,
          "default": "${!counter()}-${!timestamp_unix_nano()}.txt",
          "examples": [
            "${!counter()}-${!timestamp_unix_nano()}.txt",
            "${!meta(\"kafka_key\")}.json",
            "${!json(\"doc.namespace\")}/${!json(\"doc.id\")}.json"
          ]
        },
        "region": {
          "name": "region",
          "type": "string",
          "kind": "scalar",
          "description": "The AWS region to target.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "server_side_encryption": {
          "name": "server_side_encryption",
          "type": "string",
          "kind": "scalar",
          "description": "An optional server side encryption algorithm.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "storage_class": {
          "name": "storage_class",
          "type": "string",
          "kind": "scalar",
          "description": "The storage class to set for each object.",
          "required": true,
          "default": "STANDARD",
          "options": [
            "STANDARD",
            "REDUCED_REDUNDANCY",
            "GLACIER",
            "STANDARD_IA",
            "ONEZONE_IA",
            "INTELLIGENT_TIERING",
            "DEEP_ARCHIVE"
          ],
          "advanced": true
        },
        "tags": {
          "name": "tags",
          "type": "string",
          "kind": "map",
          "description": "Key/value pairs to store with the object as tags.",
          "required": true,
          "default": {},
          "examples": [
            {
              "Key1": "Value1",
              "Timestamp": "${!meta(\"Timestamp\")}"
            }
          ]
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum period to wait on an upload before abandoning it and reattempting.",
          "required": true,
          "default": "5s",
          "advanced": true
        },
        "website_redirect_location": {
          "name": "website_redirect_location",
          "type": "string",
          "kind": "scalar",
          "description": "The website redirect location to set for each object.",
          "required": true,
          "default": "",
          "advanced": true
        }
      }
    },
    "aws_sns": {
      "name": "aws_sns",
      "type": "output",
      "source": "upstream",
      "summary": "Sends messages to an AWS SNS topic.",
      "description": "\n== Credentials\n\nBy default Redpanda Connect will use a shared credentials file when connecting to AWS services. It's also possible to set them explicitly at the component level, allowing you to transfer data across accounts. You can find out more in xref:guides:cloud/aws.adoc[].\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.",
      "config": {
        "credentials": {
          "name": "credentials",
          "type": "object",
          "kind": "scalar",
          "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "profile",
              "type": "string",
              "kind": "scalar",
              "description": "A profile from `~/.aws/credentials` to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "id",
              "type": "string",
              "kind": "scalar",
              "description": "The ID of credentials to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "secret",
              "type": "string",
              "kind": "scalar",
              "description": "The secret for the credentials being used.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token",
              "type": "string",
              "kind": "scalar",
              "description": "The token for the credentials being used, required when using short term credentials.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "from_ec2_role",
              "type": "bool",
              "kind": "scalar",
              "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "role",
              "type": "string",
              "kind": "scalar",
              "description": "A role ARN to assume.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "role_external_id",
              "type": "string",
              "kind": "scalar",
              "description": "An external ID to provide when assuming a role.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "Allows you to specify a custom endpoint for the AWS API.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "message_deduplication_id": {
          "name": "message_deduplication_id",
          "type": "string",
          "kind": "scalar",
          "description": "An optional deduplication ID to set for messages.",
          "required": false,
          "default": null
        },
        "message_group_id": {
          "name": "message_group_id",
          "type": "string",
          "kind": "scalar",
          "description": "An optional group ID to set for messages.",
          "required": false,
          "default": null
        },
        "metadata": {
          "name": "metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Specify criteria for which metadata values are sent as headers.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "exclude_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to be excluded when adding metadata to sent messages.",
              "required": true,
              "default": []
            }
          ]
        },
        "region": {
          "name": "region",
          "type": "string",
          "kind": "scalar",
          "description": "The AWS region to target.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum period to wait on an upload before abandoning it and reattempting.",
          "required": true,
          "default": "5s",
          "advanced": true
        },
        "topic_arn": {
          "name": "topic_arn",
          "type": "string",
          "kind": "scalar",
          "description": "The topic to publish to.",
          "required": true,
          "default": null
        }
      }
    },
    "aws_sqs": {
      "name": "aws_sqs",
      "type": "output",
      "source": "upstream",
      "summary": "Sends messages to an SQS queue.",
      "description": "\nMetadata values are sent along with the payload as attributes with the data type String. If the number of metadata values in a message exceeds the message attribute limit (10) then the top ten keys ordered alphabetically will be selected.\n\nThe fields `message_group_id`, `message_deduplication_id` and `delay_seconds` can be set dynamically using xref:configuration:interpolation.adoc#bloblang-queries[function interpolations], which are resolved individually for each message of a batch.\n\n== Credentials\n\nBy default Redpanda Connect will use a shared credentials file when connecting to AWS services. It's also possible to set them explicitly at the component level, allowing you to transfer data across accounts. You can find out more in xref:guides:cloud/aws.adoc[].\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "backoff": {
          "name": "backoff",
          "type": "object",
          "kind": "scalar",
          "description": "Control time intervals between retry attempts.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "initial_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The initial period to wait between retry attempts.",
              "required": true,
              "default": "1s",
              "advanced": true
            },
            {
              "name": "max_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait between retry attempts.",
              "required": true,
              "default": "5s",
              "advanced": true
            },
            {
              "name": "max_elapsed_time",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait before retry attempts are abandoned. If zero then no limit is used.",
              "required": true,
              "default": "30s",
              "advanced": true
            }
          ]
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "credentials": {
          "name": "credentials",
          "type": "object",
          "kind": "scalar",
          "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "profile",
              "type": "string",
              "kind": "scalar",
              "description": "A profile from `~/.aws/credentials` to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "id",
              "type": "string",
              "kind": "scalar",
              "description": "The ID of credentials to use.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "secret",
              "type": "string",
              "kind": "scalar",
              "description": "The secret for the credentials being used.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token",
              "type": "string",
              "kind": "scalar",
              "description": "The token for the credentials being used, required when using short term credentials.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "from_ec2_role",
              "type": "bool",
              "kind": "scalar",
              "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "role",
              "type": "string",
              "kind": "scalar",
              "description": "A role ARN to assume.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "role_external_id",
              "type": "string",
              "kind": "scalar",
              "description": "An external ID to provide when assuming a role.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "delay_seconds": {
          "name": "delay_seconds",
          "type": "string",
          "kind": "scalar",
          "description": "An optional delay time in seconds for message. Value between 0 and 900",
          "required": false,
          "default": null
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "Allows you to specify a custom endpoint for the AWS API.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of parallel message batches to have in flight at any given time.",
          "required": true,
          "default": 64
        },
        "max_records_per_request": {
          "name": "max_records_per_request",
          "type": "int",
          "kind": "scalar",
          "description": "Customize the maximum number of records delivered in a single SQS request. This value must be greater than 0 but no greater than 10.",
          "required": true,
          "default": 10,
          "advanced": true
        },
        "max_retries": {
          "name": "max_retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retries before giving up on the request. If set to zero there is no discrete limit.",
          "required": true,
          "default": 0,
          "advanced": true
        },
        "message_deduplication_id": {
          "name": "message_deduplication_id",
          "type": "string",
          "kind": "scalar",
          "description": "An optional deduplication ID to set for messages.",
          "required": false,
          "default": null
        },
        "message_group_id": {
          "name": "message_group_id",
          "type": "string",
          "kind": "scalar",
          "description": "An optional group ID to set for messages.",
          "required": false,
          "default": null
        },
        "metadata": {
          "name": "metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Specify criteria for which metadata values are sent as headers.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "exclude_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to be excluded when adding metadata to sent messages.",
              "required": true,
              "default": []
            }
          ]
        },
        "region": {
          "name": "region",
          "type": "string",
          "kind": "scalar",
          "description": "The AWS region to target.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL of the target SQS queue.",
          "required": true,
          "default": null
        }
      }
    },
    "azure_blob_storage": {
      "name": "azure_blob_storage",
      "type": "output",
      "source": "upstream",
      "summary": "Sends message parts as objects to an Azure Blob Storage Account container. Each object is uploaded with the filename specified with the `container` field.",
      "description": "\nIn order to have a different path for each object you should use function\ninterpolations described xref:configuration:interpolation.adoc#bloblang-queries[here], which are\ncalculated per message of a batch.\n\nSupports multiple authentication methods but only one of the following is required:\n\n- `storage_connection_string`\n- `storage_account` and `storage_access_key`\n- `storage_account` and `storage_sas_token`\n- `storage_account` to access via https://pkg.go.dev/github.com/Azure/azure-sdk-for-go/sdk/azidentity#DefaultAzureCredential[DefaultAzureCredential^]\n\nIf multiple are set then the `storage_connection_string` is given priority.\n\nIf the `storage_connection_string` does not contain the `AccountName` parameter, please specify it in the\n`storage_account` field.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.",
      "config": {
        "blob_type": {
          "name": "blob_type",
          "type": "string",
          "kind": "scalar",
          "description": "Block and Append blobs are comprized of blocks, and each blob can support up to 50,000 blocks. The default value is `+\"`BLOCK`\"+`.`",
          "required": true,
          "default": "BLOCK",
          "options": [
            "BLOCK",
            "APPEND"
          ],
          "advanced": true
        },
        "container": {
          "name": "container",
          "type": "string",
          "kind": "scalar",
          "description": "The container for uploading the messages to.",
          "required": true,
          "default": null,
          "examples": [
            "messages-${!timestamp(\"2006\")}"
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "path": {
          "name": "path",
          "type": "string",
          "kind": "scalar",
          "description": "The path of each message to upload.",
          "required": true,
          "default": "${!counter()}-${!timestamp_unix_nano()}.txt",
          "examples": [
            "${!counter()}-${!timestamp_unix_nano()}.json",
            "${!meta(\"kafka_key\")}.json",
            "${!json(\"doc.namespace\")}/${!json(\"doc.id\")}.json"
          ]
        },
        "public_access_level": {
          "name": "public_access_level",
          "type": "string",
          "kind": "scalar",
          "description": "The container's public access level. The default value is `PRIVATE`.",
          "required": true,
          "default": "PRIVATE",
          "options": [
            "PRIVATE",
            "BLOB",
            "CONTAINER"
          ],
          "advanced": true
        },
        "storage_access_key": {
          "name": "storage_access_key",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account access key. This field is ignored if `storage_connection_string` is set.",
          "required": true,
          "default": ""
        },
        "storage_account": {
          "name": "storage_account",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account to access. This field is ignored if `storage_connection_string` is set.",
          "required": true,
          "default": ""
        },
        "storage_connection_string": {
          "name": "storage_connection_string",
          "type": "string",
          "kind": "scalar",
          "description": "A storage account connection string. This field is required if `storage_account` and `storage_access_key` / `storage_sas_token` are not set.",
          "required": true,
          "default": ""
        },
        "storage_sas_token": {
          "name": "storage_sas_token",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account SAS token. This field is ignored if `storage_connection_string` or `storage_access_key` are set.",
          "required": true,
          "default": ""
        }
      }
    },
    "azure_cosmosdb": {
      "name": "azure_cosmosdb",
      "type": "output",
      "source": "upstream",
      "summary": "Creates or updates messages as JSON documents in https://learn.microsoft.com/en-us/azure/cosmos-db/introduction[Azure CosmosDB^].",
      "description": "\nWhen creating documents, each message must have the `id` property (case-sensitive) set (or use `auto_id: true`). It is the unique name that identifies the document, that is, no two documents share the same `id` within a logical partition. The `id` field must not exceed 255 characters. https://learn.microsoft.com/en-us/rest/api/cosmos-db/documents[See details^].\n\nThe `partition_keys` field must resolve to the same value(s) across the entire message batch.\n\n\n== Credentials\n\nYou can use one of the following authentication mechanisms:\n\n- Set the `endpoint` field and the `account_key` field\n- Set only the `endpoint` field to use https://pkg.go.dev/github.com/Azure/azure-sdk-for-go/sdk/azidentity#DefaultAzureCredential[DefaultAzureCredential^]\n- Set the `connection_string` field\n\n\n== Batching\n\nCosmosDB limits the maximum batch size to 100 messages and the payload must not exceed 2MB (https://learn.microsoft.com/en-us/azure/cosmos-db/concepts-limits#per-request-limits[details here^]).\n\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "account_key": {
          "name": "account_key",
          "type": "string",
          "kind": "scalar",
          "description": "Account key.",
          "required": false,
          "default": null,
          "examples": [
            "C2y6yDjf5/R+ob0N8A7Cgv30VRDJIWEHLM+4QDU5DE2nQ9nDuVTqobD4b8mGGyPMbIZnqyMsEcaGQy67XIw/Jw=="
          ]
        },
        "auto_id": {
          "name": "auto_id",
          "type": "bool",
          "kind": "scalar",
          "description": "Automatically set the item `id` field to a random UUID v4. If the `id` field is already set, then it will not be overwritten. Setting this to `false` can improve performance, since the messages will not have to be parsed.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "connection_string": {
          "name": "connection_string",
          "type": "string",
          "kind": "scalar",
          "description": "Connection string.",
          "required": false,
          "default": null,
          "examples": [
            "AccountEndpoint=https://localhost:8081/;AccountKey=C2y6yDjf5/R+ob0N8A7Cgv30VRDJIWEHLM+4QDU5DE2nQ9nDuVTqobD4b8mGGyPMbIZnqyMsEcaGQy67XIw/Jw==;"
          ]
        },
        "container": {
          "name": "container",
          "type": "string",
          "kind": "scalar",
          "description": "Container.",
          "required": true,
          "default": null,
          "examples": [
            "testcontainer"
          ]
        },
        "database": {
          "name": "database",
          "type": "string",
          "kind": "scalar",
          "description": "Database.",
          "required": true,
          "default": null,
          "examples": [
            "testdb"
          ]
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "CosmosDB endpoint.",
          "required": false,
          "default": null,
          "examples": [
            "https://localhost:8081"
          ]
        },
        "item_id": {
          "name": "item_id",
          "type": "string",
          "kind": "scalar",
          "description": "ID of item to replace or delete. Only used by the Replace and Delete operations",
          "required": false,
          "default": null,
          "examples": [
            "${! json(\"id\") }"
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "operation": {
          "name": "operation",
          "type": "string",
          "kind": "scalar",
          "description": "Operation.",
          "required": true,
          "default": "Create"
        },
        "partition_keys_map": {
          "name": "partition_keys_map",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to a single partition key value or an array of partition key values of type string, integer or boolean. Currently, hierarchical partition keys are not supported so only one value may be provided.",
          "required": true,
          "default": null,
          "examples": [
            "root = \"blobfish\"",
            "root = 41",
            "root = true",
            "root = null",
            "root = json(\"blobfish\").depth"
          ]
        },
        "patch_condition": {
          "name": "patch_condition",
          "type": "string",
          "kind": "scalar",
          "description": "Patch operation condition.",
          "required": false,
          "default": null,
          "examples": [
            "from c where not is_defined(c.blobfish)"
          ],
          "advanced": true
        },
        "patch_operations": {
          "name": "patch_operations",
          "type": "object",
          "kind": "array",
          "description": "Patch operations to be performed when `operation: Patch` .",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "operation",
              "type": "string",
              "kind": "scalar",
              "description": "Operation.",
              "required": true,
              "default": "Add",
              "advanced": true
            },
            {
              "name": "path",
              "type": "string",
              "kind": "scalar",
              "description": "Path.",
              "required": true,
              "default": null,
              "examples": [
                "/foo/bar/baz"
              ],
              "advanced": true
            },
            {
              "name": "value_map",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to a value of any type that is supported by CosmosDB.",
              "required": false,
              "default": null,
              "examples": [
                "root = \"blobfish\"",
                "root = 41",
                "root = true",
                "root = json(\"blobfish\").depth",
                "root = [1, 2, 3]"
              ],
              "advanced": true
            }
          ]
        }
      }
    },
    "azure_data_lake_gen2": {
      "name": "azure_data_lake_gen2",
      "type": "output",
      "source": "upstream",
      "summary": "Sends message parts as files to an Azure Data Lake Gen2 filesystem. Each file is uploaded with the filename specified with the `path` field.",
      "description": "\nIn order to have a different path for each file you should use function\ninterpolations described xref:configuration:interpolation.adoc#bloblang-queries[here], which are\ncalculated per message of a batch.\n\nSupports multiple authentication methods but only one of the following is required:\n\n- `storage_connection_string`\n- `storage_account` and `storage_access_key`\n- `storage_account` and `storage_sas_token`\n- `storage_account` to access via https://pkg.go.dev/github.com/Azure/azure-sdk-for-go/sdk/azidentity#DefaultAzureCredential[DefaultAzureCredential^]\n\nIf multiple are set then the `storage_connection_string` is given priority.\n\nIf the `storage_connection_string` does not contain the `AccountName` parameter, please specify it in the\n`storage_account` field.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.",
      "config": {
        "filesystem": {
          "name": "filesystem",
          "type": "string",
          "kind": "scalar",
          "description": "The data lake storage filesystem name for uploading the messages to.",
          "required": true,
          "default": null,
          "examples": [
            "messages-${!timestamp(\"2006\")}"
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "path": {
          "name": "path",
          "type": "string",
          "kind": "scalar",
          "description": "The path of each message to upload within the filesystem.",
          "required": true,
          "default": "${!counter()}-${!timestamp_unix_nano()}.txt",
          "examples": [
            "${!counter()}-${!timestamp_unix_nano()}.json",
            "${!meta(\"kafka_key\")}.json",
            "${!json(\"doc.namespace\")}/${!json(\"doc.id\")}.json"
          ]
        },
        "storage_access_key": {
          "name": "storage_access_key",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account access key. This field is ignored if `storage_connection_string` is set.",
          "required": true,
          "default": ""
        },
        "storage_account": {
          "name": "storage_account",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account to access. This field is ignored if `storage_connection_string` is set.",
          "required": true,
          "default": ""
        },
        "storage_connection_string": {
          "name": "storage_connection_string",
          "type": "string",
          "kind": "scalar",
          "description": "A storage account connection string. This field is required if `storage_account` and `storage_access_key` / `storage_sas_token` are not set.",
          "required": true,
          "default": ""
        },
        "storage_sas_token": {
          "name": "storage_sas_token",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account SAS token. This field is ignored if `storage_connection_string` or `storage_access_key` are set.",
          "required": true,
          "default": ""
        }
      }
    },
    "azure_queue_storage": {
      "name": "azure_queue_storage",
      "type": "output",
      "source": "upstream",
      "summary": "Sends messages to an Azure Storage Queue.",
      "description": "\nOnly one authentication method is required, `storage_connection_string` or `storage_account` and `storage_access_key`. If both are set then the `storage_connection_string` is given priority.\n\nIn order to set the `queue_name` you can use function interpolations described xref:configuration:interpolation.adoc#bloblang-queries[here], which are calculated per message of a batch.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of parallel message batches to have in flight at any given time.",
          "required": true,
          "default": 64
        },
        "queue_name": {
          "name": "queue_name",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the target Queue Storage queue.",
          "required": true,
          "default": null
        },
        "storage_access_key": {
          "name": "storage_access_key",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account access key. This field is ignored if `storage_connection_string` is set.",
          "required": true,
          "default": ""
        },
        "storage_account": {
          "name": "storage_account",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account to access. This field is ignored if `storage_connection_string` is set.",
          "required": true,
          "default": ""
        },
        "storage_connection_string": {
          "name": "storage_connection_string",
          "type": "string",
          "kind": "scalar",
          "description": "A storage account connection string. This field is required if `storage_account` and `storage_access_key` / `storage_sas_token` are not set.",
          "required": true,
          "default": ""
        },
        "storage_sas_token": {
          "name": "storage_sas_token",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account SAS token. This field is ignored if `storage_connection_string` or `storage_access_key` are set.",
          "required": true,
          "default": ""
        },
        "ttl": {
          "name": "ttl",
          "type": "string",
          "kind": "scalar",
          "description": "The TTL of each individual message as a duration string. Defaults to 0, meaning no retention period is set",
          "required": true,
          "default": "",
          "examples": [
            "60s",
            "5m",
            "36h"
          ],
          "advanced": true
        }
      }
    },
    "azure_table_storage": {
      "name": "azure_table_storage",
      "type": "output",
      "source": "upstream",
      "summary": "Stores messages in an Azure Table Storage table.",
      "description": "\nOnly one authentication method is required, `storage_connection_string` or `storage_account` and `storage_access_key`. If both are set then the `storage_connection_string` is given priority.\n\nIn order to set the `table_name`,  `partition_key` and `row_key` you can use function interpolations described xref:configuration:interpolation.adoc#bloblang-queries[here], which are calculated per message of a batch.\n\nIf the `properties` are not set in the config, all the `json` fields are marshalled and stored in the table, which will be created if it does not exist.\n\nThe `object` and `array` fields are marshaled as strings. e.g.:\n\nThe JSON message:\n\n```json\n{\n  \"foo\": 55,\n  \"bar\": {\n    \"baz\": \"a\",\n    \"bez\": \"b\"\n  },\n  \"diz\": [\"a\", \"b\"]\n}\n```\n\nWill store in the table the following properties:\n\n```yml\nfoo: '55'\nbar: '{ \"baz\": \"a\", \"bez\": \"b\" }'\ndiz: '[\"a\", \"b\"]'\n```\n\nIt's also possible to use function interpolations to get or transform the properties values, e.g.:\n\n```yml\nproperties:\n  device: '${! json(\"device\") }'\n  timestamp: '${! json(\"timestamp\") }'\n```\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "insert_type": {
          "name": "insert_type",
          "type": "string",
          "kind": "scalar",
          "description": "Type of insert operation. Valid options are `INSERT`, `INSERT_MERGE` and `INSERT_REPLACE`",
          "required": true,
          "default": "",
          "examples": [
            "${! json(\"operation\") }",
            "${! meta(\"operation\") }",
            "INSERT"
          ],
          "options": [
            "INSERT",
            "INSERT_MERGE",
            "INSERT_REPLACE"
          ],
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of parallel message batches to have in flight at any given time.",
          "required": true,
          "default": 64
        },
        "partition_key": {
          "name": "partition_key",
          "type": "string",
          "kind": "scalar",
          "description": "The partition key.",
          "required": true,
          "default": "",
          "examples": [
            "${! json(\"date\") }"
          ]
        },
        "properties": {
          "name": "properties",
          "type": "string",
          "kind": "map",
          "description": "A map of properties to store into the table.",
          "required": true,
          "default": {}
        },
        "row_key": {
          "name": "row_key",
          "type": "string",
          "kind": "scalar",
          "description": "The row key.",
          "required": true,
          "default": "",
          "examples": [
            "${! json(\"device\")}-${!uuid_v4() }"
          ]
        },
        "storage_access_key": {
          "name": "storage_access_key",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account access key. This field is ignored if `storage_connection_string` is set.",
          "required": true,
          "default": ""
        },
        "storage_account": {
          "name": "storage_account",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account to access. This field is ignored if `storage_connection_string` is set.",
          "required": true,
          "default": ""
        },
        "storage_connection_string": {
          "name": "storage_connection_string",
          "type": "string",
          "kind": "scalar",
          "description": "A storage account connection string. This field is required if `storage_account` and `storage_access_key` / `storage_sas_token` are not set.",
          "required": true,
          "default": ""
        },
        "storage_sas_token": {
          "name": "storage_sas_token",
          "type": "string",
          "kind": "scalar",
          "description": "The storage account SAS token. This field is ignored if `storage_connection_string` or `storage_access_key` are set.",
          "required": true,
          "default": ""
        },
        "table_name": {
          "name": "table_name",
          "type": "string",
          "kind": "scalar",
          "description": "The table to store messages into.",
          "required": true,
          "default": null,
          "examples": [
            "${! meta(\"kafka_topic\") }",
            "${! json(\"table\") }"
          ]
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum period to wait on an upload before abandoning it and reattempting.",
          "required": true,
          "default": "5s",
          "advanced": true
        },
        "transaction_type": {
          "name": "transaction_type",
          "type": "string",
          "kind": "scalar",
          "description": "Type of transaction operation.",
          "required": true,
          "default": "INSERT",
          "examples": [
            "${! json(\"operation\") }",
            "${! meta(\"operation\") }",
            "INSERT"
          ],
          "options": [
            "INSERT",
            "INSERT_MERGE",
            "INSERT_REPLACE",
            "UPDATE_MERGE",
            "UPDATE_REPLACE",
            "DELETE"
          ],
          "advanced": true
        }
      }
    },
    "beanstalkd": {
      "name": "beanstalkd",
      "type": "output",
      "source": "upstream",
      "summary": "Write messages to a Beanstalkd queue.",
      "config": {
        "address": {
          "name": "address",
          "type": "string",
          "kind": "scalar",
          "description": "An address to connect to.",
          "required": true,
          "default": null,
          "examples": [
            "127.0.0.1:11300"
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase to improve throughput.",
          "required": true,
          "default": 64
        }
      }
    },
    "broker": {
      "name": "broker",
      "type": "output",
      "source": "upstream",
      "summary": "Allows you to route messages to multiple child outputs using a range of brokering \u003c\u003cpatterns\u003e\u003e.",
      "description": "\nxref:components:processors/about.adoc[Processors] can be listed to apply across individual outputs or all outputs:\n\n```yaml\noutput:\n  broker:\n    pattern: fan_out\n    outputs:\n      - resource: foo\n      - resource: bar\n        # Processors only applied to messages sent to bar.\n        processors:\n          - resource: bar_processor\n\n  # Processors applied to messages sent to all brokered outputs.\n  processors:\n    - resource: general_processor\n```",
      "config": {
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "copies": {
          "name": "copies",
          "type": "int",
          "kind": "scalar",
          "description": "The number of copies of each configured output to spawn.",
          "required": true,
          "default": 1,
          "advanced": true
        },
        "outputs": {
          "name": "outputs",
          "type": "output",
          "kind": "array",
          "description": "A list of child outputs to broker.",
          "required": true,
          "default": null
        },
        "pattern": {
          "name": "pattern",
          "type": "string",
          "kind": "scalar",
          "description": "The brokering pattern to use.",
          "required": true,
          "default": "fan_out",
          "options": [
            "fan_out",
            "fan_out_fail_fast",
            "fan_out_sequential",
            "fan_out_sequential_fail_fast",
            "round_robin",
            "greedy"
          ]
        }
      }
    },
    "cache": {
      "name": "cache",
      "type": "output",
      "source": "upstream",
      "summary": "Stores each message in a xref:components:caches/about.adoc[cache].",
      "description": "Caches are configured as xref:components:caches/about.adoc[resources], where there's a wide variety to choose from.\n\n:cache-support: aws_dynamodb=certified, aws_s3=certified, file=certified, memcached=certified, memory=certified, nats_kv=certified, redis=certified, ristretto=certified, couchbase=community, mongodb=community, sql=community, multilevel=community, ttlru=community, gcp_cloud_storage=community, lru=community, noop=community\n\nThe `target` field must reference a configured cache resource label like follows:\n\n```yaml\noutput:\n  cache:\n    target: foo\n    key: ${!json(\"document.id\")}\n\ncache_resources:\n  - label: foo\n    memcached:\n      addresses:\n        - localhost:11211\n      default_ttl: 60s\n```\n\nIn order to create a unique `key` value per item you should use function interpolations described in xref:configuration:interpolation.adoc#bloblang-queries[Bloblang queries].\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.",
      "config": {
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "The key to store messages by, function interpolation should be used in order to derive a unique key for each message.",
          "required": true,
          "default": "${!count(\"items\")}-${!timestamp_unix_nano()}",
          "examples": [
            "${!count(\"items\")}-${!timestamp_unix_nano()}",
            "${!json(\"doc.id\")}",
            "${!meta(\"kafka_key\")}"
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "target": {
          "name": "target",
          "type": "string",
          "kind": "scalar",
          "description": "The target cache to store messages in.",
          "required": true,
          "default": null
        },
        "ttl": {
          "name": "ttl",
          "type": "string",
          "kind": "scalar",
          "description": "The TTL of each individual item as a duration string. After this period an item will be eligible for removal during the next compaction. Not all caches support per-key TTLs, and those that do not will fall back to their generally configured TTL setting.",
          "required": false,
          "default": null,
          "examples": [
            "60s",
            "5m",
            "36h"
          ],
          "advanced": true
        }
      }
    },
    "cassandra": {
      "name": "cassandra",
      "type": "output",
      "source": "upstream",
      "summary": "Runs a query against a Cassandra database for each message in order to insert data.",
      "description": "\nQuery arguments can be set using a bloblang array for the fields using the `args_mapping` field.\n\nWhen populating timestamp columns the value must either be a string in ISO 8601 format (2006-01-02T15:04:05Z07:00), or an integer representing unix time in seconds.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "addresses": {
          "name": "addresses",
          "type": "string",
          "kind": "array",
          "description": "A list of Cassandra nodes to connect to. Multiple comma separated addresses can be specified on a single line.",
          "required": true,
          "default": null,
          "examples": [
            [
              "localhost:9042"
            ],
            [
              "foo:9042",
              "bar:9042"
            ],
            [
              "foo:9042,bar:9042"
            ]
          ]
        },
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] that can be used to provide arguments to Cassandra queries. The result of the query must be an array containing a matching number of elements to the query arguments.",
          "required": false,
          "default": null
        },
        "backoff": {
          "name": "backoff",
          "type": "object",
          "kind": "scalar",
          "description": "Control time intervals between retry attempts.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "initial_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The initial period to wait between retry attempts.",
              "required": true,
              "default": "1s",
              "advanced": true
            },
            {
              "name": "max_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait between retry attempts.",
              "required": true,
              "default": "5s",
              "advanced": true
            }
          ]
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "consistency": {
          "name": "consistency",
          "type": "string",
          "kind": "scalar",
          "description": "The consistency level to use.",
          "required": true,
          "default": "QUORUM",
          "options": [
            "ANY",
            "ONE",
            "TWO",
            "THREE",
            "QUORUM",
            "ALL",
            "LOCAL_QUORUM",
            "EACH_QUORUM",
            "LOCAL_ONE"
          ],
          "advanced": true
        },
        "disable_initial_host_lookup": {
          "name": "disable_initial_host_lookup",
          "type": "bool",
          "kind": "scalar",
          "description": "If enabled the driver will not attempt to get host info from the system.peers table. This can speed up queries but will mean that data_centre, rack and token information will not be available.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "logged_batch": {
          "name": "logged_batch",
          "type": "bool",
          "kind": "scalar",
          "description": "If enabled the driver will perform a logged batch. Disabling this prompts unlogged batches to be used instead, which are less efficient but necessary for alternative storages that do not support logged batches.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "max_retries": {
          "name": "max_retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retries before giving up on a request.",
          "required": true,
          "default": 3,
          "advanced": true
        },
        "password_authenticator": {
          "name": "password_authenticator",
          "type": "object",
          "kind": "scalar",
          "description": "Optional configuration of Cassandra authentication parameters.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use password authentication",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "The username to authenticate as.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "The password to authenticate with.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "query": {
          "name": "query",
          "type": "string",
          "kind": "scalar",
          "description": "A query to execute for each message.",
          "required": true,
          "default": null
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The client connection timeout.",
          "required": true,
          "default": "600ms"
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        }
      }
    },
    "couchbase": {
      "name": "couchbase",
      "type": "output",
      "source": "upstream",
      "summary": "Performs operations against Couchbase for each message, allowing you to store or delete data.",
      "description": "When inserting, replacing or upserting documents, each must have the `content` property set.\n\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "bucket": {
          "name": "bucket",
          "type": "string",
          "kind": "scalar",
          "description": "Couchbase bucket.",
          "required": true,
          "default": null
        },
        "collection": {
          "name": "collection",
          "type": "string",
          "kind": "scalar",
          "description": "Bucket collection.",
          "required": false,
          "default": "_default",
          "advanced": true
        },
        "content": {
          "name": "content",
          "type": "string",
          "kind": "scalar",
          "description": "Document content.",
          "required": false,
          "default": null
        },
        "id": {
          "name": "id",
          "type": "string",
          "kind": "scalar",
          "description": "Document id.",
          "required": true,
          "default": null,
          "examples": [
            "${! json(\"id\") }"
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "operation": {
          "name": "operation",
          "type": "string",
          "kind": "scalar",
          "description": "Couchbase operation to perform.",
          "required": true,
          "default": "upsert"
        },
        "password": {
          "name": "password",
          "type": "string",
          "kind": "scalar",
          "description": "Password to connect to the cluster.",
          "required": false,
          "default": null
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "Operation timeout.",
          "required": true,
          "default": "15s",
          "advanced": true
        },
        "transcoder": {
          "name": "transcoder",
          "type": "string",
          "kind": "scalar",
          "description": "Couchbase transcoder to use.",
          "required": true,
          "default": "legacy",
          "advanced": true
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "Couchbase connection string.",
          "required": true,
          "default": null,
          "examples": [
            "couchbase://localhost:11210"
          ]
        },
        "username": {
          "name": "username",
          "type": "string",
          "kind": "scalar",
          "description": "Username to connect to the cluster.",
          "required": false,
          "default": null
        }
      }
    },
    "cypher": {
      "name": "cypher",
      "type": "output",
      "source": "upstream",
      "summary": "",
      "description": "The cypher output type writes a batch of messages to any graph database that supports the Neo4j or Bolt protocols.",
      "config": {
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "The mapping from the message to the data that is passed in as parameters to the cypher expression. Must be an object. By default the entire payload is used.",
          "required": false,
          "default": null,
          "examples": [
            "root.name = this.displayName",
            "root = {\"orgId\": this.org.id, \"name\": this.user.name}"
          ]
        },
        "basic_auth": {
          "name": "basic_auth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify basic authentication.",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use basic authentication in requests.",
              "required": true,
              "default": false
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "A username to authenticate as.",
              "required": true,
              "default": ""
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A password to authenticate with.",
              "required": true,
              "default": ""
            },
            {
              "name": "realm",
              "type": "string",
              "kind": "scalar",
              "description": "The realm for authentication challenges.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "cypher": {
          "name": "cypher",
          "type": "string",
          "kind": "scalar",
          "description": "The cypher expression to execute against the graph database.",
          "required": true,
          "default": null,
          "examples": [
            "MERGE (p:Person {name: $name})",
            "MATCH (o:Organization {id: $orgId})\nMATCH (p:Person {name: $name})\nMERGE (p)-[:WORKS_FOR]-\u003e(o)"
          ]
        },
        "database_name": {
          "name": "database_name",
          "type": "string",
          "kind": "scalar",
          "description": "Set the target database for which expressions are evaluated against.",
          "required": true,
          "default": ""
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "uri": {
          "name": "uri",
          "type": "string",
          "kind": "scalar",
          "description": "The connection URI to connect to.\nSee https://neo4j.com/docs/go-manual/current/connect-advanced/[Neo4j's documentation^] for more information. ",
          "required": true,
          "default": null,
          "examples": [
            "neo4j://demo.neo4jlabs.com",
            "neo4j+s://aura.databases.neo4j.io",
            "neo4j+ssc://self-signed.demo.neo4jlabs.com",
            "bolt://127.0.0.1:7687",
            "bolt+s://core.db.server:7687",
            "bolt+ssc://10.0.0.43"
          ]
        }
      }
    },
    "discord": {
      "name": "discord",
      "type": "output",
      "source": "upstream",
      "summary": "Writes messages to a Discord channel.",
      "description": "\nThis output POSTs messages to the `/channels/\\{channel_id}/messages` Discord API endpoint authenticated as a bot using token based authentication.\n\nIf the format of a message is a JSON object matching the https://discord.com/developers/docs/resources/channel#message-object[Discord API message type^] then it is sent directly, otherwise an object matching the API type is created with the content of the message added as a string.\n",
      "config": {
        "bot_token": {
          "name": "bot_token",
          "type": "string",
          "kind": "scalar",
          "description": "A bot token used for authentication.",
          "required": true,
          "default": null
        },
        "channel_id": {
          "name": "channel_id",
          "type": "string",
          "kind": "scalar",
          "description": "A discord channel ID to write messages to.",
          "required": true,
          "default": null
        },
        "rate_limit": {
          "name": "rate_limit",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": "An optional rate limit resource to restrict API requests with."
        }
      }
    },
    "drop": {
      "name": "drop",
      "type": "output",
      "source": "upstream",
      "summary": "Drops all messages.",
      "config": {}
    },
    "drop_on": {
      "name": "drop_on",
      "type": "output",
      "source": "upstream",
      "summary": "Attempts to write messages to a child output and if the write fails for one of a list of configurable reasons the message is dropped (acked) instead of being reattempted (or nacked).",
      "description": "Regular Redpanda Connect outputs will apply back pressure when downstream services aren't accessible, and Redpanda Connect retries (or nacks) all messages that fail to be delivered. However, in some circumstances, or for certain output types, we instead might want to relax these mechanisms, which is when this output becomes useful.",
      "config": {
        "back_pressure": {
          "name": "back_pressure",
          "type": "string",
          "kind": "scalar",
          "description": "An optional duration string that determines the maximum length of time to wait for a given message to be accepted by the child output before the message should be dropped instead. The most common reason for an output to block is when waiting for a lost connection to be re-established. Once a message has been dropped due to back pressure all subsequent messages are dropped immediately until the output is ready to process them again. Note that if `error` is set to `false` and this field is specified then messages dropped due to back pressure will return an error response (are nacked or reattempted).",
          "required": false,
          "default": null,
          "examples": [
            "30s",
            "1m"
          ]
        },
        "error": {
          "name": "error",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether messages should be dropped when the child output returns an error of any type. For example, this could be when an `http_client` output gets a 4XX response code. In order to instead drop only on specific error patterns use the `error_matches` field instead.",
          "required": true,
          "default": false
        },
        "error_patterns": {
          "name": "error_patterns",
          "type": "string",
          "kind": "array",
          "description": "A list of regular expressions (re2) where if the child output returns an error that matches any part of any of these patterns the message will be dropped.",
          "required": false,
          "default": null,
          "examples": [
            [
              "and that was really bad$"
            ],
            [
              "roughly [0-9]+ issues occurred"
            ]
          ]
        },
        "output": {
          "name": "output",
          "type": "output",
          "kind": "scalar",
          "description": "A child output to wrap with this drop mechanism.",
          "required": true,
          "default": null
        }
      }
    },
    "dynamic": {
      "name": "dynamic",
      "type": "output",
      "source": "upstream",
      "summary": "A special broker type where the outputs are identified by unique labels and can be created, changed and removed during runtime via a REST API.",
      "description": "The broker pattern used is always `fan_out`, meaning each message will be delivered to each dynamic output.",
      "config": {
        "outputs": {
          "name": "outputs",
          "type": "output",
          "kind": "map",
          "description": "A map of outputs to statically create.",
          "required": true,
          "default": {}
        },
        "prefix": {
          "name": "prefix",
          "type": "string",
          "kind": "scalar",
          "description": "A path prefix for HTTP endpoints that are registered.",
          "required": true,
          "default": ""
        }
      }
    },
    "elasticsearch": {
      "name": "elasticsearch",
      "type": "output",
      "source": "upstream",
      "summary": "Publishes messages into an Elasticsearch index. If the index does not exist then it is created with a dynamic mapping.",
      "description": "\nBoth the `id` and `index` fields can be dynamically set using function interpolations described in xref:configuration:interpolation.adoc#bloblang-queries[Bloblang queries]. When sending batched messages these interpolations are performed per message part.\n\n== AWS\n\nIt's possible to enable AWS connectivity with this output using the `aws` fields. However, you may need to set `sniff` and `healthcheck` to false for connections to succeed.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "action": {
          "name": "action",
          "type": "string",
          "kind": "scalar",
          "description": "The action to take on the document. This field must resolve to one of the following action types: `create`, `index`, `update`, `upsert` or `delete`.",
          "required": true,
          "default": "index",
          "advanced": true
        },
        "api_key": {
          "name": "api_key",
          "type": "string",
          "kind": "scalar",
          "description": "The key to set in the Authorization header if using API keys for authentication.",
          "required": false,
          "default": null
        },
        "aws": {
          "name": "aws",
          "type": "object",
          "kind": "scalar",
          "description": "Enables and customises connectivity to Amazon Elastic Service.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to connect to Amazon Elastic Service.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "region",
              "type": "string",
              "kind": "scalar",
              "description": "The AWS region to target.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "endpoint",
              "type": "string",
              "kind": "scalar",
              "description": "Allows you to specify a custom endpoint for the AWS API.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "credentials",
              "type": "object",
              "kind": "scalar",
              "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
              "required": true,
              "default": null,
              "advanced": true,
              "children": [
                {
                  "name": "profile",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A profile from `~/.aws/credentials` to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "id",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The ID of credentials to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "secret",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The secret for the credentials being used.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "token",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The token for the credentials being used, required when using short term credentials.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "from_ec2_role",
                  "type": "bool",
                  "kind": "scalar",
                  "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
                  "required": true,
                  "default": false,
                  "advanced": true
                },
                {
                  "name": "role",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A role ARN to assume.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "role_external_id",
                  "type": "string",
                  "kind": "scalar",
                  "description": "An external ID to provide when assuming a role.",
                  "required": true,
                  "default": "",
                  "advanced": true
                }
              ]
            }
          ]
        },
        "backoff": {
          "name": "backoff",
          "type": "object",
          "kind": "scalar",
          "description": "Control time intervals between retry attempts.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "initial_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The initial period to wait between retry attempts.",
              "required": true,
              "default": "1s",
              "advanced": true
            },
            {
              "name": "max_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait between retry attempts.",
              "required": true,
              "default": "5s",
              "advanced": true
            },
            {
              "name": "max_elapsed_time",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait before retry attempts are abandoned. If zero then no limit is used.",
              "required": true,
              "default": "30s",
              "advanced": true
            }
          ]
        },
        "basic_auth": {
          "name": "basic_auth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify basic authentication.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use basic authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "A username to authenticate as.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A password to authenticate with.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "gzip_compression": {
          "name": "gzip_compression",
          "type": "bool",
          "kind": "scalar",
          "description": "Enable gzip compression on the request side.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "healthcheck": {
          "name": "healthcheck",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to enable healthchecks.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "id": {
          "name": "id",
          "type": "string",
          "kind": "scalar",
          "description": "The ID for indexed messages. Interpolation should be used in order to create a unique ID for each message.",
          "required": true,
          "default": "${!counter()}-${!timestamp_unix()}"
        },
        "index": {
          "name": "index",
          "type": "string",
          "kind": "scalar",
          "description": "The index to place messages.",
          "required": true,
          "default": null
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "max_retries": {
          "name": "max_retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retries before giving up on the request. If set to zero there is no discrete limit.",
          "required": true,
          "default": 0,
          "advanced": true
        },
        "pipeline": {
          "name": "pipeline",
          "type": "string",
          "kind": "scalar",
          "description": "An optional pipeline id to preprocess incoming documents.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "retry_on_conflict": {
          "name": "retry_on_conflict",
          "type": "int",
          "kind": "scalar",
          "description": "When using the update or upsert action, retry_on_conflict can be used to specify how many times an update should be retried in the case of a version conflict.",
          "required": true,
          "default": 0,
          "advanced": true
        },
        "routing": {
          "name": "routing",
          "type": "string",
          "kind": "scalar",
          "description": "The routing key to use for the document.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "sniff": {
          "name": "sniff",
          "type": "bool",
          "kind": "scalar",
          "description": "Prompts Redpanda Connect to sniff for brokers to connect to when establishing a connection.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum time to wait before abandoning a request (and trying again).",
          "required": true,
          "default": "5s",
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "type": {
          "name": "type",
          "type": "string",
          "kind": "scalar",
          "description": "The document mapping type. This field is required for versions of elasticsearch earlier than 6.0.0, but are invalid for versions 7.0.0 or later.",
          "required": true,
          "default": ""
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "http://localhost:9200"
            ]
          ]
        }
      }
    },
    "elasticsearch_v8": {
      "name": "elasticsearch_v8",
      "type": "output",
      "source": "upstream",
      "summary": "Publishes messages into an Elasticsearch index. If the index does not exist then it is created with a dynamic mapping.",
      "description": "\nBoth the `id` and `index` fields can be dynamically set using function interpolations described xref:configuration:interpolation.adoc#bloblang-queries[here]. When sending batched messages these interpolations are performed per message part.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "action": {
          "name": "action",
          "type": "string",
          "kind": "scalar",
          "description": "The action to take on the document. This field must resolve to one of the following action types: `index`, `update` or `delete`. See the `Updating Documents` example for more on how the `update` action works.",
          "required": true,
          "default": null
        },
        "basic_auth": {
          "name": "basic_auth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify basic authentication.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use basic authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "A username to authenticate as.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A password to authenticate with.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "id": {
          "name": "id",
          "type": "string",
          "kind": "scalar",
          "description": "The ID for indexed messages. Interpolation should be used in order to create a unique ID for each message.",
          "required": true,
          "default": null,
          "examples": [
            "${!counter()}-${!timestamp_unix()}"
          ]
        },
        "index": {
          "name": "index",
          "type": "string",
          "kind": "scalar",
          "description": "The index to place messages.",
          "required": true,
          "default": null
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "pipeline": {
          "name": "pipeline",
          "type": "string",
          "kind": "scalar",
          "description": "An optional pipeline id to preprocess incoming documents.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "retry_on_conflict": {
          "name": "retry_on_conflict",
          "type": "int",
          "kind": "scalar",
          "description": "Specify how many times should an update operation be retried when a conflict occurs",
          "required": true,
          "default": 0,
          "advanced": true
        },
        "routing": {
          "name": "routing",
          "type": "string",
          "kind": "scalar",
          "description": "The routing key to use for the document.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "http://localhost:9200"
            ]
          ]
        }
      }
    },
    "fallback": {
      "name": "fallback",
      "type": "output",
      "source": "upstream",
      "summary": "Attempts to send each message to a child output, starting from the first output on the list. If an output attempt fails then the next output in the list is attempted, and so on.",
      "description": "\nThis pattern is useful for triggering events in the case where certain output targets have broken. For example, if you had an output type `http_client` but wished to reroute messages whenever the endpoint becomes unreachable you could use this pattern:\n\n```yaml\noutput:\n  fallback:\n    - http_client:\n        url: http://foo:4195/post/might/become/unreachable\n        retries: 3\n        retry_period: 1s\n    - http_client:\n        url: http://bar:4196/somewhere/else\n        retries: 3\n        retry_period: 1s\n      processors:\n        - mapping: 'root = \"failed to send this message to foo: \" + content()'\n    - file:\n        path: /usr/local/benthos/everything_failed.jsonl\n```\n\n== Metadata\n\nWhen a given output fails the message routed to the following output will have a metadata value named `fallback_error` containing a string error message outlining the cause of the failure. The content of this string will depend on the particular output and can be used to enrich the message or provide information used to broker the data to an appropriate output using something like a `switch` output.\n\n== Batching\n\nWhen an output within a fallback sequence uses batching, like so:\n\n```yaml\noutput:\n  fallback:\n    - aws_dynamodb:\n        table: foo\n        string_columns:\n          id: ${!json(\"id\")}\n          content: ${!content()}\n        batching:\n          count: 10\n          period: 1s\n    - file:\n        path: /usr/local/benthos/failed_stuff.jsonl\n```\n\nRedpanda Connect makes a best attempt at inferring which specific messages of the batch failed, and only propagates those individual messages to the next fallback tier.\n\nHowever, depending on the output and the error returned it is sometimes not possible to determine the individual messages that failed, in which case the whole batch is passed to the next tier in order to preserve at-least-once delivery guarantees.",
      "config": {}
    },
    "file": {
      "name": "file",
      "type": "output",
      "source": "upstream",
      "summary": "Writes messages to files on disk based on a chosen codec.",
      "description": "Messages can be written to different files by using xref:configuration:interpolation.adoc#bloblang-queries[interpolation functions] in the path field. However, only one file is ever open at a given time, and therefore when the path changes the previously open file is closed.",
      "config": {
        "codec": {
          "name": "codec",
          "type": "string",
          "kind": "scalar",
          "description": "The way in which the bytes of messages should be written out into the output data stream. It's possible to write lines using a custom delimiter with the `delim:x` codec, where x is the character sequence custom delimiter.",
          "required": true,
          "default": "lines",
          "examples": [
            "lines",
            "delim:\t",
            "delim:foobar"
          ]
        },
        "path": {
          "name": "path",
          "type": "string",
          "kind": "scalar",
          "description": "The file to write to, if the file does not yet exist it will be created.",
          "required": true,
          "default": null,
          "examples": [
            "/tmp/data.txt",
            "/tmp/${! timestamp_unix() }.txt",
            "/tmp/${! json(\"document.id\") }.json"
          ]
        }
      }
    },
    "gcp_bigquery": {
      "name": "gcp_bigquery",
      "type": "output",
      "source": "upstream",
      "summary": "Sends messages as new rows to a Google Cloud BigQuery table.",
      "description": "\n== Credentials\n\nBy default Redpanda Connect will use a shared credentials file when connecting to GCP services. You can find out more in xref:guides:cloud/gcp.adoc[].\n\n== Format\n\nThis output currently supports only CSV, NEWLINE_DELIMITED_JSON and PARQUET, formats. Learn more about how to use GCP BigQuery with them here:\n\n- https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json[`NEWLINE_DELIMITED_JSON`^]\n- https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv[`CSV`^]\n- https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet[`PARQUET`^]\n\nEach message may contain multiple elements separated by newlines. For example a single message containing:\n\n```json\n{\"key\": \"1\"}\n{\"key\": \"2\"}\n```\n\nIs equivalent to two separate messages:\n\n```json\n{\"key\": \"1\"}\n```\n\nAnd:\n\n```json\n{\"key\": \"2\"}\n```\n\nThe same is true for the CSV format.\n\n=== CSV\n\nFor the CSV format when the field `csv.header` is specified a header row will be inserted as the first line of each message batch. If this field is not provided then the first message of each message batch must include a header line.\n\n=== Parquet\n\nFor parquet, the data can be encoded using the `parquet_encode` processor and each message that is sent to the output must be a full parquet message.\n\n\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "auto_detect": {
          "name": "auto_detect",
          "type": "bool",
          "kind": "scalar",
          "description": "Indicates if we should automatically infer the options and schema for CSV and JSON sources. If the table doesn't exist and this field is set to `false` the output may not be able to insert data and will throw insertion error. Be careful using this field since it delegates to the GCP BigQuery service the schema detection and values like `\"no\"` may be treated as booleans for the CSV format.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "create_disposition": {
          "name": "create_disposition",
          "type": "string",
          "kind": "scalar",
          "description": "Specifies the circumstances under which destination table will be created. If CREATE_IF_NEEDED is used the GCP BigQuery will create the table if it does not already exist and tables are created atomically on successful completion of a job. The CREATE_NEVER option ensures the table must already exist and will not be automatically created.",
          "required": true,
          "default": "CREATE_IF_NEEDED",
          "options": [
            "CREATE_IF_NEEDED",
            "CREATE_NEVER"
          ],
          "advanced": true
        },
        "credentials_json": {
          "name": "credentials_json",
          "type": "string",
          "kind": "scalar",
          "description": "An optional field to set Google Service Account Credentials json.",
          "required": true,
          "default": ""
        },
        "csv": {
          "name": "csv",
          "type": "object",
          "kind": "scalar",
          "description": "Specify how CSV data should be interpretted.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "header",
              "type": "string",
              "kind": "array",
              "description": "A list of values to use as header for each batch of messages. If not specified the first line of each message will be used as header.",
              "required": true,
              "default": []
            },
            {
              "name": "field_delimiter",
              "type": "string",
              "kind": "scalar",
              "description": "The separator for fields in a CSV file, used when reading or exporting data.",
              "required": true,
              "default": ","
            },
            {
              "name": "allow_jagged_rows",
              "type": "bool",
              "kind": "scalar",
              "description": "Causes missing trailing optional columns to be tolerated when reading CSV data. Missing values are treated as nulls.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "allow_quoted_newlines",
              "type": "bool",
              "kind": "scalar",
              "description": "Sets whether quoted data sections containing newlines are allowed when reading CSV data.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "encoding",
              "type": "string",
              "kind": "scalar",
              "description": "Encoding is the character encoding of data to be read.",
              "required": true,
              "default": "UTF-8",
              "options": [
                "UTF-8",
                "ISO-8859-1"
              ],
              "advanced": true
            },
            {
              "name": "skip_leading_rows",
              "type": "int",
              "kind": "scalar",
              "description": "The number of rows at the top of a CSV file that BigQuery will skip when reading data. The default value is 1 since Redpanda Connect will add the specified header in the first line of each batch sent to BigQuery.",
              "required": true,
              "default": 1,
              "advanced": true
            }
          ]
        },
        "dataset": {
          "name": "dataset",
          "type": "string",
          "kind": "scalar",
          "description": "The BigQuery Dataset ID.",
          "required": true,
          "default": null
        },
        "format": {
          "name": "format",
          "type": "string",
          "kind": "scalar",
          "description": "The format of each incoming message.",
          "required": true,
          "default": "NEWLINE_DELIMITED_JSON",
          "options": [
            "NEWLINE_DELIMITED_JSON",
            "CSV",
            "PARQUET"
          ]
        },
        "ignore_unknown_values": {
          "name": "ignore_unknown_values",
          "type": "bool",
          "kind": "scalar",
          "description": "Causes values not matching the schema to be tolerated. Unknown values are ignored. For CSV this ignores extra values at the end of a line. For JSON this ignores named values that do not match any column name. If this field is set to false (the default value), records containing unknown values are treated as bad records. The max_bad_records field can be used to customize how bad records are handled.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "job_labels": {
          "name": "job_labels",
          "type": "string",
          "kind": "map",
          "description": "A list of labels to add to the load job.",
          "required": true,
          "default": {}
        },
        "job_project": {
          "name": "job_project",
          "type": "string",
          "kind": "scalar",
          "description": "The project ID in which jobs will be exectuted. If not set, project will be used.",
          "required": true,
          "default": ""
        },
        "max_bad_records": {
          "name": "max_bad_records",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of bad records that will be ignored when reading data.",
          "required": true,
          "default": 0,
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of message batches to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "project": {
          "name": "project",
          "type": "string",
          "kind": "scalar",
          "description": "The project ID of the dataset to insert data to. If not set, it will be inferred from the credentials or read from the GOOGLE_CLOUD_PROJECT environment variable.",
          "required": true,
          "default": ""
        },
        "table": {
          "name": "table",
          "type": "string",
          "kind": "scalar",
          "description": "The table to insert messages to.",
          "required": true,
          "default": null
        },
        "write_disposition": {
          "name": "write_disposition",
          "type": "string",
          "kind": "scalar",
          "description": "Specifies how existing data in a destination table is treated.",
          "required": true,
          "default": "WRITE_APPEND",
          "options": [
            "WRITE_APPEND",
            "WRITE_EMPTY",
            "WRITE_TRUNCATE"
          ],
          "advanced": true
        }
      }
    },
    "gcp_cloud_storage": {
      "name": "gcp_cloud_storage",
      "type": "output",
      "source": "upstream",
      "summary": "Sends message parts as objects to a Google Cloud Storage bucket. Each object is uploaded with the path specified with the `path` field.",
      "description": "\nIn order to have a different path for each object you should use function interpolations described in xref:configuration:interpolation.adoc#bloblang-queries[Bloblang queries], which are calculated per message of a batch.\n\n== Metadata\n\nMetadata fields on messages will be sent as headers, in order to mutate these values (or remove them) check out the xref:configuration:metadata.adoc[metadata docs].\n\n== Credentials\n\nBy default Redpanda Connect will use a shared credentials file when connecting to GCP services. You can find out more in xref:guides:cloud/gcp.adoc[].\n\n== Batching\n\nIt's common to want to upload messages to Google Cloud Storage as batched archives, the easiest way to do this is to batch your messages at the output level and join the batch of messages with an xref:components:processors/archive.adoc[`archive`] and/or xref:components:processors/compress.adoc[`compress`] processor.\n\nFor example, if we wished to upload messages as a .tar.gz archive of documents we could achieve that with the following config:\n\n```yaml\noutput:\n  gcp_cloud_storage:\n    bucket: TODO\n    path: ${!counter()}-${!timestamp_unix_nano()}.tar.gz\n    batching:\n      count: 100\n      period: 10s\n      processors:\n        - archive:\n            format: tar\n        - compress:\n            algorithm: gzip\n```\n\nAlternatively, if we wished to upload JSON documents as a single large document containing an array of objects we can do that with:\n\n```yaml\noutput:\n  gcp_cloud_storage:\n    bucket: TODO\n    path: ${!counter()}-${!timestamp_unix_nano()}.json\n    batching:\n      count: 100\n      processors:\n        - archive:\n            format: json_array\n```\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "bucket": {
          "name": "bucket",
          "type": "string",
          "kind": "scalar",
          "description": "The bucket to upload messages to.",
          "required": true,
          "default": null
        },
        "chunk_size": {
          "name": "chunk_size",
          "type": "int",
          "kind": "scalar",
          "description": "An optional chunk size which controls the maximum number of bytes of the object that the Writer will attempt to send to the server in a single request. If ChunkSize is set to zero, chunking will be disabled.",
          "required": true,
          "default": 16777216,
          "advanced": true
        },
        "collision_mode": {
          "name": "collision_mode",
          "type": "string",
          "kind": "scalar",
          "description": "Determines how file path collisions should be dealt with.",
          "required": true,
          "default": "overwrite"
        },
        "content_encoding": {
          "name": "content_encoding",
          "type": "string",
          "kind": "scalar",
          "description": "An optional content encoding to set for each object.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "content_type": {
          "name": "content_type",
          "type": "string",
          "kind": "scalar",
          "description": "The content type to set for each object.",
          "required": true,
          "default": "application/octet-stream"
        },
        "credentials_json": {
          "name": "credentials_json",
          "type": "string",
          "kind": "scalar",
          "description": "An optional field to set Google Service Account Credentials json.",
          "required": true,
          "default": ""
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of message batches to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "path": {
          "name": "path",
          "type": "string",
          "kind": "scalar",
          "description": "The path of each message to upload.",
          "required": true,
          "default": "${!counter()}-${!timestamp_unix_nano()}.txt",
          "examples": [
            "${!counter()}-${!timestamp_unix_nano()}.txt",
            "${!meta(\"kafka_key\")}.json",
            "${!json(\"doc.namespace\")}/${!json(\"doc.id\")}.json"
          ]
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum period to wait on an upload before abandoning it and reattempting.",
          "required": true,
          "default": "3s",
          "examples": [
            "1s",
            "500ms"
          ]
        }
      }
    },
    "gcp_pubsub": {
      "name": "gcp_pubsub",
      "type": "output",
      "source": "upstream",
      "summary": "Sends messages to a GCP Cloud Pub/Sub topic. xref:configuration:metadata.adoc[Metadata] from messages are sent as attributes.",
      "description": "\nFor information on how to set up credentials, see https://cloud.google.com/docs/authentication/production[this guide^].\n\n== Troubleshooting\n\nIf you're consistently seeing `Failed to send message to gcp_pubsub: context deadline exceeded` error logs without any further information it is possible that you are encountering https://github.com/benthosdev/benthos/issues/1042, which occurs when metadata values contain characters that are not valid utf-8. This can frequently occur when consuming from Kafka as the key metadata field may be populated with an arbitrary binary value, but this issue is not exclusive to Kafka.\n\nIf you are blocked by this issue then a work around is to delete either the specific problematic keys:\n\n```yaml\npipeline:\n  processors:\n    - mapping: |\n        meta kafka_key = deleted()\n```\n\nOr delete all keys with:\n\n```yaml\npipeline:\n  processors:\n    - mapping: meta = deleted()\n```",
      "config": {
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "Configures a batching policy on this output. While the PubSub client maintains its own internal buffering mechanism, preparing larger batches of messages can further trade-off some latency for throughput.",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "byte_threshold": {
          "name": "byte_threshold",
          "type": "int",
          "kind": "scalar",
          "description": "Publish a batch when its size in bytes reaches this value.",
          "required": true,
          "default": 1000000
        },
        "count_threshold": {
          "name": "count_threshold",
          "type": "int",
          "kind": "scalar",
          "description": "Publish a pubsub buffer when it has this many messages",
          "required": true,
          "default": 100
        },
        "credentials_json": {
          "name": "credentials_json",
          "type": "string",
          "kind": "scalar",
          "description": "An optional field to set Google Service Account Credentials json.",
          "required": true,
          "default": ""
        },
        "delay_threshold": {
          "name": "delay_threshold",
          "type": "string",
          "kind": "scalar",
          "description": "Publish a non-empty pubsub buffer after this delay has passed.",
          "required": true,
          "default": "10ms"
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "An optional endpoint to override the default of `pubsub.googleapis.com:443`. This can be used to connect to a region specific pubsub endpoint. For a list of valid values, see https://cloud.google.com/pubsub/docs/reference/service_apis_overview#list_of_regional_endpoints[this document^].",
          "required": true,
          "default": "",
          "examples": [
            "us-central1-pubsub.googleapis.com:443",
            "us-west3-pubsub.googleapis.com:443"
          ]
        },
        "flow_control": {
          "name": "flow_control",
          "type": "object",
          "kind": "scalar",
          "description": "For a given topic, configures the PubSub client's internal buffer for messages to be published.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "max_outstanding_bytes",
              "type": "int",
              "kind": "scalar",
              "description": "Maximum size of buffered messages to be published. If less than or equal to zero, this is disabled.",
              "required": true,
              "default": -1,
              "advanced": true
            },
            {
              "name": "max_outstanding_messages",
              "type": "int",
              "kind": "scalar",
              "description": "Maximum number of buffered messages to be published. If less than or equal to zero, this is disabled.",
              "required": true,
              "default": 1000,
              "advanced": true
            },
            {
              "name": "limit_exceeded_behavior",
              "type": "string",
              "kind": "scalar",
              "description": "Configures the behavior when trying to publish additional messages while the flow controller is full. The available options are block (default), ignore (disable), and signal_error (publish results will return an error).",
              "required": true,
              "default": "block",
              "options": [
                "ignore",
                "block",
                "signal_error"
              ],
              "advanced": true
            }
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increasing this may improve throughput.",
          "required": true,
          "default": 64
        },
        "metadata": {
          "name": "metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Specify criteria for which metadata values are sent as attributes, all are sent by default.",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "exclude_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to be excluded when adding metadata to sent messages.",
              "required": true,
              "default": []
            }
          ]
        },
        "ordering_key": {
          "name": "ordering_key",
          "type": "string",
          "kind": "scalar",
          "description": "The ordering key to use for publishing messages.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "project": {
          "name": "project",
          "type": "string",
          "kind": "scalar",
          "description": "The project ID of the topic to publish to.",
          "required": true,
          "default": null
        },
        "publish_timeout": {
          "name": "publish_timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum length of time to wait before abandoning a publish attempt for a message.",
          "required": true,
          "default": "1m0s",
          "examples": [
            "10s",
            "5m",
            "60m"
          ],
          "advanced": true
        },
        "topic": {
          "name": "topic",
          "type": "string",
          "kind": "scalar",
          "description": "The topic to publish to.",
          "required": true,
          "default": null
        }
      }
    },
    "hdfs": {
      "name": "hdfs",
      "type": "output",
      "source": "upstream",
      "summary": "Sends message parts as files to a HDFS directory.",
      "description": "Each file is written with the path specified with the 'path' field, in order to have a different path for each object you should use function interpolations described xref:configuration:interpolation.adoc#bloblang-queries[here].\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.",
      "config": {
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "directory": {
          "name": "directory",
          "type": "string",
          "kind": "scalar",
          "description": "A directory to store message files within. If the directory does not exist it will be created.",
          "required": true,
          "default": null
        },
        "hosts": {
          "name": "hosts",
          "type": "string",
          "kind": "array",
          "description": "A list of target host addresses to connect to.",
          "required": true,
          "default": null,
          "examples": [
            "localhost:9000"
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "path": {
          "name": "path",
          "type": "string",
          "kind": "scalar",
          "description": "The path to upload messages as, interpolation functions should be used in order to generate unique file paths.",
          "required": true,
          "default": "${!counter()}-${!timestamp_unix_nano()}.txt"
        },
        "user": {
          "name": "user",
          "type": "string",
          "kind": "scalar",
          "description": "A user ID to connect as.",
          "required": true,
          "default": ""
        }
      }
    },
    "http_client": {
      "name": "http_client",
      "type": "output",
      "source": "upstream",
      "summary": "Sends messages to an HTTP server.",
      "description": "\nWhen the number of retries expires the output will reject the message, the behavior after this will depend on the pipeline but usually this simply means the send is attempted again until successful whilst applying back pressure.\n\nThe URL and header values of this type can be dynamically set using function interpolations described in xref:configuration:interpolation.adoc#bloblang-queries[Bloblang queries].\n\nThe body of the HTTP request is the raw contents of the message payload. If the message has multiple parts (is a batch) the request will be sent according to https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html[RFC1341^]. This behavior can be disabled by setting the field \u003c\u003cbatch_as_multipart, `batch_as_multipart`\u003e\u003e to `false`.\n\n== Propagate responses\n\nIt's possible to propagate the response from each HTTP request back to the input source by setting `propagate_response` to `true`. Only inputs that support xref:guides:sync_responses.adoc[synchronous responses] are able to make use of these propagated responses.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "backoff_on": {
          "name": "backoff_on",
          "type": "int",
          "kind": "array",
          "description": "A list of status codes whereby the request should be considered to have failed and retries should be attempted, but the period between them should be increased gradually.",
          "required": true,
          "default": [
            429
          ],
          "advanced": true
        },
        "basic_auth": {
          "name": "basic_auth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify basic authentication.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use basic authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "A username to authenticate as.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A password to authenticate with.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "batch_as_multipart": {
          "name": "batch_as_multipart",
          "type": "bool",
          "kind": "scalar",
          "description": "Send message batches as a single request using https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html[RFC1341^]. If disabled messages in batches will be sent as individual requests.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "disable_http2": {
          "name": "disable_http2",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether or not to disable disable HTTP/2",
          "required": true,
          "default": false,
          "advanced": true
        },
        "drop_on": {
          "name": "drop_on",
          "type": "int",
          "kind": "array",
          "description": "A list of status codes whereby the request should be considered to have failed but retries should not be attempted. This is useful for preventing wasted retries for requests that will never succeed. Note that with these status codes the _request_ is dropped, but _message_ that caused the request will not be dropped.",
          "required": true,
          "default": [],
          "advanced": true
        },
        "dump_request_log_level": {
          "name": "dump_request_log_level",
          "type": "string",
          "kind": "scalar",
          "description": "EXPERIMENTAL: Optionally set a level at which the request and response payload of each request made will be logged.",
          "required": true,
          "default": "",
          "options": [
            "TRACE",
            "DEBUG",
            "INFO",
            "WARN",
            "ERROR",
            "FATAL",
            ""
          ],
          "advanced": true
        },
        "extract_headers": {
          "name": "extract_headers",
          "type": "object",
          "kind": "scalar",
          "description": "Specify which response headers should be added to resulting synchronous response messages as metadata. Header keys are lowercased before matching, so ensure that your patterns target lowercased versions of the header keys that you expect. This field is not applicable unless `propagate_response` is set to `true`.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "include_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  "foo_",
                  "bar_"
                ],
                [
                  "kafka_"
                ],
                [
                  "content-"
                ]
              ],
              "advanced": true
            },
            {
              "name": "include_patterns",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key regular expression (re2) patterns to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  ".*"
                ],
                [
                  "_timestamp_unix$"
                ]
              ],
              "advanced": true
            }
          ]
        },
        "follow_redirects": {
          "name": "follow_redirects",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether or not to transparently follow redirects, i.e. responses with 300-399 status codes. If disabled, the response message will contain the body, status, and headers from the redirect response and the processor will not make a request to the URL set in the Location header of the response.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "headers": {
          "name": "headers",
          "type": "string",
          "kind": "map",
          "description": "A map of headers to add to the request.",
          "required": true,
          "default": {},
          "examples": [
            {
              "Content-Type": "application/octet-stream",
              "traceparent": "${! tracing_span().traceparent }"
            }
          ]
        },
        "jwt": {
          "name": "jwt",
          "type": "object",
          "kind": "scalar",
          "description": "BETA: Allows you to specify JWT authentication.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use JWT authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "private_key_file",
              "type": "string",
              "kind": "scalar",
              "description": "A file with the PEM encoded via PKCS1 or PKCS8 as private key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "signing_method",
              "type": "string",
              "kind": "scalar",
              "description": "A method used to sign the token such as RS256, RS384, RS512 or EdDSA.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "claims",
              "type": "unknown",
              "kind": "map",
              "description": "A value used to identify the claims that issued the JWT.",
              "required": true,
              "default": {},
              "advanced": true
            },
            {
              "name": "headers",
              "type": "unknown",
              "kind": "map",
              "description": "Add optional key/value headers to the JWT.",
              "required": true,
              "default": {},
              "advanced": true
            }
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of parallel message batches to have in flight at any given time.",
          "required": true,
          "default": 64
        },
        "max_retry_backoff": {
          "name": "max_retry_backoff",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum period to wait between failed requests.",
          "required": true,
          "default": "300s",
          "advanced": true
        },
        "metadata": {
          "name": "metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Specify optional matching rules to determine which metadata keys should be added to the HTTP request as headers.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "include_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  "foo_",
                  "bar_"
                ],
                [
                  "kafka_"
                ],
                [
                  "content-"
                ]
              ],
              "advanced": true
            },
            {
              "name": "include_patterns",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key regular expression (re2) patterns to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  ".*"
                ],
                [
                  "_timestamp_unix$"
                ]
              ],
              "advanced": true
            }
          ]
        },
        "multipart": {
          "name": "multipart",
          "type": "object",
          "kind": "array",
          "description": "EXPERIMENTAL: Create explicit multipart HTTP requests by specifying an array of parts to add to the request, each part specified consists of content headers and a data field that can be populated dynamically. If this field is populated it will override the default request creation behavior.",
          "required": true,
          "default": [],
          "advanced": true,
          "children": [
            {
              "name": "content_type",
              "type": "string",
              "kind": "scalar",
              "description": "The content type of the individual message part.",
              "required": true,
              "default": "",
              "examples": [
                "application/bin"
              ],
              "advanced": true
            },
            {
              "name": "content_disposition",
              "type": "string",
              "kind": "scalar",
              "description": "The content disposition of the individual message part.",
              "required": true,
              "default": "",
              "examples": [
                "form-data; name=\"bin\"; filename='${! @AttachmentName }"
              ],
              "advanced": true
            },
            {
              "name": "body",
              "type": "string",
              "kind": "scalar",
              "description": "The body of the individual message part.",
              "required": true,
              "default": "",
              "examples": [
                "${! this.data.part1 }"
              ],
              "advanced": true
            }
          ]
        },
        "oauth": {
          "name": "oauth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify open authentication via OAuth version 1.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use OAuth version 1 in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "consumer_key",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to identify the client to the service provider.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "consumer_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret used to establish ownership of the consumer key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "access_token",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to gain access to the protected resources on behalf of the user.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "access_token_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret provided in order to establish ownership of a given access token.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "oauth2": {
          "name": "oauth2",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify open authentication via OAuth version 2 using the client credentials token flow.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use OAuth version 2 in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "client_key",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to identify the client to the token provider.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "client_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret used to establish ownership of the client key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token_url",
              "type": "string",
              "kind": "scalar",
              "description": "The URL of the token provider.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "scopes",
              "type": "string",
              "kind": "array",
              "description": "A list of optional requested permissions.",
              "required": true,
              "default": [],
              "advanced": true
            },
            {
              "name": "endpoint_params",
              "type": "unknown",
              "kind": "map",
              "description": "A list of optional endpoint parameters, values should be arrays of strings.",
              "required": false,
              "default": {},
              "examples": [
                {
                  "bar": [
                    "woof"
                  ],
                  "foo": [
                    "meow",
                    "quack"
                  ]
                }
              ],
              "advanced": true
            }
          ]
        },
        "propagate_response": {
          "name": "propagate_response",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether responses from the server should be xref:guides:sync_responses.adoc[propagated back] to the input.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "proxy_url": {
          "name": "proxy_url",
          "type": "string",
          "kind": "scalar",
          "description": "An optional HTTP proxy URL.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "rate_limit": {
          "name": "rate_limit",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:components:rate_limits/about.adoc[rate limit] to throttle requests by.",
          "required": false,
          "default": null
        },
        "retries": {
          "name": "retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retry attempts to make.",
          "required": true,
          "default": 3,
          "advanced": true
        },
        "retry_period": {
          "name": "retry_period",
          "type": "string",
          "kind": "scalar",
          "description": "The base period to wait between failed requests.",
          "required": true,
          "default": "1s",
          "advanced": true
        },
        "successful_on": {
          "name": "successful_on",
          "type": "int",
          "kind": "array",
          "description": "A list of status codes whereby the attempt should be considered successful, this is useful for dropping requests that return non-2XX codes indicating that the message has been dealt with, such as a 303 See Other or a 409 Conflict. All 2XX codes are considered successful unless they are present within `backoff_on` or `drop_on`, regardless of this field.",
          "required": true,
          "default": [],
          "advanced": true
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "A static timeout to apply to requests.",
          "required": true,
          "default": "5s"
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL to connect to.",
          "required": true,
          "default": null
        },
        "verb": {
          "name": "verb",
          "type": "string",
          "kind": "scalar",
          "description": "A verb to connect with",
          "required": true,
          "default": "POST",
          "examples": [
            "POST",
            "GET",
            "DELETE"
          ]
        }
      }
    },
    "http_server": {
      "name": "http_server",
      "type": "output",
      "source": "upstream",
      "summary": "Sets up an HTTP server that will send messages over HTTP(S) GET requests. HTTP 2.0 is supported when using TLS, which is enabled when key and cert files are specified.",
      "description": "Sets up an HTTP server that will send messages over HTTP(S) GET requests. If the `address` config field is left blank the xref:components:http/about.adoc[service-wide HTTP server] will be used.\n\nThree endpoints will be registered at the paths specified by the fields `path`, `stream_path` and `ws_path`. Which allow you to consume a single message batch, a continuous stream of line delimited messages, or a websocket of messages for each request respectively.\n\nWhen messages are batched the `path` endpoint encodes the batch according to https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html[RFC1341^]. This behavior can be overridden by xref:configuration:batching.adoc#post-batch-processing[archiving your batches].\n\nPlease note, messages are considered delivered as soon as the data is written to the client. There is no concept of at least once delivery on this output.\n\n\n[CAUTION]\n.Endpoint caveats\n====\nComponents within a Redpanda Connect config will register their respective endpoints in a non-deterministic order. This means that establishing precedence of endpoints that are registered via multiple `http_server` inputs or outputs (either within brokers or from cohabiting streams) is not possible in a predictable way.\n\nThis ambiguity makes it difficult to ensure that paths which are both a subset of a path registered by a separate component, and end in a slash (`/`) and will therefore match against all extensions of that path, do not prevent the more specific path from matching against requests.\n\nIt is therefore recommended that you ensure paths of separate components do not collide unless they are explicitly non-competing.\n\nFor example, if you were to deploy two separate `http_server` inputs, one with a path `/foo/` and the other with a path `/foo/bar`, it would not be possible to ensure that the path `/foo/` does not swallow requests made to `/foo/bar`.\n====\n",
      "config": {
        "address": {
          "name": "address",
          "type": "string",
          "kind": "scalar",
          "description": "An alternative address to host from. If left empty the service wide address is used.",
          "required": true,
          "default": ""
        },
        "allowed_verbs": {
          "name": "allowed_verbs",
          "type": "string",
          "kind": "array",
          "description": "An array of verbs that are allowed for the `path` and `stream_path` HTTP endpoint.",
          "required": true,
          "default": [
            "GET"
          ]
        },
        "cert_file": {
          "name": "cert_file",
          "type": "string",
          "kind": "scalar",
          "description": "Enable TLS by specifying a certificate and key file. Only valid with a custom `address`.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "cors": {
          "name": "cors",
          "type": "object",
          "kind": "scalar",
          "description": "Adds Cross-Origin Resource Sharing headers. Only valid with a custom `address`.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow CORS requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "allowed_origins",
              "type": "string",
              "kind": "array",
              "description": "An explicit list of origins that are allowed for CORS requests.",
              "required": true,
              "default": [],
              "advanced": true
            }
          ]
        },
        "key_file": {
          "name": "key_file",
          "type": "string",
          "kind": "scalar",
          "description": "Enable TLS by specifying a certificate and key file. Only valid with a custom `address`.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "path": {
          "name": "path",
          "type": "string",
          "kind": "scalar",
          "description": "The path from which discrete messages can be consumed.",
          "required": true,
          "default": "/get"
        },
        "stream_path": {
          "name": "stream_path",
          "type": "string",
          "kind": "scalar",
          "description": "The path from which a continuous stream of messages can be consumed.",
          "required": true,
          "default": "/get/stream"
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum time to wait before a blocking, inactive connection is dropped (only applies to the `path` endpoint).",
          "required": true,
          "default": "5s",
          "advanced": true
        },
        "ws_path": {
          "name": "ws_path",
          "type": "string",
          "kind": "scalar",
          "description": "The path from which websocket connections can be established.",
          "required": true,
          "default": "/get/ws"
        }
      }
    },
    "inproc": {
      "name": "inproc",
      "type": "output",
      "source": "upstream",
      "summary": "",
      "description": "\nSends data directly to Redpanda Connect inputs by connecting to a unique ID. This allows you to hook up isolated streams whilst running Redpanda Connect in xref:guides:streams_mode/about.adoc[streams mode], it is NOT recommended that you connect the inputs of a stream with an output of the same stream, as feedback loops can lead to deadlocks in your message flow.\n\nIt is possible to connect multiple inputs to the same inproc ID, resulting in messages dispatching in a round-robin fashion to connected inputs. However, only one output can assume an inproc ID, and will replace existing outputs if a collision occurs.",
      "config": {}
    },
    "kafka": {
      "name": "kafka",
      "type": "output",
      "source": "upstream",
      "summary": "The kafka output type writes a batch of messages to Kafka brokers and waits for acknowledgement before propagating it back to the input.",
      "description": "\nThe config field `ack_replicas` determines whether we wait for acknowledgement from all replicas or just a single broker.\n\nBoth the `key` and `topic` fields can be dynamically set using function interpolations described in xref:configuration:interpolation.adoc#bloblang-queries[Bloblang queries].\n\nxref:configuration:metadata.adoc[Metadata] will be added to each message sent as headers (version 0.11+), but can be restricted using the field \u003c\u003cmetadata, `metadata`\u003e\u003e.\n\n== Strict ordering and retries\n\nWhen strict ordering is required for messages written to topic partitions it is important to ensure that both the field `max_in_flight` is set to `1` and that the field `retry_as_batch` is set to `true`.\n\nYou must also ensure that failed batches are never rerouted back to the same output. This can be done by setting the field `max_retries` to `0` and `backoff.max_elapsed_time` to empty, which will apply back pressure indefinitely until the batch is sent successfully.\n\nHowever, this also means that manual intervention will eventually be required in cases where the batch cannot be sent due to configuration problems such as an incorrect `max_msg_bytes` estimate. A less strict but automated alternative would be to route failed batches to a dead letter queue using a xref:components:outputs/fallback.adoc[`fallback` broker], but this would allow subsequent batches to be delivered in the meantime whilst those failed batches are dealt with.\n\n== Troubleshooting\n\nIf you're seeing issues writing to or reading from Kafka with this component then it's worth trying out the newer xref:components:outputs/kafka_franz.adoc[`kafka_franz` output].\n\n- I'm seeing logs that report `Failed to connect to kafka: kafka: client has run out of available brokers to talk to (Is your cluster reachable?)`, but the brokers are definitely reachable.\n\nUnfortunately this error message will appear for a wide range of connection problems even when the broker endpoint can be reached. Double check your authentication configuration and also ensure that you have \u003c\u003ctlsenabled, enabled TLS\u003e\u003e if applicable.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "ack_replicas": {
          "name": "ack_replicas",
          "type": "bool",
          "kind": "scalar",
          "description": "Ensure that messages have been copied across all replicas before acknowledging receipt.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "addresses": {
          "name": "addresses",
          "type": "string",
          "kind": "array",
          "description": "A list of broker addresses to connect to. If an item of the list contains commas it will be expanded into multiple addresses.",
          "required": true,
          "default": null,
          "examples": [
            [
              "localhost:9092"
            ],
            [
              "localhost:9041,localhost:9042"
            ],
            [
              "localhost:9041",
              "localhost:9042"
            ]
          ]
        },
        "backoff": {
          "name": "backoff",
          "type": "object",
          "kind": "scalar",
          "description": "Control time intervals between retry attempts.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "initial_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The initial period to wait between retry attempts.",
              "required": true,
              "default": "3s",
              "examples": [
                "50ms",
                "1s"
              ],
              "advanced": true
            },
            {
              "name": "max_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait between retry attempts",
              "required": true,
              "default": "10s",
              "examples": [
                "5s",
                "1m"
              ],
              "advanced": true
            },
            {
              "name": "max_elapsed_time",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum overall period of time to spend on retry attempts before the request is aborted. Setting this value to a zeroed duration (such as `0s`) will result in unbounded retries.",
              "required": true,
              "default": "30s",
              "examples": [
                "1m",
                "1h"
              ],
              "advanced": true
            }
          ]
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "client_id": {
          "name": "client_id",
          "type": "string",
          "kind": "scalar",
          "description": "An identifier for the client connection.",
          "required": true,
          "default": "benthos",
          "advanced": true
        },
        "compression": {
          "name": "compression",
          "type": "string",
          "kind": "scalar",
          "description": "The compression algorithm to use.",
          "required": true,
          "default": "none",
          "options": [
            "none",
            "snappy",
            "lz4",
            "gzip",
            "zstd"
          ]
        },
        "custom_topic_creation": {
          "name": "custom_topic_creation",
          "type": "object",
          "kind": "scalar",
          "description": "If enabled, topics will be created with the specified number of partitions and replication factor if they do not already exist.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to enable custom topic creation.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "partitions",
              "type": "int",
              "kind": "scalar",
              "description": "The number of partitions to create for new topics. Leave at -1 to use the broker configured default. Must be \u003e= 1.",
              "required": true,
              "default": -1,
              "advanced": true
            },
            {
              "name": "replication_factor",
              "type": "int",
              "kind": "scalar",
              "description": "The replication factor to use for new topics. Leave at -1 to use the broker configured default. Must be an odd number, and less then or equal to the number of brokers.",
              "required": true,
              "default": -1,
              "advanced": true
            }
          ]
        },
        "idempotent_write": {
          "name": "idempotent_write",
          "type": "bool",
          "kind": "scalar",
          "description": "Enable the idempotent write producer option. This requires the `IDEMPOTENT_WRITE` permission on `CLUSTER` and can be disabled if this permission is not available.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "inject_tracing_map": {
          "name": "inject_tracing_map",
          "type": "string",
          "kind": "scalar",
          "description": "EXPERIMENTAL: A xref:guides:bloblang/about.adoc[Bloblang mapping] used to inject an object containing tracing propagation information into outbound messages. The specification of the injected fields will match the format used by the service wide tracer.",
          "required": false,
          "default": null,
          "examples": [
            "meta = @.merge(this)",
            "root.meta.span = this"
          ],
          "advanced": true
        },
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "The key to publish messages with.",
          "required": true,
          "default": ""
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "max_msg_bytes": {
          "name": "max_msg_bytes",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum size in bytes of messages sent to the target topic.",
          "required": true,
          "default": 1000000,
          "advanced": true
        },
        "max_retries": {
          "name": "max_retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retries before giving up on the request. If set to zero there is no discrete limit.",
          "required": true,
          "default": 0,
          "advanced": true
        },
        "metadata": {
          "name": "metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Specify criteria for which metadata values are sent with messages as headers.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "exclude_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to be excluded when adding metadata to sent messages.",
              "required": true,
              "default": []
            }
          ]
        },
        "partition": {
          "name": "partition",
          "type": "string",
          "kind": "scalar",
          "description": "The manually-specified partition to publish messages to, relevant only when the field `partitioner` is set to `manual`. Must be able to parse as a 32-bit integer.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "partitioner": {
          "name": "partitioner",
          "type": "string",
          "kind": "scalar",
          "description": "The partitioning algorithm to use.",
          "required": true,
          "default": "fnv1a_hash",
          "options": [
            "fnv1a_hash",
            "murmur2_hash",
            "random",
            "round_robin",
            "manual"
          ]
        },
        "rack_id": {
          "name": "rack_id",
          "type": "string",
          "kind": "scalar",
          "description": "A rack identifier for this client.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "retry_as_batch": {
          "name": "retry_as_batch",
          "type": "bool",
          "kind": "scalar",
          "description": "When enabled forces an entire batch of messages to be retried if any individual message fails on a send, otherwise only the individual messages that failed are retried. Disabling this helps to reduce message duplicates during intermittent errors, but also makes it impossible to guarantee strict ordering of messages.",
          "required": true,
          "default": false,
          "advanced": true
        },
        "sasl": {
          "name": "sasl",
          "type": "object",
          "kind": "scalar",
          "description": "Enables SASL authentication.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "mechanism",
              "type": "string",
              "kind": "scalar",
              "description": "The SASL authentication mechanism, if left empty SASL authentication is not used.",
              "required": true,
              "default": "none",
              "advanced": true
            },
            {
              "name": "user",
              "type": "string",
              "kind": "scalar",
              "description": "A PLAIN username. It is recommended that you use environment variables to populate this field.",
              "required": true,
              "default": "",
              "examples": [
                "${USER}"
              ],
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A PLAIN password. It is recommended that you use environment variables to populate this field.",
              "required": true,
              "default": "",
              "examples": [
                "${PASSWORD}"
              ],
              "advanced": true
            },
            {
              "name": "access_token",
              "type": "string",
              "kind": "scalar",
              "description": "A static OAUTHBEARER access token",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token_cache",
              "type": "string",
              "kind": "scalar",
              "description": "Instead of using a static `access_token` allows you to query a xref:components:caches/about.adoc[`cache`] resource to fetch OAUTHBEARER tokens from",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token_key",
              "type": "string",
              "kind": "scalar",
              "description": "Required when using a `token_cache`, the key to query the cache with for tokens.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "static_headers": {
          "name": "static_headers",
          "type": "string",
          "kind": "map",
          "description": "An optional map of static headers that should be added to messages in addition to metadata.",
          "required": false,
          "default": null,
          "examples": [
            {
              "first-static-header": "value-1",
              "second-static-header": "value-2"
            }
          ]
        },
        "target_version": {
          "name": "target_version",
          "type": "string",
          "kind": "scalar",
          "description": "The version of the Kafka protocol to use. This limits the capabilities used by the client and should ideally match the version of your brokers. Defaults to the oldest supported stable version.",
          "required": false,
          "default": null,
          "examples": [
            "2.1.0",
            "3.1.0"
          ]
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum period of time to wait for message sends before abandoning the request and retrying.",
          "required": true,
          "default": "5s",
          "advanced": true
        },
        "timestamp": {
          "name": "timestamp",
          "type": "string",
          "kind": "scalar",
          "description": "An optional timestamp to set for each message. When left empty, the current timestamp is used.",
          "required": false,
          "default": null,
          "examples": [
            "${! timestamp_unix() }",
            "${! metadata(\"kafka_timestamp_unix\") }"
          ],
          "advanced": true
        },
        "timestamp_ms": {
          "name": "timestamp_ms",
          "type": "string",
          "kind": "scalar",
          "description": "An optional timestamp to set for each message expressed in milliseconds. When left empty, the current timestamp is used.",
          "required": false,
          "default": null,
          "examples": [
            "${! timestamp_unix_milli() }",
            "${! metadata(\"kafka_timestamp_ms\") }"
          ],
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "topic": {
          "name": "topic",
          "type": "string",
          "kind": "scalar",
          "description": "The topic to publish messages to.",
          "required": true,
          "default": null
        }
      }
    },
    "kafka_franz": {
      "name": "kafka_franz",
      "type": "output",
      "source": "upstream",
      "summary": "A Kafka output using the https://github.com/twmb/franz-go[Franz Kafka client library^].",
      "description": "\nWrites a batch of messages to Kafka brokers and waits for acknowledgement before propagating it back to the input.\n\nThis output often out-performs the traditional `kafka` output as well as providing more useful logs and error messages.\n",
      "config": {
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "broker_write_max_bytes": {
          "name": "broker_write_max_bytes",
          "type": "string",
          "kind": "scalar",
          "description": "The upper bound for the number of bytes written to a broker connection in a single write. This field corresponds to Kafka's `socket.request.max.bytes`.",
          "required": true,
          "default": "100MiB",
          "examples": [
            "128MB",
            "50mib"
          ],
          "advanced": true
        },
        "client_id": {
          "name": "client_id",
          "type": "string",
          "kind": "scalar",
          "description": "An identifier for the client connection.",
          "required": true,
          "default": "benthos",
          "advanced": true
        },
        "compression": {
          "name": "compression",
          "type": "string",
          "kind": "scalar",
          "description": "Optionally set an explicit compression type. The default preference is to use snappy when the broker supports it, and fall back to none if not.",
          "required": false,
          "default": null,
          "options": [
            "lz4",
            "snappy",
            "gzip",
            "none",
            "zstd"
          ],
          "advanced": true
        },
        "idempotent_write": {
          "name": "idempotent_write",
          "type": "bool",
          "kind": "scalar",
          "description": "Enable the idempotent write producer option. This requires the `IDEMPOTENT_WRITE` permission on `CLUSTER` and can be disabled if this permission is not available.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "An optional key to populate for each message.",
          "required": false,
          "default": null
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of batches to be sending in parallel at any given time.",
          "required": true,
          "default": 10
        },
        "max_message_bytes": {
          "name": "max_message_bytes",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum space in bytes than an individual message may take, messages larger than this value will be rejected. This field corresponds to Kafka's `max.message.bytes`.",
          "required": true,
          "default": "1MiB",
          "examples": [
            "100MB",
            "50mib"
          ],
          "advanced": true
        },
        "metadata": {
          "name": "metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Determine which (if any) metadata values should be added to messages as headers.",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "include_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  "foo_",
                  "bar_"
                ],
                [
                  "kafka_"
                ],
                [
                  "content-"
                ]
              ]
            },
            {
              "name": "include_patterns",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key regular expression (re2) patterns to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  ".*"
                ],
                [
                  "_timestamp_unix$"
                ]
              ]
            }
          ]
        },
        "metadata_max_age": {
          "name": "metadata_max_age",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum age of metadata before it is refreshed.",
          "required": true,
          "default": "5m",
          "advanced": true
        },
        "partition": {
          "name": "partition",
          "type": "string",
          "kind": "scalar",
          "description": "An optional explicit partition to set for each message. This field is only relevant when the `partitioner` is set to `manual`. The provided interpolation string must be a valid integer.",
          "required": false,
          "default": null,
          "examples": [
            "${! meta(\"partition\") }"
          ]
        },
        "partitioner": {
          "name": "partitioner",
          "type": "string",
          "kind": "scalar",
          "description": "Override the default murmur2 hashing partitioner.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "rack_id": {
          "name": "rack_id",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": null
        },
        "sasl": {
          "name": "sasl",
          "type": "object",
          "kind": "array",
          "description": "Specify one or more methods of SASL authentication. SASL is tried in order; if the broker supports the first mechanism, all connections will use that mechanism. If the first mechanism fails, the client will pick the first supported mechanism. If the broker does not support any client mechanisms, connections will fail.",
          "required": false,
          "default": null,
          "examples": [
            [
              {
                "mechanism": "SCRAM-SHA-512",
                "password": "bar",
                "username": "foo"
              }
            ]
          ],
          "advanced": true,
          "children": [
            {
              "name": "mechanism",
              "type": "string",
              "kind": "scalar",
              "description": "The SASL mechanism to use.",
              "required": true,
              "default": null,
              "advanced": true
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "A username to provide for PLAIN or SCRAM-* authentication.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A password to provide for PLAIN or SCRAM-* authentication.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token",
              "type": "string",
              "kind": "scalar",
              "description": "The token to use for a single session's OAUTHBEARER authentication.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "extensions",
              "type": "string",
              "kind": "map",
              "description": "Key/value pairs to add to OAUTHBEARER authentication requests.",
              "required": false,
              "default": null,
              "advanced": true
            },
            {
              "name": "aws",
              "type": "object",
              "kind": "scalar",
              "description": "Contains AWS specific fields for when the `mechanism` is set to `AWS_MSK_IAM`.",
              "required": false,
              "default": null,
              "advanced": true,
              "children": [
                {
                  "name": "region",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The AWS region to target.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "endpoint",
                  "type": "string",
                  "kind": "scalar",
                  "description": "Allows you to specify a custom endpoint for the AWS API.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "credentials",
                  "type": "object",
                  "kind": "scalar",
                  "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
                  "required": true,
                  "default": null,
                  "advanced": true,
                  "children": [
                    {
                      "name": "profile",
                      "type": "string",
                      "kind": "scalar",
                      "description": "A profile from `~/.aws/credentials` to use.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "id",
                      "type": "string",
                      "kind": "scalar",
                      "description": "The ID of credentials to use.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "secret",
                      "type": "string",
                      "kind": "scalar",
                      "description": "The secret for the credentials being used.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "token",
                      "type": "string",
                      "kind": "scalar",
                      "description": "The token for the credentials being used, required when using short term credentials.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "from_ec2_role",
                      "type": "bool",
                      "kind": "scalar",
                      "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
                      "required": true,
                      "default": false,
                      "advanced": true
                    },
                    {
                      "name": "role",
                      "type": "string",
                      "kind": "scalar",
                      "description": "A role ARN to assume.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "role_external_id",
                      "type": "string",
                      "kind": "scalar",
                      "description": "An external ID to provide when assuming a role.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        "seed_brokers": {
          "name": "seed_brokers",
          "type": "string",
          "kind": "array",
          "description": "A list of broker addresses to connect to in order to establish connections. If an item of the list contains commas it will be expanded into multiple addresses.",
          "required": true,
          "default": null,
          "examples": [
            [
              "localhost:9092"
            ],
            [
              "foo:9092",
              "bar:9092"
            ],
            [
              "foo:9092,bar:9092"
            ]
          ]
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum period of time to wait for message sends before abandoning the request and retrying",
          "required": true,
          "default": "10s",
          "advanced": true
        },
        "timestamp": {
          "name": "timestamp",
          "type": "string",
          "kind": "scalar",
          "description": "An optional timestamp to set for each message. When left empty, the current timestamp is used.",
          "required": false,
          "default": null,
          "examples": [
            "${! timestamp_unix() }",
            "${! metadata(\"kafka_timestamp_unix\") }"
          ],
          "advanced": true
        },
        "timestamp_ms": {
          "name": "timestamp_ms",
          "type": "string",
          "kind": "scalar",
          "description": "An optional timestamp to set for each message expressed in milliseconds. When left empty, the current timestamp is used.",
          "required": false,
          "default": null,
          "examples": [
            "${! timestamp_unix_milli() }",
            "${! metadata(\"kafka_timestamp_ms\") }"
          ],
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "topic": {
          "name": "topic",
          "type": "string",
          "kind": "scalar",
          "description": "A topic to write messages to.",
          "required": true,
          "default": null
        }
      }
    },
    "mongodb": {
      "name": "mongodb",
      "type": "output",
      "source": "upstream",
      "summary": "Inserts items into a MongoDB collection.",
      "description": "\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "app_name": {
          "name": "app_name",
          "type": "string",
          "kind": "scalar",
          "description": "The client application name.",
          "required": true,
          "default": "benthos",
          "advanced": true
        },
        "backoff": {
          "name": "backoff",
          "type": "object",
          "kind": "scalar",
          "description": "Control time intervals between retry attempts.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "initial_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The initial period to wait between retry attempts.",
              "required": true,
              "default": "1s",
              "advanced": true
            },
            {
              "name": "max_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait between retry attempts.",
              "required": true,
              "default": "5s",
              "advanced": true
            },
            {
              "name": "max_elapsed_time",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait before retry attempts are abandoned. If zero then no limit is used.",
              "required": true,
              "default": "30s",
              "advanced": true
            }
          ]
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "collection": {
          "name": "collection",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the target collection.",
          "required": true,
          "default": null
        },
        "database": {
          "name": "database",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the target MongoDB database.",
          "required": true,
          "default": null
        },
        "document_map": {
          "name": "document_map",
          "type": "string",
          "kind": "scalar",
          "description": "A bloblang map representing a document to store within MongoDB, expressed as https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/[extended JSON in canonical form^]. The document map is required for the operations insert-one, replace-one and update-one.",
          "required": true,
          "default": "",
          "examples": [
            "root.a = this.foo\nroot.b = this.bar"
          ]
        },
        "filter_map": {
          "name": "filter_map",
          "type": "string",
          "kind": "scalar",
          "description": "A bloblang map representing a filter for a MongoDB command, expressed as https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/[extended JSON in canonical form^]. The filter map is required for all operations except insert-one. It is used to find the document(s) for the operation. For example in a delete-one case, the filter map should have the fields required to locate the document to delete.",
          "required": true,
          "default": "",
          "examples": [
            "root.a = this.foo\nroot.b = this.bar"
          ]
        },
        "hint_map": {
          "name": "hint_map",
          "type": "string",
          "kind": "scalar",
          "description": "A bloblang map representing the hint for the MongoDB command, expressed as https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/[extended JSON in canonical form^]. This map is optional and is used with all operations except insert-one. It is used to improve performance of finding the documents in the mongodb.",
          "required": true,
          "default": "",
          "examples": [
            "root.a = this.foo\nroot.b = this.bar"
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "max_retries": {
          "name": "max_retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retries before giving up on the request. If set to zero there is no discrete limit.",
          "required": true,
          "default": 3,
          "advanced": true
        },
        "operation": {
          "name": "operation",
          "type": "string",
          "kind": "scalar",
          "description": "The mongodb operation to perform.",
          "required": true,
          "default": "update-one",
          "options": [
            "insert-one",
            "delete-one",
            "delete-many",
            "replace-one",
            "update-one"
          ]
        },
        "password": {
          "name": "password",
          "type": "string",
          "kind": "scalar",
          "description": "The password to connect to the database.",
          "required": true,
          "default": ""
        },
        "upsert": {
          "name": "upsert",
          "type": "bool",
          "kind": "scalar",
          "description": "The upsert setting is optional and only applies for update-one and replace-one operations. If the filter specified in filter_map matches, the document is updated or replaced accordingly, otherwise it is created.",
          "required": true,
          "default": false
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL of the target MongoDB server.",
          "required": true,
          "default": null,
          "examples": [
            "mongodb://localhost:27017"
          ]
        },
        "username": {
          "name": "username",
          "type": "string",
          "kind": "scalar",
          "description": "The username to connect to the database.",
          "required": true,
          "default": ""
        },
        "write_concern": {
          "name": "write_concern",
          "type": "object",
          "kind": "scalar",
          "description": "The write concern settings for the mongo connection.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "w",
              "type": "string",
              "kind": "scalar",
              "description": "W requests acknowledgement that write operations propagate to the specified number of mongodb instances. Can be the string \"majority\" to wait for a calculated majority of nodes to acknowledge the write operation, or an integer value specifying an minimum number of nodes to acknowledge the operation, or a string specifying the name of a custom write concern configured in the cluster.",
              "required": true,
              "default": "majority"
            },
            {
              "name": "j",
              "type": "bool",
              "kind": "scalar",
              "description": "J requests acknowledgement from MongoDB that write operations are written to the journal.",
              "required": true,
              "default": false
            },
            {
              "name": "w_timeout",
              "type": "string",
              "kind": "scalar",
              "description": "The write concern timeout.",
              "required": true,
              "default": ""
            }
          ]
        }
      }
    },
    "mqtt": {
      "name": "mqtt",
      "type": "output",
      "source": "upstream",
      "summary": "Pushes messages to an MQTT broker.",
      "description": "\nThe `topic` field can be dynamically set using function interpolations described xref:configuration:interpolation.adoc#bloblang-queries[here]. When sending batched messages these interpolations are performed per message part.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.",
      "config": {
        "client_id": {
          "name": "client_id",
          "type": "string",
          "kind": "scalar",
          "description": "An identifier for the client connection.",
          "required": true,
          "default": ""
        },
        "connect_timeout": {
          "name": "connect_timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum amount of time to wait in order to establish a connection before the attempt is abandoned.",
          "required": true,
          "default": "30s",
          "examples": [
            "1s",
            "500ms"
          ]
        },
        "dynamic_client_id_suffix": {
          "name": "dynamic_client_id_suffix",
          "type": "string",
          "kind": "scalar",
          "description": "Append a dynamically generated suffix to the specified `client_id` on each run of the pipeline. This can be useful when clustering Redpanda Connect producers.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "keepalive": {
          "name": "keepalive",
          "type": "int",
          "kind": "scalar",
          "description": "Max seconds of inactivity before a keepalive message is sent.",
          "required": true,
          "default": 30,
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "password": {
          "name": "password",
          "type": "string",
          "kind": "scalar",
          "description": "A password to connect with.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "qos": {
          "name": "qos",
          "type": "int",
          "kind": "scalar",
          "description": "The QoS value to set for each message. Has options 0, 1, 2.",
          "required": true,
          "default": 1
        },
        "retained": {
          "name": "retained",
          "type": "bool",
          "kind": "scalar",
          "description": "Set message as retained on the topic.",
          "required": true,
          "default": false
        },
        "retained_interpolated": {
          "name": "retained_interpolated",
          "type": "string",
          "kind": "scalar",
          "description": "Override the value of `retained` with an interpolable value, this allows it to be dynamically set based on message contents. The value must resolve to either `true` or `false`.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "topic": {
          "name": "topic",
          "type": "string",
          "kind": "scalar",
          "description": "The topic to publish messages to.",
          "required": true,
          "default": null
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. The format should be `scheme://host:port` where `scheme` is one of `tcp`, `ssl`, or `ws`, `host` is the ip-address (or hostname) and `port` is the port on which the broker is accepting connections. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "tcp://localhost:1883"
            ]
          ]
        },
        "user": {
          "name": "user",
          "type": "string",
          "kind": "scalar",
          "description": "A username to connect with.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "will": {
          "name": "will",
          "type": "object",
          "kind": "scalar",
          "description": "Set last will message in case of Redpanda Connect failure",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to enable last will messages.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "qos",
              "type": "int",
              "kind": "scalar",
              "description": "Set QoS for last will message. Valid values are: 0, 1, 2.",
              "required": true,
              "default": 0,
              "advanced": true
            },
            {
              "name": "retained",
              "type": "bool",
              "kind": "scalar",
              "description": "Set retained for last will message.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "topic",
              "type": "string",
              "kind": "scalar",
              "description": "Set topic for last will message.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "payload",
              "type": "string",
              "kind": "scalar",
              "description": "Set payload for last will message.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "write_timeout": {
          "name": "write_timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum amount of time to wait to write data before the attempt is abandoned.",
          "required": true,
          "default": "3s",
          "examples": [
            "1s",
            "500ms"
          ]
        }
      }
    },
    "nanomsg": {
      "name": "nanomsg",
      "type": "output",
      "source": "upstream",
      "summary": "Send messages over a Nanomsg socket.",
      "description": "Currently only PUSH and PUB sockets are supported.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.",
      "config": {
        "bind": {
          "name": "bind",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether the URLs listed should be bind (otherwise they are connected to).",
          "required": true,
          "default": false
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "poll_timeout": {
          "name": "poll_timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum period of time to wait for a message to send before the request is abandoned and reattempted.",
          "required": true,
          "default": "5s"
        },
        "socket_type": {
          "name": "socket_type",
          "type": "string",
          "kind": "scalar",
          "description": "The socket type to send with.",
          "required": true,
          "default": "PUSH",
          "options": [
            "PUSH",
            "PUB"
          ]
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null
        }
      }
    },
    "nats": {
      "name": "nats",
      "type": "output",
      "source": "upstream",
      "summary": "Publish to an NATS subject.",
      "description": "This output will interpolate functions within the subject field, you can find a list of functions xref:configuration:interpolation.adoc#bloblang-queries[here].\n\n== Connection name\n\nWhen monitoring and managing a production NATS system, it is often useful to\nknow which connection a message was send/received from. This can be achieved by\nsetting the connection name option when creating a NATS connection.\n\nRedpanda Connect will automatically set the connection name based off the label of the given\nNATS component, so that monitoring tools between NATS and Redpanda Connect can stay in sync.\n\n\n== Authentication\n\nThere are several components within Redpanda Connect which uses NATS services. You will find that each of these components\nsupport optional advanced authentication parameters for https://docs.nats.io/nats-server/configuration/securing_nats/auth_intro/nkey_auth[NKeys^]\nand https://docs.nats.io/using-nats/developer/connecting/creds[User Credentials^].\n\nSee an https://docs.nats.io/running-a-nats-service/nats_admin/security/jwt[in-depth tutorial^].\n\n=== NKey file\n\nThe NATS server can use these NKeys in several ways for authentication. The simplest is for the server to be configured\nwith a list of known public keys and for the clients to respond to the challenge by signing it with its private NKey\nconfigured in the `nkey_file` or `nkey` field.\n\nhttps://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[More details^].\n\n=== User credentials\n\nNATS server supports decentralized authentication based on JSON Web Tokens (JWT). Clients need an https://docs.nats.io/nats-server/configuration/securing_nats/jwt#json-web-tokens[user JWT^]\nand a corresponding https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[NKey secret^] when connecting to a server\nwhich is configured to use this authentication scheme.\n\nThe `user_credentials_file` field should point to a file containing both the private key and the JWT and can be\ngenerated with the https://docs.nats.io/nats-tools/nsc[nsc tool^].\n\nAlternatively, the `user_jwt` field can contain a plain text JWT and the `user_nkey_seed`can contain\nthe plain text NKey Seed.\n\nhttps://docs.nats.io/using-nats/developer/connecting/creds[More details^].",
      "config": {
        "auth": {
          "name": "auth",
          "type": "object",
          "kind": "scalar",
          "description": "Optional configuration of NATS authentication parameters.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "nkey_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing a NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./seed.nk"
              ],
              "advanced": true
            },
            {
              "name": "nkey",
              "type": "string",
              "kind": "scalar",
              "description": "The NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "UDXU4RCSJNZOIQHZNWXHXORDPRTGNJAHAHFRGZNEEJCPQTT2M7NLCNF4"
              ],
              "advanced": true
            },
            {
              "name": "user_credentials_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing user credentials which consist of an user JWT and corresponding NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./user.creds"
              ],
              "advanced": true
            },
            {
              "name": "user_jwt",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user JWT (given along with the corresponding user NKey Seed).",
              "required": false,
              "default": null,
              "advanced": true
            },
            {
              "name": "user_nkey_seed",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user NKey Seed (given along with the corresponding user JWT).",
              "required": false,
              "default": null,
              "advanced": true
            }
          ]
        },
        "headers": {
          "name": "headers",
          "type": "string",
          "kind": "map",
          "description": "Explicit message headers to add to messages.",
          "required": true,
          "default": {},
          "examples": [
            {
              "Content-Type": "application/json",
              "Timestamp": "${!meta(\"Timestamp\")}"
            }
          ]
        },
        "inject_tracing_map": {
          "name": "inject_tracing_map",
          "type": "string",
          "kind": "scalar",
          "description": "EXPERIMENTAL: A xref:guides:bloblang/about.adoc[Bloblang mapping] used to inject an object containing tracing propagation information into outbound messages. The specification of the injected fields will match the format used by the service wide tracer.",
          "required": false,
          "default": null,
          "examples": [
            "meta = @.merge(this)",
            "root.meta.span = this"
          ],
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "metadata": {
          "name": "metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Determine which (if any) metadata values should be added to messages as headers.",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "include_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  "foo_",
                  "bar_"
                ],
                [
                  "kafka_"
                ],
                [
                  "content-"
                ]
              ]
            },
            {
              "name": "include_patterns",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key regular expression (re2) patterns to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  ".*"
                ],
                [
                  "_timestamp_unix$"
                ]
              ]
            }
          ]
        },
        "subject": {
          "name": "subject",
          "type": "string",
          "kind": "scalar",
          "description": "The subject to publish to.",
          "required": true,
          "default": null,
          "examples": [
            "foo.bar.baz"
          ]
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "nats://127.0.0.1:4222"
            ],
            [
              "nats://username:password@127.0.0.1:4222"
            ]
          ]
        }
      }
    },
    "nats_jetstream": {
      "name": "nats_jetstream",
      "type": "output",
      "source": "upstream",
      "summary": "Write messages to a NATS JetStream subject.",
      "description": "== Connection name\n\nWhen monitoring and managing a production NATS system, it is often useful to\nknow which connection a message was send/received from. This can be achieved by\nsetting the connection name option when creating a NATS connection.\n\nRedpanda Connect will automatically set the connection name based off the label of the given\nNATS component, so that monitoring tools between NATS and Redpanda Connect can stay in sync.\n\n\n== Authentication\n\nThere are several components within Redpanda Connect which uses NATS services. You will find that each of these components\nsupport optional advanced authentication parameters for https://docs.nats.io/nats-server/configuration/securing_nats/auth_intro/nkey_auth[NKeys^]\nand https://docs.nats.io/using-nats/developer/connecting/creds[User Credentials^].\n\nSee an https://docs.nats.io/running-a-nats-service/nats_admin/security/jwt[in-depth tutorial^].\n\n=== NKey file\n\nThe NATS server can use these NKeys in several ways for authentication. The simplest is for the server to be configured\nwith a list of known public keys and for the clients to respond to the challenge by signing it with its private NKey\nconfigured in the `nkey_file` or `nkey` field.\n\nhttps://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[More details^].\n\n=== User credentials\n\nNATS server supports decentralized authentication based on JSON Web Tokens (JWT). Clients need an https://docs.nats.io/nats-server/configuration/securing_nats/jwt#json-web-tokens[user JWT^]\nand a corresponding https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[NKey secret^] when connecting to a server\nwhich is configured to use this authentication scheme.\n\nThe `user_credentials_file` field should point to a file containing both the private key and the JWT and can be\ngenerated with the https://docs.nats.io/nats-tools/nsc[nsc tool^].\n\nAlternatively, the `user_jwt` field can contain a plain text JWT and the `user_nkey_seed`can contain\nthe plain text NKey Seed.\n\nhttps://docs.nats.io/using-nats/developer/connecting/creds[More details^].",
      "config": {
        "auth": {
          "name": "auth",
          "type": "object",
          "kind": "scalar",
          "description": "Optional configuration of NATS authentication parameters.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "nkey_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing a NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./seed.nk"
              ],
              "advanced": true
            },
            {
              "name": "nkey",
              "type": "string",
              "kind": "scalar",
              "description": "The NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "UDXU4RCSJNZOIQHZNWXHXORDPRTGNJAHAHFRGZNEEJCPQTT2M7NLCNF4"
              ],
              "advanced": true
            },
            {
              "name": "user_credentials_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing user credentials which consist of an user JWT and corresponding NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./user.creds"
              ],
              "advanced": true
            },
            {
              "name": "user_jwt",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user JWT (given along with the corresponding user NKey Seed).",
              "required": false,
              "default": null,
              "advanced": true
            },
            {
              "name": "user_nkey_seed",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user NKey Seed (given along with the corresponding user JWT).",
              "required": false,
              "default": null,
              "advanced": true
            }
          ]
        },
        "headers": {
          "name": "headers",
          "type": "string",
          "kind": "map",
          "description": "Explicit message headers to add to messages.",
          "required": true,
          "default": {},
          "examples": [
            {
              "Content-Type": "application/json",
              "Timestamp": "${!meta(\"Timestamp\")}"
            }
          ]
        },
        "inject_tracing_map": {
          "name": "inject_tracing_map",
          "type": "string",
          "kind": "scalar",
          "description": "EXPERIMENTAL: A xref:guides:bloblang/about.adoc[Bloblang mapping] used to inject an object containing tracing propagation information into outbound messages. The specification of the injected fields will match the format used by the service wide tracer.",
          "required": false,
          "default": null,
          "examples": [
            "meta = @.merge(this)",
            "root.meta.span = this"
          ],
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 1024
        },
        "metadata": {
          "name": "metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Determine which (if any) metadata values should be added to messages as headers.",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "include_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  "foo_",
                  "bar_"
                ],
                [
                  "kafka_"
                ],
                [
                  "content-"
                ]
              ]
            },
            {
              "name": "include_patterns",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key regular expression (re2) patterns to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  ".*"
                ],
                [
                  "_timestamp_unix$"
                ]
              ]
            }
          ]
        },
        "subject": {
          "name": "subject",
          "type": "string",
          "kind": "scalar",
          "description": "A subject to write to.",
          "required": true,
          "default": null,
          "examples": [
            "foo.bar.baz",
            "${! meta(\"kafka_topic\") }",
            "foo.${! json(\"meta.type\") }"
          ]
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "nats://127.0.0.1:4222"
            ],
            [
              "nats://username:password@127.0.0.1:4222"
            ]
          ]
        }
      }
    },
    "nats_kv": {
      "name": "nats_kv",
      "type": "output",
      "source": "upstream",
      "summary": "Put messages in a NATS key-value bucket.",
      "description": "\nThe field `key` supports\nxref:configuration:interpolation.adoc#bloblang-queries[interpolation functions], allowing\nyou to create a unique key for each message.\n\n== Connection name\n\nWhen monitoring and managing a production NATS system, it is often useful to\nknow which connection a message was send/received from. This can be achieved by\nsetting the connection name option when creating a NATS connection.\n\nRedpanda Connect will automatically set the connection name based off the label of the given\nNATS component, so that monitoring tools between NATS and Redpanda Connect can stay in sync.\n\n\n== Authentication\n\nThere are several components within Redpanda Connect which uses NATS services. You will find that each of these components\nsupport optional advanced authentication parameters for https://docs.nats.io/nats-server/configuration/securing_nats/auth_intro/nkey_auth[NKeys^]\nand https://docs.nats.io/using-nats/developer/connecting/creds[User Credentials^].\n\nSee an https://docs.nats.io/running-a-nats-service/nats_admin/security/jwt[in-depth tutorial^].\n\n=== NKey file\n\nThe NATS server can use these NKeys in several ways for authentication. The simplest is for the server to be configured\nwith a list of known public keys and for the clients to respond to the challenge by signing it with its private NKey\nconfigured in the `nkey_file` or `nkey` field.\n\nhttps://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[More details^].\n\n=== User credentials\n\nNATS server supports decentralized authentication based on JSON Web Tokens (JWT). Clients need an https://docs.nats.io/nats-server/configuration/securing_nats/jwt#json-web-tokens[user JWT^]\nand a corresponding https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[NKey secret^] when connecting to a server\nwhich is configured to use this authentication scheme.\n\nThe `user_credentials_file` field should point to a file containing both the private key and the JWT and can be\ngenerated with the https://docs.nats.io/nats-tools/nsc[nsc tool^].\n\nAlternatively, the `user_jwt` field can contain a plain text JWT and the `user_nkey_seed`can contain\nthe plain text NKey Seed.\n\nhttps://docs.nats.io/using-nats/developer/connecting/creds[More details^].",
      "config": {
        "auth": {
          "name": "auth",
          "type": "object",
          "kind": "scalar",
          "description": "Optional configuration of NATS authentication parameters.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "nkey_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing a NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./seed.nk"
              ],
              "advanced": true
            },
            {
              "name": "nkey",
              "type": "string",
              "kind": "scalar",
              "description": "The NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "UDXU4RCSJNZOIQHZNWXHXORDPRTGNJAHAHFRGZNEEJCPQTT2M7NLCNF4"
              ],
              "advanced": true
            },
            {
              "name": "user_credentials_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing user credentials which consist of an user JWT and corresponding NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./user.creds"
              ],
              "advanced": true
            },
            {
              "name": "user_jwt",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user JWT (given along with the corresponding user NKey Seed).",
              "required": false,
              "default": null,
              "advanced": true
            },
            {
              "name": "user_nkey_seed",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user NKey Seed (given along with the corresponding user JWT).",
              "required": false,
              "default": null,
              "advanced": true
            }
          ]
        },
        "bucket": {
          "name": "bucket",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the KV bucket.",
          "required": true,
          "default": null,
          "examples": [
            "my_kv_bucket"
          ]
        },
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "The key for each message.",
          "required": true,
          "default": null,
          "examples": [
            "foo",
            "foo.bar.baz",
            "foo.${! json(\"meta.type\") }"
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 1024
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "nats://127.0.0.1:4222"
            ],
            [
              "nats://username:password@127.0.0.1:4222"
            ]
          ]
        }
      }
    },
    "nats_stream": {
      "name": "nats_stream",
      "type": "output",
      "source": "upstream",
      "summary": "Publish to a NATS Stream subject.",
      "description": "\n[CAUTION]\n.Deprecation notice\n====\nThe NATS Streaming Server is being deprecated. Critical bug fixes and security fixes will be applied until June of 2023. NATS-enabled applications requiring persistence should use https://docs.nats.io/nats-concepts/jetstream[JetStream^].\n====\n\n\n\n== Authentication\n\nThere are several components within Redpanda Connect which uses NATS services. You will find that each of these components\nsupport optional advanced authentication parameters for https://docs.nats.io/nats-server/configuration/securing_nats/auth_intro/nkey_auth[NKeys^]\nand https://docs.nats.io/using-nats/developer/connecting/creds[User Credentials^].\n\nSee an https://docs.nats.io/running-a-nats-service/nats_admin/security/jwt[in-depth tutorial^].\n\n=== NKey file\n\nThe NATS server can use these NKeys in several ways for authentication. The simplest is for the server to be configured\nwith a list of known public keys and for the clients to respond to the challenge by signing it with its private NKey\nconfigured in the `nkey_file` or `nkey` field.\n\nhttps://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[More details^].\n\n=== User credentials\n\nNATS server supports decentralized authentication based on JSON Web Tokens (JWT). Clients need an https://docs.nats.io/nats-server/configuration/securing_nats/jwt#json-web-tokens[user JWT^]\nand a corresponding https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/nkey_auth[NKey secret^] when connecting to a server\nwhich is configured to use this authentication scheme.\n\nThe `user_credentials_file` field should point to a file containing both the private key and the JWT and can be\ngenerated with the https://docs.nats.io/nats-tools/nsc[nsc tool^].\n\nAlternatively, the `user_jwt` field can contain a plain text JWT and the `user_nkey_seed`can contain\nthe plain text NKey Seed.\n\nhttps://docs.nats.io/using-nats/developer/connecting/creds[More details^].\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.",
      "config": {
        "auth": {
          "name": "auth",
          "type": "object",
          "kind": "scalar",
          "description": "Optional configuration of NATS authentication parameters.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "nkey_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing a NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./seed.nk"
              ],
              "advanced": true
            },
            {
              "name": "nkey",
              "type": "string",
              "kind": "scalar",
              "description": "The NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "UDXU4RCSJNZOIQHZNWXHXORDPRTGNJAHAHFRGZNEEJCPQTT2M7NLCNF4"
              ],
              "advanced": true
            },
            {
              "name": "user_credentials_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional file containing user credentials which consist of an user JWT and corresponding NKey seed.",
              "required": false,
              "default": null,
              "examples": [
                "./user.creds"
              ],
              "advanced": true
            },
            {
              "name": "user_jwt",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user JWT (given along with the corresponding user NKey Seed).",
              "required": false,
              "default": null,
              "advanced": true
            },
            {
              "name": "user_nkey_seed",
              "type": "string",
              "kind": "scalar",
              "description": "An optional plain text user NKey Seed (given along with the corresponding user JWT).",
              "required": false,
              "default": null,
              "advanced": true
            }
          ]
        },
        "client_id": {
          "name": "client_id",
          "type": "string",
          "kind": "scalar",
          "description": "The client ID to connect with.",
          "required": true,
          "default": ""
        },
        "cluster_id": {
          "name": "cluster_id",
          "type": "string",
          "kind": "scalar",
          "description": "The cluster ID to publish to.",
          "required": true,
          "default": null
        },
        "inject_tracing_map": {
          "name": "inject_tracing_map",
          "type": "string",
          "kind": "scalar",
          "description": "EXPERIMENTAL: A xref:guides:bloblang/about.adoc[Bloblang mapping] used to inject an object containing tracing propagation information into outbound messages. The specification of the injected fields will match the format used by the service wide tracer.",
          "required": false,
          "default": null,
          "examples": [
            "meta = @.merge(this)",
            "root.meta.span = this"
          ],
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "subject": {
          "name": "subject",
          "type": "string",
          "kind": "scalar",
          "description": "The subject to publish to.",
          "required": true,
          "default": null
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "nats://127.0.0.1:4222"
            ],
            [
              "nats://username:password@127.0.0.1:4222"
            ]
          ]
        }
      }
    },
    "nsq": {
      "name": "nsq",
      "type": "output",
      "source": "upstream",
      "summary": "Publish to an NSQ topic.",
      "description": "The `topic` field can be dynamically set using function interpolations described xref:configuration:interpolation.adoc#bloblang-queries[here]. When sending batched messages these interpolations are performed per message part.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.",
      "config": {
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "nsqd_tcp_address": {
          "name": "nsqd_tcp_address",
          "type": "string",
          "kind": "scalar",
          "description": "The address of the target NSQD server.",
          "required": true,
          "default": null
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "topic": {
          "name": "topic",
          "type": "string",
          "kind": "scalar",
          "description": "The topic to publish to.",
          "required": true,
          "default": null
        },
        "user_agent": {
          "name": "user_agent",
          "type": "string",
          "kind": "scalar",
          "description": "A user agent to assume when connecting.",
          "required": false,
          "default": null
        }
      }
    },
    "ockam_kafka": {
      "name": "ockam_kafka",
      "type": "output",
      "source": "upstream",
      "summary": "Ockam",
      "config": {
        "allow": {
          "name": "allow",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": false,
          "default": "self"
        },
        "allow_consumer": {
          "name": "allow_consumer",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": "self"
        },
        "disable_content_encryption": {
          "name": "disable_content_encryption",
          "type": "bool",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": false
        },
        "encrypted_fields": {
          "name": "encrypted_fields",
          "type": "string",
          "kind": "array",
          "description": "The fields to encrypt in the kafka messages, assuming the record is a valid JSON map. By default, the whole record is encrypted.",
          "required": true,
          "default": []
        },
        "enrollment_ticket": {
          "name": "enrollment_ticket",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": false,
          "default": null
        },
        "identity_name": {
          "name": "identity_name",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": false,
          "default": null
        },
        "kafka": {
          "name": "kafka",
          "type": "object",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "seed_brokers",
              "type": "string",
              "kind": "array",
              "description": "A list of broker addresses to connect to in order to establish connections. If an item of the list contains commas it will be expanded into multiple addresses.",
              "required": false,
              "default": null,
              "examples": [
                [
                  "localhost:9092"
                ],
                [
                  "foo:9092",
                  "bar:9092"
                ],
                [
                  "foo:9092,bar:9092"
                ]
              ]
            },
            {
              "name": "tls",
              "type": "object",
              "kind": "scalar",
              "description": "Custom TLS settings can be used to override system defaults.",
              "required": true,
              "default": null,
              "advanced": true,
              "children": [
                {
                  "name": "enabled",
                  "type": "bool",
                  "kind": "scalar",
                  "description": "Whether custom TLS settings are enabled.",
                  "required": true,
                  "default": false,
                  "advanced": true
                },
                {
                  "name": "skip_cert_verify",
                  "type": "bool",
                  "kind": "scalar",
                  "description": "Whether to skip server side certificate verification.",
                  "required": true,
                  "default": false,
                  "advanced": true
                },
                {
                  "name": "enable_renegotiation",
                  "type": "bool",
                  "kind": "scalar",
                  "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
                  "required": true,
                  "default": false,
                  "advanced": true
                },
                {
                  "name": "root_cas",
                  "type": "string",
                  "kind": "scalar",
                  "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
                  "required": true,
                  "default": "",
                  "examples": [
                    "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
                  ],
                  "advanced": true
                },
                {
                  "name": "root_cas_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
                  "required": true,
                  "default": "",
                  "examples": [
                    "./root_cas.pem"
                  ],
                  "advanced": true
                },
                {
                  "name": "client_certs",
                  "type": "object",
                  "kind": "array",
                  "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
                  "required": true,
                  "default": [],
                  "examples": [
                    [
                      {
                        "cert": "foo",
                        "key": "bar"
                      }
                    ],
                    [
                      {
                        "cert_file": "./example.pem",
                        "key_file": "./example.key"
                      }
                    ]
                  ],
                  "advanced": true,
                  "children": [
                    {
                      "name": "cert",
                      "type": "string",
                      "kind": "scalar",
                      "description": "A plain text certificate to use.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "key",
                      "type": "string",
                      "kind": "scalar",
                      "description": "A plain text certificate key to use.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "cert_file",
                      "type": "string",
                      "kind": "scalar",
                      "description": "The path of a certificate to use.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "key_file",
                      "type": "string",
                      "kind": "scalar",
                      "description": "The path of a certificate key to use.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "password",
                      "type": "string",
                      "kind": "scalar",
                      "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                      "required": true,
                      "default": "",
                      "examples": [
                        "foo",
                        "${KEY_PASSWORD}"
                      ],
                      "advanced": true
                    }
                  ]
                }
              ]
            },
            {
              "name": "max_in_flight",
              "type": "int",
              "kind": "scalar",
              "description": "The maximum number of batches to be sending in parallel at any given time.",
              "required": true,
              "default": 10
            },
            {
              "name": "batching",
              "type": "object",
              "kind": "",
              "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
              "required": true,
              "default": null,
              "examples": [
                {
                  "byte_size": 5000,
                  "count": 0,
                  "period": "1s"
                },
                {
                  "count": 10,
                  "period": "1s"
                },
                {
                  "check": "this.contains(\"END BATCH\")",
                  "count": 0,
                  "period": "1m"
                }
              ],
              "children": [
                {
                  "name": "count",
                  "type": "int",
                  "kind": "scalar",
                  "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
                  "required": true,
                  "default": 0
                },
                {
                  "name": "byte_size",
                  "type": "int",
                  "kind": "scalar",
                  "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
                  "required": true,
                  "default": 0
                },
                {
                  "name": "period",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A period in which an incomplete batch should be flushed regardless of its size.",
                  "required": true,
                  "default": "",
                  "examples": [
                    "1s",
                    "1m",
                    "500ms"
                  ]
                },
                {
                  "name": "check",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
                  "required": true,
                  "default": "",
                  "examples": [
                    "this.type == \"end_of_transaction\""
                  ]
                },
                {
                  "name": "processors",
                  "type": "processor",
                  "kind": "array",
                  "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
                  "required": false,
                  "default": null,
                  "examples": [
                    [
                      {
                        "archive": {
                          "format": "concatenate"
                        }
                      }
                    ],
                    [
                      {
                        "archive": {
                          "format": "lines"
                        }
                      }
                    ],
                    [
                      {
                        "archive": {
                          "format": "json_array"
                        }
                      }
                    ]
                  ],
                  "advanced": true
                }
              ]
            },
            {
              "name": "partitioner",
              "type": "string",
              "kind": "scalar",
              "description": "Override the default murmur2 hashing partitioner.",
              "required": false,
              "default": null,
              "advanced": true
            },
            {
              "name": "idempotent_write",
              "type": "bool",
              "kind": "scalar",
              "description": "Enable the idempotent write producer option. This requires the `IDEMPOTENT_WRITE` permission on `CLUSTER` and can be disabled if this permission is not available.",
              "required": true,
              "default": true,
              "advanced": true
            },
            {
              "name": "compression",
              "type": "string",
              "kind": "scalar",
              "description": "Optionally set an explicit compression type. The default preference is to use snappy when the broker supports it, and fall back to none if not.",
              "required": false,
              "default": null,
              "options": [
                "lz4",
                "snappy",
                "gzip",
                "none",
                "zstd"
              ],
              "advanced": true
            },
            {
              "name": "timeout",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period of time to wait for message sends before abandoning the request and retrying",
              "required": true,
              "default": "10s",
              "advanced": true
            },
            {
              "name": "max_message_bytes",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum space in bytes than an individual message may take, messages larger than this value will be rejected. This field corresponds to Kafka's `max.message.bytes`.",
              "required": true,
              "default": "1MiB",
              "examples": [
                "100MB",
                "50mib"
              ],
              "advanced": true
            },
            {
              "name": "broker_write_max_bytes",
              "type": "string",
              "kind": "scalar",
              "description": "The upper bound for the number of bytes written to a broker connection in a single write. This field corresponds to Kafka's `socket.request.max.bytes`.",
              "required": true,
              "default": "100MiB",
              "examples": [
                "128MB",
                "50mib"
              ],
              "advanced": true
            },
            {
              "name": "topic",
              "type": "string",
              "kind": "scalar",
              "description": "A topic to write messages to.",
              "required": true,
              "default": null
            },
            {
              "name": "key",
              "type": "string",
              "kind": "scalar",
              "description": "An optional key to populate for each message.",
              "required": false,
              "default": null
            },
            {
              "name": "partition",
              "type": "string",
              "kind": "scalar",
              "description": "An optional explicit partition to set for each message. This field is only relevant when the `partitioner` is set to `manual`. The provided interpolation string must be a valid integer.",
              "required": false,
              "default": null,
              "examples": [
                "${! meta(\"partition\") }"
              ]
            },
            {
              "name": "metadata",
              "type": "object",
              "kind": "scalar",
              "description": "Determine which (if any) metadata values should be added to messages as headers.",
              "required": false,
              "default": null,
              "children": [
                {
                  "name": "include_prefixes",
                  "type": "string",
                  "kind": "array",
                  "description": "Provide a list of explicit metadata key prefixes to match against.",
                  "required": true,
                  "default": [],
                  "examples": [
                    [
                      "foo_",
                      "bar_"
                    ],
                    [
                      "kafka_"
                    ],
                    [
                      "content-"
                    ]
                  ]
                },
                {
                  "name": "include_patterns",
                  "type": "string",
                  "kind": "array",
                  "description": "Provide a list of explicit metadata key regular expression (re2) patterns to match against.",
                  "required": true,
                  "default": [],
                  "examples": [
                    [
                      ".*"
                    ],
                    [
                      "_timestamp_unix$"
                    ]
                  ]
                }
              ]
            },
            {
              "name": "timestamp",
              "type": "string",
              "kind": "scalar",
              "description": "An optional timestamp to set for each message. When left empty, the current timestamp is used.",
              "required": false,
              "default": null,
              "examples": [
                "${! timestamp_unix() }",
                "${! metadata(\"kafka_timestamp_unix\") }"
              ],
              "advanced": true
            },
            {
              "name": "timestamp_ms",
              "type": "string",
              "kind": "scalar",
              "description": "An optional timestamp to set for each message expressed in milliseconds. When left empty, the current timestamp is used.",
              "required": false,
              "default": null,
              "examples": [
                "${! timestamp_unix_milli() }",
                "${! metadata(\"kafka_timestamp_ms\") }"
              ],
              "advanced": true
            }
          ]
        },
        "route_to_consumer": {
          "name": "route_to_consumer",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": "/ip4/127.0.0.1/tcp/6262"
        },
        "route_to_kafka_outlet": {
          "name": "route_to_kafka_outlet",
          "type": "string",
          "kind": "scalar",
          "description": "",
          "required": true,
          "default": "self"
        }
      }
    },
    "opcua": {
      "name": "opcua",
      "type": "output",
      "source": "benthos-umh",
      "summary": "OPC UA output plugin",
      "description": "The OPC UA output plugin writes data to an OPC UA server and optionally verifies the write via a read-back handshake.",
      "config": {
        "autoReconnect": {
          "name": "autoReconnect",
          "type": "bool",
          "kind": "scalar",
          "description": "Set to true to automatically reconnect to the OPC UA server when the connection is lost.",
          "required": true,
          "default": false,
          "examples": [
            false,
            true
          ],
          "advanced": true
        },
        "clientCertificate": {
          "name": "clientCertificate",
          "type": "string",
          "kind": "scalar",
          "description": "The client certificate to use, base64-encoded.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "directConnect": {
          "name": "directConnect",
          "type": "bool",
          "kind": "scalar",
          "description": "Set this to true to directly connect to an OPC UA endpoint. This can be necessary in cases where the OPC UA server does not allow 'endpoint discovery'. This requires having the full endpoint name in endpoint, and securityMode and securityPolicy set.",
          "required": true,
          "default": false,
          "examples": [
            false,
            true
          ],
          "advanced": true
        },
        "endpoint": {
          "name": "endpoint",
          "type": "string",
          "kind": "scalar",
          "description": "The OPC UA server endpoint to connect to.",
          "required": true,
          "default": null,
          "examples": [
            "opc.tcp://localhost:4840",
            "opc.tcp://{{ .IP }}:{{ .PORT }}",
            "opc.tcp://192.168.1.100:4840",
            "opc.tcp://10.0.0.50:4840",
            "opc.tcp://plc.local:4840"
          ]
        },
        "handshake": {
          "name": "handshake",
          "type": "object",
          "kind": "scalar",
          "description": "Configuration for the read-back handshake.",
          "required": true,
          "default": {
            "enabled": true,
            "maxWriteAttempts": 1,
            "readbackTimeoutMs": 2000,
            "timeBetweenRetriesMs": 1000
          },
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to enable read-back verification after writing.",
              "required": true,
              "default": true
            },
            {
              "name": "readbackTimeoutMs",
              "type": "int",
              "kind": "scalar",
              "description": "How long to wait for the server to show the updated value.",
              "required": true,
              "default": 2000
            },
            {
              "name": "maxWriteAttempts",
              "type": "int",
              "kind": "scalar",
              "description": "Number of write attempts if the server fails.",
              "required": true,
              "default": 1
            },
            {
              "name": "timeBetweenRetriesMs",
              "type": "int",
              "kind": "scalar",
              "description": "Delay between write attempts.",
              "required": true,
              "default": 1000
            }
          ]
        },
        "insecure": {
          "name": "insecure",
          "type": "bool",
          "kind": "scalar",
          "description": "Set to true to bypass secure connections, useful in case of SSL or certificate issues. Default is secure (false).",
          "required": true,
          "default": false,
          "examples": [
            false,
            true
          ],
          "advanced": true
        },
        "nodeIDs": {
          "name": "nodeIDs",
          "type": "string",
          "kind": "array",
          "description": "List of OPC-UA node IDs to begin browsing.",
          "required": true,
          "default": null,
          "examples": [
            [
              "i=84"
            ],
            [
              "ns=2;s=Temperature"
            ],
            [
              "ns=2;s=Temperature",
              "ns=2;s=Pressure"
            ],
            [
              "ns=3;i=1001"
            ]
          ]
        },
        "nodeMappings": {
          "name": "nodeMappings",
          "type": "object",
          "kind": "array",
          "description": "List of node mappings defining which message fields to write to which OPC UA nodes",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "nodeId",
              "type": "string",
              "kind": "scalar",
              "description": "The OPC UA node ID to write to. Supports dynamic values through interpolation.",
              "required": true,
              "default": null,
              "examples": [
                "ns=2;s=MyVariable",
                "ns=2;s=${! json(\"nodeId\") }"
              ]
            },
            {
              "name": "valueFrom",
              "type": "string",
              "kind": "scalar",
              "description": "The field in the input message to get the value from.",
              "required": true,
              "default": null,
              "examples": [
                "value"
              ]
            },
            {
              "name": "dataType",
              "type": "string",
              "kind": "scalar",
              "description": "The OPC UA data type for the value. Supports dynamic values through interpolation.",
              "required": true,
              "default": null,
              "examples": [
                "Int32",
                "${! json(\"dataType\") }"
              ]
            }
          ]
        },
        "password": {
          "name": "password",
          "type": "string",
          "kind": "scalar",
          "description": "The password for authentication.",
          "required": false,
          "default": "",
          "examples": [
            "",
            "password123"
          ],
          "advanced": true
        },
        "pollRate": {
          "name": "pollRate",
          "type": "int",
          "kind": "scalar",
          "description": "The rate in milliseconds at which to poll the OPC UA server when not using subscriptions. Defaults to 1000ms (1 second).",
          "required": false,
          "default": 1000,
          "examples": [
            1000,
            5000,
            100
          ],
          "advanced": true
        },
        "queueSize": {
          "name": "queueSize",
          "type": "int",
          "kind": "scalar",
          "description": "The size of the queue, which will get filled from the OPC UA server when requesting its data via subscription",
          "required": false,
          "default": 10,
          "examples": [
            10,
            50,
            100
          ],
          "advanced": true
        },
        "reconnectIntervalInSeconds": {
          "name": "reconnectIntervalInSeconds",
          "type": "int",
          "kind": "scalar",
          "description": "The interval in seconds at which to reconnect to the OPC UA server when the connection is lost. This is only used if `autoReconnect` is set to true.",
          "required": true,
          "default": 5,
          "examples": [
            5,
            10,
            30
          ],
          "advanced": true
        },
        "samplingInterval": {
          "name": "samplingInterval",
          "type": "float",
          "kind": "scalar",
          "description": "The interval for sampling on the OPC UA server - notice 0.0 will get you updates as fast as possible",
          "required": false,
          "default": 0,
          "examples": [
            0,
            100,
            1000
          ],
          "advanced": true
        },
        "securityMode": {
          "name": "securityMode",
          "type": "string",
          "kind": "scalar",
          "description": "The security mode to use. Options: None, Sign, SignAndEncrypt",
          "required": false,
          "default": "",
          "examples": [
            "",
            "None",
            "Sign",
            "SignAndEncrypt"
          ],
          "advanced": true
        },
        "securityPolicy": {
          "name": "securityPolicy",
          "type": "string",
          "kind": "scalar",
          "description": "The security policy to use. Options: None, Basic128Rsa15, Basic256, Basic256Sha256",
          "required": false,
          "default": "",
          "examples": [
            "",
            "None",
            "Basic256",
            "Basic256Sha256"
          ],
          "advanced": true
        },
        "serverCertificateFingerprint": {
          "name": "serverCertificateFingerprint",
          "type": "string",
          "kind": "scalar",
          "description": "The server certificate fingerprint to verify, SHA3-512 hash.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "sessionTimeout": {
          "name": "sessionTimeout",
          "type": "int",
          "kind": "scalar",
          "description": "The duration in milliseconds that a OPC UA session will last. Is used to ensure that older failed sessions will timeout and that we will not get a TooManySession error.",
          "required": true,
          "default": 10000,
          "examples": [
            10000,
            30000,
            60000
          ],
          "advanced": true
        },
        "subscribeEnabled": {
          "name": "subscribeEnabled",
          "type": "bool",
          "kind": "scalar",
          "description": "Set to true to subscribe to OPC UA nodes instead of fetching them every seconds. Default is pulling messages every second (false).",
          "required": true,
          "default": false,
          "examples": [
            true,
            false
          ]
        },
        "useHeartbeat": {
          "name": "useHeartbeat",
          "type": "bool",
          "kind": "scalar",
          "description": "Set to true to provide an extra message with the servers timestamp as a heartbeat",
          "required": false,
          "default": false,
          "examples": [
            true,
            false
          ],
          "advanced": true
        },
        "userCertificate": {
          "name": "userCertificate",
          "type": "string",
          "kind": "scalar",
          "description": "User certificate in base64 encoded format of either PEM or DER.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "userPrivateKey": {
          "name": "userPrivateKey",
          "type": "string",
          "kind": "scalar",
          "description": "User private key in base64 format of PEM for user certificate based authentication.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "username": {
          "name": "username",
          "type": "string",
          "kind": "scalar",
          "description": "The username for authentication.",
          "required": false,
          "default": "",
          "examples": [
            "",
            "admin",
            "opcuser"
          ],
          "advanced": true
        }
      }
    },
    "opensearch": {
      "name": "opensearch",
      "type": "output",
      "source": "upstream",
      "summary": "Publishes messages into an Elasticsearch index. If the index does not exist then it is created with a dynamic mapping.",
      "description": "\nBoth the `id` and `index` fields can be dynamically set using function interpolations described xref:configuration:interpolation.adoc#bloblang-queries[here]. When sending batched messages these interpolations are performed per message part.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "action": {
          "name": "action",
          "type": "string",
          "kind": "scalar",
          "description": "The action to take on the document. This field must resolve to one of the following action types: `index`, `update` or `delete`.",
          "required": true,
          "default": null
        },
        "aws": {
          "name": "aws",
          "type": "object",
          "kind": "scalar",
          "description": "Enables and customises connectivity to Amazon Elastic Service.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to connect to Amazon Elastic Service.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "region",
              "type": "string",
              "kind": "scalar",
              "description": "The AWS region to target.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "endpoint",
              "type": "string",
              "kind": "scalar",
              "description": "Allows you to specify a custom endpoint for the AWS API.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "credentials",
              "type": "object",
              "kind": "scalar",
              "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
              "required": true,
              "default": null,
              "advanced": true,
              "children": [
                {
                  "name": "profile",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A profile from `~/.aws/credentials` to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "id",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The ID of credentials to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "secret",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The secret for the credentials being used.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "token",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The token for the credentials being used, required when using short term credentials.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "from_ec2_role",
                  "type": "bool",
                  "kind": "scalar",
                  "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
                  "required": true,
                  "default": false,
                  "advanced": true
                },
                {
                  "name": "role",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A role ARN to assume.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "role_external_id",
                  "type": "string",
                  "kind": "scalar",
                  "description": "An external ID to provide when assuming a role.",
                  "required": true,
                  "default": "",
                  "advanced": true
                }
              ]
            }
          ]
        },
        "basic_auth": {
          "name": "basic_auth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify basic authentication.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use basic authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "A username to authenticate as.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A password to authenticate with.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "id": {
          "name": "id",
          "type": "string",
          "kind": "scalar",
          "description": "The ID for indexed messages. Interpolation should be used in order to create a unique ID for each message.",
          "required": true,
          "default": null,
          "examples": [
            "${!counter()}-${!timestamp_unix()}"
          ]
        },
        "index": {
          "name": "index",
          "type": "string",
          "kind": "scalar",
          "description": "The index to place messages.",
          "required": true,
          "default": null
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "pipeline": {
          "name": "pipeline",
          "type": "string",
          "kind": "scalar",
          "description": "An optional pipeline id to preprocess incoming documents.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "routing": {
          "name": "routing",
          "type": "string",
          "kind": "scalar",
          "description": "The routing key to use for the document.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "urls": {
          "name": "urls",
          "type": "string",
          "kind": "array",
          "description": "A list of URLs to connect to. If an item of the list contains commas it will be expanded into multiple URLs.",
          "required": true,
          "default": null,
          "examples": [
            [
              "http://localhost:9200"
            ]
          ]
        }
      }
    },
    "pinecone": {
      "name": "pinecone",
      "type": "output",
      "source": "upstream",
      "summary": "Inserts items into a Pinecone index.",
      "description": "\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "api_key": {
          "name": "api_key",
          "type": "string",
          "kind": "scalar",
          "description": "The Pinecone api key.",
          "required": true,
          "default": null
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "host": {
          "name": "host",
          "type": "string",
          "kind": "scalar",
          "description": "The host for the Pinecone index.",
          "required": true,
          "default": null
        },
        "id": {
          "name": "id",
          "type": "string",
          "kind": "scalar",
          "description": "The ID for the index entry in Pinecone.",
          "required": true,
          "default": null
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "metadata_mapping": {
          "name": "metadata_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "An optional mapping of message to metadata in the Pinecone index entry.",
          "required": false,
          "default": null,
          "examples": [
            "root = @",
            "root = metadata()",
            "root = {\"summary\": this.summary, \"foo\": this.other_field}"
          ]
        },
        "namespace": {
          "name": "namespace",
          "type": "string",
          "kind": "scalar",
          "description": "The namespace to write to - writes to the default namespace by default.",
          "required": true,
          "default": "",
          "advanced": true
        },
        "operation": {
          "name": "operation",
          "type": "string",
          "kind": "scalar",
          "description": "The operation to perform against the Pinecone index.",
          "required": true,
          "default": "upsert-vectors",
          "options": [
            "update-vector",
            "upsert-vectors",
            "delete-vectors"
          ]
        },
        "vector_mapping": {
          "name": "vector_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "The mapping to extract out the vector from the document. The result must be a floating point array. Required if not a delete operation.",
          "required": false,
          "default": null,
          "examples": [
            "root = this.embeddings_vector",
            "root = [1.2, 0.5, 0.76]"
          ]
        }
      }
    },
    "pulsar": {
      "name": "pulsar",
      "type": "output",
      "source": "upstream",
      "summary": "Write messages to an Apache Pulsar server.",
      "config": {
        "auth": {
          "name": "auth",
          "type": "object",
          "kind": "scalar",
          "description": "Optional configuration of Pulsar authentication methods.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "oauth2",
              "type": "object",
              "kind": "scalar",
              "description": "Parameters for Pulsar OAuth2 authentication.",
              "required": false,
              "default": null,
              "advanced": true,
              "children": [
                {
                  "name": "enabled",
                  "type": "bool",
                  "kind": "scalar",
                  "description": "Whether OAuth2 is enabled.",
                  "required": true,
                  "default": false,
                  "advanced": true
                },
                {
                  "name": "audience",
                  "type": "string",
                  "kind": "scalar",
                  "description": "OAuth2 audience.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "issuer_url",
                  "type": "string",
                  "kind": "scalar",
                  "description": "OAuth2 issuer URL.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "scope",
                  "type": "string",
                  "kind": "scalar",
                  "description": "OAuth2 scope to request.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "private_key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path to a file containing a private key.",
                  "required": true,
                  "default": "",
                  "advanced": true
                }
              ]
            },
            {
              "name": "token",
              "type": "object",
              "kind": "scalar",
              "description": "Parameters for Pulsar Token authentication.",
              "required": false,
              "default": null,
              "advanced": true,
              "children": [
                {
                  "name": "enabled",
                  "type": "bool",
                  "kind": "scalar",
                  "description": "Whether Token Auth is enabled.",
                  "required": true,
                  "default": false,
                  "advanced": true
                },
                {
                  "name": "token",
                  "type": "string",
                  "kind": "scalar",
                  "description": "Actual base64 encoded token.",
                  "required": true,
                  "default": "",
                  "advanced": true
                }
              ]
            }
          ]
        },
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "The key to publish messages with.",
          "required": true,
          "default": ""
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "ordering_key": {
          "name": "ordering_key",
          "type": "string",
          "kind": "scalar",
          "description": "The ordering key to publish messages with.",
          "required": true,
          "default": ""
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Specify the path to a custom CA certificate to trust broker TLS service.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ]
            }
          ]
        },
        "topic": {
          "name": "topic",
          "type": "string",
          "kind": "scalar",
          "description": "The topic to publish to.",
          "required": true,
          "default": null
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "A URL to connect to.",
          "required": true,
          "default": null,
          "examples": [
            "pulsar://localhost:6650",
            "pulsar://pulsar.us-west.example.com:6650",
            "pulsar+ssl://pulsar.us-west.example.com:6651"
          ]
        }
      }
    },
    "pusher": {
      "name": "pusher",
      "type": "output",
      "source": "upstream",
      "summary": "Output for publishing messages to Pusher API (https://pusher.com)",
      "config": {
        "appId": {
          "name": "appId",
          "type": "string",
          "kind": "scalar",
          "description": "Pusher app id",
          "required": true,
          "default": null
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "maximum batch size is 10 (limit of the pusher library)",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "channel": {
          "name": "channel",
          "type": "string",
          "kind": "scalar",
          "description": "Pusher channel to publish to. Interpolation functions can also be used",
          "required": true,
          "default": null,
          "examples": [
            "my_channel",
            "${!json(\"id\")}"
          ]
        },
        "cluster": {
          "name": "cluster",
          "type": "string",
          "kind": "scalar",
          "description": "Pusher cluster",
          "required": true,
          "default": null
        },
        "event": {
          "name": "event",
          "type": "string",
          "kind": "scalar",
          "description": "Event to publish to",
          "required": true,
          "default": null
        },
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "Pusher key",
          "required": true,
          "default": null
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of parallel message batches to have in flight at any given time.",
          "required": true,
          "default": 1
        },
        "secret": {
          "name": "secret",
          "type": "string",
          "kind": "scalar",
          "description": "Pusher secret",
          "required": true,
          "default": null
        },
        "secure": {
          "name": "secure",
          "type": "bool",
          "kind": "scalar",
          "description": "Enable SSL encryption",
          "required": true,
          "default": true
        }
      }
    },
    "qdrant": {
      "name": "qdrant",
      "type": "output",
      "source": "upstream",
      "summary": "Adds items to a https://qdrant.tech/[Qdrant^] collection",
      "description": "\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "api_token": {
          "name": "api_token",
          "type": "string",
          "kind": "scalar",
          "description": "The Qdrant API token for authentication. Defaults to an empty string.",
          "required": true,
          "default": ""
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "collection_name": {
          "name": "collection_name",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the collection in Qdrant.",
          "required": true,
          "default": null
        },
        "grpc_host": {
          "name": "grpc_host",
          "type": "string",
          "kind": "scalar",
          "description": "The gRPC host of the Qdrant server.",
          "required": true,
          "default": null,
          "examples": [
            "localhost:6334",
            "xyz-example.eu-central.aws.cloud.qdrant.io:6334"
          ]
        },
        "id": {
          "name": "id",
          "type": "string",
          "kind": "scalar",
          "description": "The ID of the point to insert. Can be a UUID string or positive integer.",
          "required": true,
          "default": null,
          "examples": [
            "root = \"dc88c126-679f-49f5-ab85-04b77e8c2791\"",
            "root = 832"
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "payload_mapping": {
          "name": "payload_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "An optional mapping of message to payload associated with the point.",
          "required": true,
          "default": "root = {}",
          "examples": [
            "root = {\"field\": this.value, \"field_2\": 987}",
            "root = metadata()"
          ]
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "TLS(HTTPS) config to use when connecting",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "vector_mapping": {
          "name": "vector_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "The mapping to extract the vector from the document.",
          "required": true,
          "default": null,
          "examples": [
            "root = {\"dense_vector\": [0.352,0.532,0.754],\"sparse_vector\": {\"indices\": [23,325,532],\"values\": [0.352,0.532,0.532]}, \"multi_vector\": [[0.352,0.532],[0.352,0.532]]}",
            "root = [1.2, 0.5, 0.76]",
            "root = this.vector",
            "root = [[0.352,0.532,0.532,0.234],[0.352,0.532,0.532,0.234]]",
            "root = {\"some_sparse\": {\"indices\":[23,325,532],\"values\":[0.352,0.532,0.532]}}",
            "root = {\"some_multi\": [[0.352,0.532,0.532,0.234],[0.352,0.532,0.532,0.234]]}",
            "root = {\"some_dense\": [0.352,0.532,0.532,0.234]}"
          ]
        }
      }
    },
    "questdb": {
      "name": "questdb",
      "type": "output",
      "source": "upstream",
      "summary": "Pushes messages to a QuestDB table",
      "description": "Important: We recommend that the dedupe feature is enabled on the QuestDB server. Please visit https://questdb.io/docs/ for more information about deploying, configuring, and using QuestDB.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "address": {
          "name": "address",
          "type": "string",
          "kind": "scalar",
          "description": "Address of the QuestDB server's HTTP port (excluding protocol)",
          "required": true,
          "default": null,
          "examples": [
            "localhost:9000"
          ]
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "designated_timestamp_field": {
          "name": "designated_timestamp_field",
          "type": "string",
          "kind": "scalar",
          "description": "Name of the designated timestamp field",
          "required": false,
          "default": null
        },
        "designated_timestamp_unit": {
          "name": "designated_timestamp_unit",
          "type": "string",
          "kind": "scalar",
          "description": "Designated timestamp field units",
          "required": false,
          "default": "auto"
        },
        "doubles": {
          "name": "doubles",
          "type": "string",
          "kind": "array",
          "description": "Columns that should be double type, (int is default)",
          "required": false,
          "default": null
        },
        "error_on_empty_messages": {
          "name": "error_on_empty_messages",
          "type": "bool",
          "kind": "scalar",
          "description": "Mark a message as errored if it is empty after field validation",
          "required": false,
          "default": false
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "password": {
          "name": "password",
          "type": "string",
          "kind": "scalar",
          "description": "Password for HTTP basic auth",
          "required": false,
          "default": null
        },
        "request_min_throughput": {
          "name": "request_min_throughput",
          "type": "int",
          "kind": "scalar",
          "description": "Minimum expected throughput in bytes per second for HTTP requests. If the throughput is lower than this value, the connection will time out. This is used to calculate an additional timeout on top of request_timeout. This is useful for large requests. You can set this value to 0 to disable this logic.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "request_timeout": {
          "name": "request_timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The time to wait for a response from the server. This is in addition to the calculation derived from the request_min_throughput parameter.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "retry_timeout": {
          "name": "retry_timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The time to continue retrying after a failed HTTP request. The interval between retries is an exponential backoff starting at 10ms and doubling after each failed attempt up to a maximum of 1 second.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "symbols": {
          "name": "symbols",
          "type": "string",
          "kind": "array",
          "description": "Columns that should be the SYMBOL type (string values default to STRING)",
          "required": false,
          "default": null
        },
        "table": {
          "name": "table",
          "type": "string",
          "kind": "scalar",
          "description": "Destination table",
          "required": true,
          "default": null,
          "examples": [
            "trades"
          ]
        },
        "timestamp_string_fields": {
          "name": "timestamp_string_fields",
          "type": "string",
          "kind": "array",
          "description": "String fields with textual timestamps",
          "required": false,
          "default": null
        },
        "timestamp_string_format": {
          "name": "timestamp_string_format",
          "type": "string",
          "kind": "scalar",
          "description": "Timestamp format, used when parsing timestamp string fields. Specified in golang's time.Parse layout",
          "required": false,
          "default": "Jan _2 15:04:05.000000Z0700"
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "token": {
          "name": "token",
          "type": "string",
          "kind": "scalar",
          "description": "Bearer token for HTTP auth (takes precedence over basic auth username \u0026 password)",
          "required": false,
          "default": null
        },
        "username": {
          "name": "username",
          "type": "string",
          "kind": "scalar",
          "description": "Username for HTTP basic auth",
          "required": false,
          "default": null
        }
      }
    },
    "redis_hash": {
      "name": "redis_hash",
      "type": "output",
      "source": "upstream",
      "summary": "Sets Redis hash objects using the HMSET command.",
      "description": "\nThe field `key` supports xref:configuration:interpolation.adoc#bloblang-queries[interpolation functions], allowing you to create a unique key for each message.\n\nThe field `fields` allows you to specify an explicit map of field names to interpolated values, also evaluated per message of a batch:\n\n```yaml\noutput:\n  redis_hash:\n    url: tcp://localhost:6379\n    key: ${!json(\"id\")}\n    fields:\n      topic: ${!meta(\"kafka_topic\")}\n      partition: ${!meta(\"kafka_partition\")}\n      content: ${!json(\"document.text\")}\n```\n\nIf the field `walk_metadata` is set to `true` then Redpanda Connect will walk all metadata fields of messages and add them to the list of hash fields to set.\n\nIf the field `walk_json_object` is set to `true` then Redpanda Connect will walk each message as a JSON object, extracting keys and the string representation of their value and adds them to the list of hash fields to set.\n\nThe order of hash field extraction is as follows:\n\n1. Metadata (if enabled)\n2. JSON object (if enabled)\n3. Explicit fields\n\nWhere latter stages will overwrite matching field names of a former stage.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.",
      "config": {
        "fields": {
          "name": "fields",
          "type": "string",
          "kind": "map",
          "description": "A map of key/value pairs to set as hash fields.",
          "required": true,
          "default": {}
        },
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "The key for each message, function interpolations should be used to create a unique key per message.",
          "required": true,
          "default": null,
          "examples": [
            "${! @.kafka_key )}",
            "${! this.doc.id }",
            "${! counter() }"
          ]
        },
        "kind": {
          "name": "kind",
          "type": "string",
          "kind": "scalar",
          "description": "Specifies a simple, cluster-aware, or failover-aware redis client.",
          "required": true,
          "default": "simple",
          "options": [
            "simple",
            "cluster",
            "failover"
          ],
          "advanced": true
        },
        "master": {
          "name": "master",
          "type": "string",
          "kind": "scalar",
          "description": "Name of the redis master when `kind` is `failover`",
          "required": true,
          "default": "",
          "examples": [
            "mymaster"
          ],
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.\n\n**Troubleshooting**\n\nSome cloud hosted instances of Redis (such as Azure Cache) might need some hand holding in order to establish stable connections. Unfortunately, it is often the case that TLS issues will manifest as generic error messages such as \"i/o timeout\". If you're using TLS and are seeing connectivity problems consider setting `enable_renegotiation` to `true`, and ensuring that the server supports at least TLS version 1.2.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL of the target Redis server. Database is optional and is supplied as the URL path.",
          "required": true,
          "default": null,
          "examples": [
            "redis://:6379",
            "redis://localhost:6379",
            "redis://foousername:foopassword@redisplace:6379",
            "redis://:foopassword@redisplace:6379",
            "redis://localhost:6379/1",
            "redis://localhost:6379/1,redis://localhost:6380/1"
          ]
        },
        "walk_json_object": {
          "name": "walk_json_object",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to walk each message as a JSON object and add each key/value pair to the list of hash fields to set.",
          "required": true,
          "default": false
        },
        "walk_metadata": {
          "name": "walk_metadata",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether all metadata fields of messages should be walked and added to the list of hash fields to set.",
          "required": true,
          "default": false
        }
      }
    },
    "redis_list": {
      "name": "redis_list",
      "type": "output",
      "source": "upstream",
      "summary": "Pushes messages onto the end of a Redis list (which is created if it doesn't already exist) using the RPUSH command.",
      "description": "The field `key` supports xref:configuration:interpolation.adoc#bloblang-queries[interpolation functions], allowing you to create a unique key for each message.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "command": {
          "name": "command",
          "type": "string",
          "kind": "scalar",
          "description": "The command used to push elements to the Redis list",
          "required": true,
          "default": "rpush",
          "options": [
            "rpush",
            "lpush"
          ],
          "advanced": true
        },
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "The key for each message, function interpolations can be optionally used to create a unique key per message.",
          "required": true,
          "default": null,
          "examples": [
            "some_list",
            "${! @.kafka_key )}",
            "${! this.doc.id }",
            "${! counter() }"
          ]
        },
        "kind": {
          "name": "kind",
          "type": "string",
          "kind": "scalar",
          "description": "Specifies a simple, cluster-aware, or failover-aware redis client.",
          "required": true,
          "default": "simple",
          "options": [
            "simple",
            "cluster",
            "failover"
          ],
          "advanced": true
        },
        "master": {
          "name": "master",
          "type": "string",
          "kind": "scalar",
          "description": "Name of the redis master when `kind` is `failover`",
          "required": true,
          "default": "",
          "examples": [
            "mymaster"
          ],
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.\n\n**Troubleshooting**\n\nSome cloud hosted instances of Redis (such as Azure Cache) might need some hand holding in order to establish stable connections. Unfortunately, it is often the case that TLS issues will manifest as generic error messages such as \"i/o timeout\". If you're using TLS and are seeing connectivity problems consider setting `enable_renegotiation` to `true`, and ensuring that the server supports at least TLS version 1.2.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL of the target Redis server. Database is optional and is supplied as the URL path.",
          "required": true,
          "default": null,
          "examples": [
            "redis://:6379",
            "redis://localhost:6379",
            "redis://foousername:foopassword@redisplace:6379",
            "redis://:foopassword@redisplace:6379",
            "redis://localhost:6379/1",
            "redis://localhost:6379/1,redis://localhost:6380/1"
          ]
        }
      }
    },
    "redis_pubsub": {
      "name": "redis_pubsub",
      "type": "output",
      "source": "upstream",
      "summary": "Publishes messages through the Redis PubSub model. It is not possible to guarantee that messages have been received.",
      "description": "\nThis output will interpolate functions within the channel field, you can find a list of functions xref:configuration:interpolation.adoc#bloblang-queries[here].\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "channel": {
          "name": "channel",
          "type": "string",
          "kind": "scalar",
          "description": "The channel to publish messages to.",
          "required": true,
          "default": null
        },
        "kind": {
          "name": "kind",
          "type": "string",
          "kind": "scalar",
          "description": "Specifies a simple, cluster-aware, or failover-aware redis client.",
          "required": true,
          "default": "simple",
          "options": [
            "simple",
            "cluster",
            "failover"
          ],
          "advanced": true
        },
        "master": {
          "name": "master",
          "type": "string",
          "kind": "scalar",
          "description": "Name of the redis master when `kind` is `failover`",
          "required": true,
          "default": "",
          "examples": [
            "mymaster"
          ],
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.\n\n**Troubleshooting**\n\nSome cloud hosted instances of Redis (such as Azure Cache) might need some hand holding in order to establish stable connections. Unfortunately, it is often the case that TLS issues will manifest as generic error messages such as \"i/o timeout\". If you're using TLS and are seeing connectivity problems consider setting `enable_renegotiation` to `true`, and ensuring that the server supports at least TLS version 1.2.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL of the target Redis server. Database is optional and is supplied as the URL path.",
          "required": true,
          "default": null,
          "examples": [
            "redis://:6379",
            "redis://localhost:6379",
            "redis://foousername:foopassword@redisplace:6379",
            "redis://:foopassword@redisplace:6379",
            "redis://localhost:6379/1",
            "redis://localhost:6379/1,redis://localhost:6380/1"
          ]
        }
      }
    },
    "redis_streams": {
      "name": "redis_streams",
      "type": "output",
      "source": "upstream",
      "summary": "Pushes messages to a Redis (v5.0+) Stream (which is created if it doesn't already exist) using the XADD command.",
      "description": "\nIt's possible to specify a maximum length of the target stream by setting it to a value greater than 0, in which case this cap is applied only when Redis is able to remove a whole macro node, for efficiency.\n\nRedis stream entries are key/value pairs, as such it is necessary to specify the key to be set to the body of the message. All metadata fields of the message will also be set as key/value pairs, if there is a key collision between a metadata item and the body then the body takes precedence.\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.\n\nThis output benefits from sending messages as a batch for improved performance. Batches can be formed at both the input and output level. You can find out more xref:configuration:batching.adoc[in this doc].",
      "config": {
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "body_key": {
          "name": "body_key",
          "type": "string",
          "kind": "scalar",
          "description": "A key to set the raw body of the message to.",
          "required": true,
          "default": "body"
        },
        "kind": {
          "name": "kind",
          "type": "string",
          "kind": "scalar",
          "description": "Specifies a simple, cluster-aware, or failover-aware redis client.",
          "required": true,
          "default": "simple",
          "options": [
            "simple",
            "cluster",
            "failover"
          ],
          "advanced": true
        },
        "master": {
          "name": "master",
          "type": "string",
          "kind": "scalar",
          "description": "Name of the redis master when `kind` is `failover`",
          "required": true,
          "default": "",
          "examples": [
            "mymaster"
          ],
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "max_length": {
          "name": "max_length",
          "type": "int",
          "kind": "scalar",
          "description": "When greater than zero enforces a rough cap on the length of the target stream.",
          "required": true,
          "default": 0
        },
        "metadata": {
          "name": "metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Specify criteria for which metadata values are included in the message body.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "exclude_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to be excluded when adding metadata to sent messages.",
              "required": true,
              "default": []
            }
          ]
        },
        "stream": {
          "name": "stream",
          "type": "string",
          "kind": "scalar",
          "description": "The stream to add messages to.",
          "required": true,
          "default": null
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.\n\n**Troubleshooting**\n\nSome cloud hosted instances of Redis (such as Azure Cache) might need some hand holding in order to establish stable connections. Unfortunately, it is often the case that TLS issues will manifest as generic error messages such as \"i/o timeout\". If you're using TLS and are seeing connectivity problems consider setting `enable_renegotiation` to `true`, and ensuring that the server supports at least TLS version 1.2.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL of the target Redis server. Database is optional and is supplied as the URL path.",
          "required": true,
          "default": null,
          "examples": [
            "redis://:6379",
            "redis://localhost:6379",
            "redis://foousername:foopassword@redisplace:6379",
            "redis://:foopassword@redisplace:6379",
            "redis://localhost:6379/1",
            "redis://localhost:6379/1,redis://localhost:6380/1"
          ]
        }
      }
    },
    "redpanda": {
      "name": "redpanda",
      "type": "output",
      "source": "upstream",
      "summary": "A Kafka output using the https://github.com/twmb/franz-go[Franz Kafka client library^].",
      "description": "\nWrites a batch of messages to Kafka brokers and waits for acknowledgement before propagating it back to the input.\n",
      "config": {
        "broker_write_max_bytes": {
          "name": "broker_write_max_bytes",
          "type": "string",
          "kind": "scalar",
          "description": "The upper bound for the number of bytes written to a broker connection in a single write. This field corresponds to Kafka's `socket.request.max.bytes`.",
          "required": true,
          "default": "100MiB",
          "examples": [
            "128MB",
            "50mib"
          ],
          "advanced": true
        },
        "client_id": {
          "name": "client_id",
          "type": "string",
          "kind": "scalar",
          "description": "An identifier for the client connection.",
          "required": true,
          "default": "benthos",
          "advanced": true
        },
        "compression": {
          "name": "compression",
          "type": "string",
          "kind": "scalar",
          "description": "Optionally set an explicit compression type. The default preference is to use snappy when the broker supports it, and fall back to none if not.",
          "required": false,
          "default": null,
          "options": [
            "lz4",
            "snappy",
            "gzip",
            "none",
            "zstd"
          ],
          "advanced": true
        },
        "idempotent_write": {
          "name": "idempotent_write",
          "type": "bool",
          "kind": "scalar",
          "description": "Enable the idempotent write producer option. This requires the `IDEMPOTENT_WRITE` permission on `CLUSTER` and can be disabled if this permission is not available.",
          "required": true,
          "default": true,
          "advanced": true
        },
        "key": {
          "name": "key",
          "type": "string",
          "kind": "scalar",
          "description": "An optional key to populate for each message.",
          "required": false,
          "default": null
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of batches to be sending in parallel at any given time.",
          "required": true,
          "default": 256
        },
        "max_message_bytes": {
          "name": "max_message_bytes",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum space in bytes than an individual message may take, messages larger than this value will be rejected. This field corresponds to Kafka's `max.message.bytes`.",
          "required": true,
          "default": "1MiB",
          "examples": [
            "100MB",
            "50mib"
          ],
          "advanced": true
        },
        "metadata": {
          "name": "metadata",
          "type": "object",
          "kind": "scalar",
          "description": "Determine which (if any) metadata values should be added to messages as headers.",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "include_prefixes",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key prefixes to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  "foo_",
                  "bar_"
                ],
                [
                  "kafka_"
                ],
                [
                  "content-"
                ]
              ]
            },
            {
              "name": "include_patterns",
              "type": "string",
              "kind": "array",
              "description": "Provide a list of explicit metadata key regular expression (re2) patterns to match against.",
              "required": true,
              "default": [],
              "examples": [
                [
                  ".*"
                ],
                [
                  "_timestamp_unix$"
                ]
              ]
            }
          ]
        },
        "metadata_max_age": {
          "name": "metadata_max_age",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum age of metadata before it is refreshed.",
          "required": true,
          "default": "5m",
          "advanced": true
        },
        "partition": {
          "name": "partition",
          "type": "string",
          "kind": "scalar",
          "description": "An optional explicit partition to set for each message. This field is only relevant when the `partitioner` is set to `manual`. The provided interpolation string must be a valid integer.",
          "required": false,
          "default": null,
          "examples": [
            "${! meta(\"partition\") }"
          ]
        },
        "partitioner": {
          "name": "partitioner",
          "type": "string",
          "kind": "scalar",
          "description": "Override the default murmur2 hashing partitioner.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "sasl": {
          "name": "sasl",
          "type": "object",
          "kind": "array",
          "description": "Specify one or more methods of SASL authentication. SASL is tried in order; if the broker supports the first mechanism, all connections will use that mechanism. If the first mechanism fails, the client will pick the first supported mechanism. If the broker does not support any client mechanisms, connections will fail.",
          "required": false,
          "default": null,
          "examples": [
            [
              {
                "mechanism": "SCRAM-SHA-512",
                "password": "bar",
                "username": "foo"
              }
            ]
          ],
          "advanced": true,
          "children": [
            {
              "name": "mechanism",
              "type": "string",
              "kind": "scalar",
              "description": "The SASL mechanism to use.",
              "required": true,
              "default": null,
              "advanced": true
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "A username to provide for PLAIN or SCRAM-* authentication.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A password to provide for PLAIN or SCRAM-* authentication.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "token",
              "type": "string",
              "kind": "scalar",
              "description": "The token to use for a single session's OAUTHBEARER authentication.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "extensions",
              "type": "string",
              "kind": "map",
              "description": "Key/value pairs to add to OAUTHBEARER authentication requests.",
              "required": false,
              "default": null,
              "advanced": true
            },
            {
              "name": "aws",
              "type": "object",
              "kind": "scalar",
              "description": "Contains AWS specific fields for when the `mechanism` is set to `AWS_MSK_IAM`.",
              "required": false,
              "default": null,
              "advanced": true,
              "children": [
                {
                  "name": "region",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The AWS region to target.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "endpoint",
                  "type": "string",
                  "kind": "scalar",
                  "description": "Allows you to specify a custom endpoint for the AWS API.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "credentials",
                  "type": "object",
                  "kind": "scalar",
                  "description": "Optional manual configuration of AWS credentials to use. More information can be found in xref:guides:cloud/aws.adoc[].",
                  "required": true,
                  "default": null,
                  "advanced": true,
                  "children": [
                    {
                      "name": "profile",
                      "type": "string",
                      "kind": "scalar",
                      "description": "A profile from `~/.aws/credentials` to use.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "id",
                      "type": "string",
                      "kind": "scalar",
                      "description": "The ID of credentials to use.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "secret",
                      "type": "string",
                      "kind": "scalar",
                      "description": "The secret for the credentials being used.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "token",
                      "type": "string",
                      "kind": "scalar",
                      "description": "The token for the credentials being used, required when using short term credentials.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "from_ec2_role",
                      "type": "bool",
                      "kind": "scalar",
                      "description": "Use the credentials of a host EC2 machine configured to assume https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html[an IAM role associated with the instance^].",
                      "required": true,
                      "default": false,
                      "advanced": true
                    },
                    {
                      "name": "role",
                      "type": "string",
                      "kind": "scalar",
                      "description": "A role ARN to assume.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    },
                    {
                      "name": "role_external_id",
                      "type": "string",
                      "kind": "scalar",
                      "description": "An external ID to provide when assuming a role.",
                      "required": true,
                      "default": "",
                      "advanced": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        "seed_brokers": {
          "name": "seed_brokers",
          "type": "string",
          "kind": "array",
          "description": "A list of broker addresses to connect to in order to establish connections. If an item of the list contains commas it will be expanded into multiple addresses.",
          "required": true,
          "default": null,
          "examples": [
            [
              "localhost:9092"
            ],
            [
              "foo:9092",
              "bar:9092"
            ],
            [
              "foo:9092,bar:9092"
            ]
          ]
        },
        "timeout": {
          "name": "timeout",
          "type": "string",
          "kind": "scalar",
          "description": "The maximum period of time to wait for message sends before abandoning the request and retrying",
          "required": true,
          "default": "10s",
          "advanced": true
        },
        "timestamp": {
          "name": "timestamp",
          "type": "string",
          "kind": "scalar",
          "description": "An optional timestamp to set for each message. When left empty, the current timestamp is used.",
          "required": false,
          "default": null,
          "examples": [
            "${! timestamp_unix() }",
            "${! metadata(\"kafka_timestamp_unix\") }"
          ],
          "advanced": true
        },
        "timestamp_ms": {
          "name": "timestamp_ms",
          "type": "string",
          "kind": "scalar",
          "description": "An optional timestamp to set for each message expressed in milliseconds. When left empty, the current timestamp is used.",
          "required": false,
          "default": null,
          "examples": [
            "${! timestamp_unix_milli() }",
            "${! metadata(\"kafka_timestamp_ms\") }"
          ],
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "topic": {
          "name": "topic",
          "type": "string",
          "kind": "scalar",
          "description": "A topic to write messages to.",
          "required": true,
          "default": null
        }
      }
    },
    "reject": {
      "name": "reject",
      "type": "output",
      "source": "upstream",
      "summary": "Rejects all messages, treating them as though the output destination failed to publish them.",
      "description": "\nThe routing of messages after this output depends on the type of input it came from. For inputs that support propagating nacks upstream such as AMQP or NATS the message will be nacked. However, for inputs that are sequential such as files or Kafka the messages will simply be reprocessed from scratch.\n\nTo learn when this output could be useful, see [the \u003c\u003cexamples\u003e\u003e.",
      "config": {}
    },
    "reject_errored": {
      "name": "reject_errored",
      "type": "output",
      "source": "upstream",
      "summary": "Rejects messages that have failed their processing steps, resulting in nack behavior at the input level, otherwise sends them to a child output.",
      "description": "\nThe routing of messages rejected by this output depends on the type of input it came from. For inputs that support propagating nacks upstream such as AMQP or NATS the message will be nacked. However, for inputs that are sequential such as files or Kafka the messages will simply be reprocessed from scratch.",
      "config": {}
    },
    "resource": {
      "name": "resource",
      "type": "output",
      "source": "upstream",
      "summary": "Resource is an output type that channels messages to a resource output, identified by its name.",
      "description": "Resources allow you to tidy up deeply nested configs. For example, the config:\n\n```yaml\noutput:\n  broker:\n    pattern: fan_out\n    outputs:\n    - kafka:\n        addresses: [ TODO ]\n        topic: foo\n    - gcp_pubsub:\n        project: bar\n        topic: baz\n```\n\nCould also be expressed as:\n\n```yaml\noutput:\n  broker:\n    pattern: fan_out\n    outputs:\n    - resource: foo\n    - resource: bar\n\noutput_resources:\n  - label: foo\n    kafka:\n      addresses: [ TODO ]\n      topic: foo\n\n  - label: bar\n    gcp_pubsub:\n      project: bar\n      topic: baz\n```\n\nYou can find out more about resources in xref:configuration:resources.adoc[]",
      "config": {}
    },
    "retry": {
      "name": "retry",
      "type": "output",
      "source": "upstream",
      "summary": "Attempts to write messages to a child output and if the write fails for any reason the message is retried either until success or, if the retries or max elapsed time fields are non-zero, either is reached.",
      "description": "\nAll messages in Redpanda Connect are always retried on an output error, but this would usually involve propagating the error back to the source of the message, whereby it would be reprocessed before reaching the output layer once again.\n\nThis output type is useful whenever we wish to avoid reprocessing a message on the event of a failed send. We might, for example, have a deduplication processor that we want to avoid reapplying to the same message more than once in the pipeline.\n\nRather than retrying the same output you may wish to retry the send using a different output target (a dead letter queue). In which case you should instead use the xref:components:outputs/fallback.adoc[`fallback`] output type.",
      "config": {
        "backoff": {
          "name": "backoff",
          "type": "object",
          "kind": "scalar",
          "description": "Control time intervals between retry attempts.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "initial_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The initial period to wait between retry attempts.",
              "required": true,
              "default": "500ms",
              "advanced": true
            },
            {
              "name": "max_interval",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait between retry attempts.",
              "required": true,
              "default": "3s",
              "advanced": true
            },
            {
              "name": "max_elapsed_time",
              "type": "string",
              "kind": "scalar",
              "description": "The maximum period to wait before retry attempts are abandoned. If zero then no limit is used.",
              "required": true,
              "default": "0s",
              "advanced": true
            }
          ]
        },
        "max_retries": {
          "name": "max_retries",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of retries before giving up on the request. If set to zero there is no discrete limit.",
          "required": true,
          "default": 0,
          "advanced": true
        },
        "output": {
          "name": "output",
          "type": "output",
          "kind": "scalar",
          "description": "A child output.",
          "required": true,
          "default": null
        }
      }
    },
    "sftp": {
      "name": "sftp",
      "type": "output",
      "source": "upstream",
      "summary": "Writes files to an SFTP server.",
      "description": "In order to have a different path for each object you should use function interpolations described xref:configuration:interpolation.adoc#bloblang-queries[here].\n\n== Performance\n\nThis output benefits from sending multiple messages in flight in parallel for improved performance. You can tune the max number of in flight messages (or message batches) with the field `max_in_flight`.",
      "config": {
        "address": {
          "name": "address",
          "type": "string",
          "kind": "scalar",
          "description": "The address of the server to connect to.",
          "required": true,
          "default": null
        },
        "codec": {
          "name": "codec",
          "type": "string",
          "kind": "scalar",
          "description": "The way in which the bytes of messages should be written out into the output data stream. It's possible to write lines using a custom delimiter with the `delim:x` codec, where x is the character sequence custom delimiter.",
          "required": true,
          "default": "all-bytes",
          "examples": [
            "lines",
            "delim:\t",
            "delim:foobar"
          ]
        },
        "credentials": {
          "name": "credentials",
          "type": "object",
          "kind": "scalar",
          "description": "The credentials to use to log into the target server.",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "The username to connect to the SFTP server.",
              "required": true,
              "default": ""
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "The password for the username to connect to the SFTP server.",
              "required": true,
              "default": ""
            },
            {
              "name": "private_key_file",
              "type": "string",
              "kind": "scalar",
              "description": "The private key for the username to connect to the SFTP server.",
              "required": true,
              "default": ""
            },
            {
              "name": "private_key_pass",
              "type": "string",
              "kind": "scalar",
              "description": "Optional passphrase for private key.",
              "required": true,
              "default": ""
            }
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "path": {
          "name": "path",
          "type": "string",
          "kind": "scalar",
          "description": "The file to save the messages to on the server.",
          "required": true,
          "default": null
        }
      }
    },
    "smtp": {
      "name": "smtp",
      "type": "output",
      "source": "upstream",
      "summary": "Creates an output that sends data to smtp. Created by Daniel H",
      "description": "This output plugin enables Benthos to send data via email using smtp. Configure the plugin by specifying the stmp server address, port, sender address and recipients.",
      "config": {
        "InsecureSkipVerify": {
          "name": "InsecureSkipVerify",
          "type": "bool",
          "kind": "scalar",
          "description": "InsecureSkipVerify",
          "required": true,
          "default": false
        },
        "TLS": {
          "name": "TLS",
          "type": "string",
          "kind": "scalar",
          "description": "STARTTLS or SMTPS",
          "required": true,
          "default": ""
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "password": {
          "name": "password",
          "type": "string",
          "kind": "scalar",
          "description": "password",
          "required": true,
          "default": ""
        },
        "recipients": {
          "name": "recipients",
          "type": "string",
          "kind": "array",
          "description": "List of recipients to send to",
          "required": true,
          "default": null
        },
        "senderAddress": {
          "name": "senderAddress",
          "type": "string",
          "kind": "scalar",
          "description": "sender Address",
          "required": true,
          "default": null
        },
        "serverAddress": {
          "name": "serverAddress",
          "type": "string",
          "kind": "scalar",
          "description": "smtp server address.",
          "required": true,
          "default": null
        },
        "serverPort": {
          "name": "serverPort",
          "type": "int",
          "kind": "scalar",
          "description": "server port. Default 25)",
          "required": true,
          "default": 25
        },
        "username": {
          "name": "username",
          "type": "string",
          "kind": "scalar",
          "description": "username",
          "required": true,
          "default": ""
        }
      }
    },
    "socket": {
      "name": "socket",
      "type": "output",
      "source": "upstream",
      "summary": "Connects to a (tcp/udp/unix) server and sends a continuous stream of data, dividing messages according to the specified codec.",
      "config": {
        "address": {
          "name": "address",
          "type": "string",
          "kind": "scalar",
          "description": "The address to connect to.",
          "required": true,
          "default": null,
          "examples": [
            "/tmp/benthos.sock",
            "127.0.0.1:6000"
          ]
        },
        "codec": {
          "name": "codec",
          "type": "string",
          "kind": "scalar",
          "description": "The way in which the bytes of messages should be written out into the output data stream. It's possible to write lines using a custom delimiter with the `delim:x` codec, where x is the character sequence custom delimiter.",
          "required": true,
          "default": "lines",
          "examples": [
            "lines",
            "delim:\t",
            "delim:foobar"
          ]
        },
        "network": {
          "name": "network",
          "type": "string",
          "kind": "scalar",
          "description": "A network type to connect as.",
          "required": true,
          "default": null,
          "options": [
            "unix",
            "tcp",
            "udp"
          ]
        }
      }
    },
    "sparkplug_b": {
      "name": "sparkplug_b",
      "type": "output",
      "source": "benthos-umh",
      "summary": "Sparkplug B MQTT output acting as Edge Node",
      "description": "The Sparkplug B output acts as an Edge Node, publishing data to Sparkplug MQTT topics \nwith complete session lifecycle management. It handles BIRTH/DEATH certificates, maintains sequence \nnumbers, manages alias mappings, and ensures full Sparkplug B compliance.\n\nKey features:\n- Always operates as Edge Node (no role configuration needed)\n- Automatic NBIRTH/DBIRTH on connect with metric definitions\n- NDEATH/DDEATH Last Will Testament on disconnect\n- Sequence number management with proper wrapping\n- Alias-based metric publishing for bandwidth efficiency\n- Automatic type detection and conversion\n- Configurable metric definitions with aliases\n- Robust reconnection handling with proper rebirth\n- UNS metadata integration for seamless data flow\n\nThe output connects to an MQTT broker, publishes BIRTH certificates to announce available metrics,\nand then publishes DATA messages as Benthos messages flow through the pipeline.",
      "config": {
        "behaviour": {
          "name": "behaviour",
          "type": "object",
          "kind": "scalar",
          "description": "Processing behavior configuration",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "auto_extract_tag_name",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to automatically extract tag_name from message metadata",
              "required": true,
              "default": true
            },
            {
              "name": "retain_last_values",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to retain last known values for BIRTH messages after reconnection",
              "required": true,
              "default": true
            }
          ]
        },
        "identity": {
          "name": "identity",
          "type": "object",
          "kind": "scalar",
          "description": "Sparkplug identity configuration",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "group_id",
              "type": "string",
              "kind": "scalar",
              "description": "Sparkplug Group ID (e.g., 'FactoryA')",
              "required": true,
              "default": null,
              "examples": [
                "FactoryA"
              ]
            },
            {
              "name": "edge_node_id",
              "type": "string",
              "kind": "scalar",
              "description": "Edge Node ID within the group (e.g., 'Line3'). If empty, auto-generated from location_path metadata using Parris Method",
              "required": false,
              "default": null,
              "examples": [
                "Line3"
              ]
            },
            {
              "name": "device_id",
              "type": "string",
              "kind": "scalar",
              "description": "Device ID under the edge node (optional, if not specified acts as node-level)",
              "required": false,
              "default": ""
            }
          ]
        },
        "metrics": {
          "name": "metrics",
          "type": "object",
          "kind": "array",
          "description": "Metric definitions for BIRTH messages and alias mapping",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "name",
              "type": "string",
              "kind": "scalar",
              "description": "Metric name as it will appear in BIRTH messages",
              "required": true,
              "default": null
            },
            {
              "name": "alias",
              "type": "int",
              "kind": "scalar",
              "description": "Numeric alias for this metric (1-65535)",
              "required": true,
              "default": null
            },
            {
              "name": "type",
              "type": "string",
              "kind": "scalar",
              "description": "Data type: int8, int16, int32, int64, uint8, uint16, uint32, uint64, float, double, boolean, string",
              "required": true,
              "default": "double"
            },
            {
              "name": "value_from",
              "type": "string",
              "kind": "scalar",
              "description": "JSONPath or field name in the message to extract value from",
              "required": true,
              "default": "value"
            }
          ]
        },
        "mqtt": {
          "name": "mqtt",
          "type": "object",
          "kind": "scalar",
          "description": "MQTT transport configuration",
          "required": true,
          "default": null,
          "children": [
            {
              "name": "urls",
              "type": "string",
              "kind": "array",
              "description": "List of MQTT broker URLs to connect to",
              "required": true,
              "default": [
                "tcp://localhost:1883"
              ],
              "examples": [
                [
                  "tcp://localhost:1883",
                  "ssl://broker.hivemq.com:8883"
                ]
              ]
            },
            {
              "name": "client_id",
              "type": "string",
              "kind": "scalar",
              "description": "MQTT client ID for this edge node",
              "required": true,
              "default": "benthos-sparkplug-output"
            },
            {
              "name": "credentials",
              "type": "object",
              "kind": "scalar",
              "description": "MQTT authentication credentials",
              "required": false,
              "default": null,
              "children": [
                {
                  "name": "username",
                  "type": "string",
                  "kind": "scalar",
                  "description": "MQTT username for authentication",
                  "required": false,
                  "default": ""
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "MQTT password for authentication",
                  "required": false,
                  "default": ""
                }
              ]
            },
            {
              "name": "qos",
              "type": "int",
              "kind": "scalar",
              "description": "QoS level for MQTT publishing (0, 1, or 2)",
              "required": true,
              "default": 1
            },
            {
              "name": "keep_alive",
              "type": "string",
              "kind": "scalar",
              "description": "MQTT keep alive interval",
              "required": true,
              "default": "60s"
            },
            {
              "name": "connect_timeout",
              "type": "string",
              "kind": "scalar",
              "description": "MQTT connection timeout",
              "required": true,
              "default": "30s"
            },
            {
              "name": "clean_session",
              "type": "bool",
              "kind": "scalar",
              "description": "MQTT clean session flag",
              "required": true,
              "default": true
            }
          ]
        }
      }
    },
    "sql": {
      "name": "sql",
      "type": "output",
      "source": "upstream",
      "summary": "Executes an arbitrary SQL query for each message.",
      "description": "\n== Alternatives\n\nFor basic inserts use the xref:components:outputs/sql.adoc[`sql_insert`] output. For more complex queries use the xref:components:outputs/sql_raw.adoc[`sql_raw`] output.",
      "config": {
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to an array of values matching in size to the number of placeholder arguments in the field `query`.",
          "required": false,
          "default": null,
          "examples": [
            "root = [ this.cat.meow, this.doc.woofs[0] ]",
            "root = [ meta(\"user.id\") ]"
          ]
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "data_source_name": {
          "name": "data_source_name",
          "type": "string",
          "kind": "scalar",
          "description": "Data source name.",
          "required": true,
          "default": null
        },
        "driver": {
          "name": "driver",
          "type": "string",
          "kind": "scalar",
          "description": "A database \u003c\u003cdrivers, driver\u003e\u003e to use.",
          "required": true,
          "default": null,
          "options": [
            "mysql",
            "postgres",
            "clickhouse",
            "mssql",
            "sqlite",
            "oracle",
            "snowflake",
            "trino",
            "gocosmos",
            "spanner"
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of inserts to run in parallel.",
          "required": true,
          "default": 64
        },
        "query": {
          "name": "query",
          "type": "string",
          "kind": "scalar",
          "description": "The query to execute. The style of placeholder to use depends on the driver, some drivers require question marks (`?`) whereas others expect incrementing dollar signs (`$1`, `$2`, and so on) or colons (`:1`, `:2` and so on). The style to use is outlined in this table:\n\n| Driver | Placeholder Style |\n|---|---|\n| `clickhouse` | Dollar sign |\n| `mysql` | Question mark |\n| `postgres` | Dollar sign |\n| `mssql` | Question mark |\n| `sqlite` | Question mark |\n| `oracle` | Colon |\n| `snowflake` | Question mark |\n| `trino` | Question mark |\n| `gocosmos` | Colon |\n",
          "required": true,
          "default": null,
          "examples": [
            "INSERT INTO footable (foo, bar, baz) VALUES (?, ?, ?);"
          ]
        }
      }
    },
    "sql_insert": {
      "name": "sql_insert",
      "type": "output",
      "source": "upstream",
      "summary": "Inserts a row into an SQL database for each message.",
      "config": {
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "A xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to an array of values matching in size to the number of columns specified.",
          "required": true,
          "default": null,
          "examples": [
            "root = [ this.cat.meow, this.doc.woofs[0] ]",
            "root = [ meta(\"user.id\") ]"
          ]
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "columns": {
          "name": "columns",
          "type": "string",
          "kind": "array",
          "description": "A list of columns to insert.",
          "required": true,
          "default": null,
          "examples": [
            [
              "foo",
              "bar",
              "baz"
            ]
          ]
        },
        "conn_max_idle": {
          "name": "conn_max_idle",
          "type": "int",
          "kind": "scalar",
          "description": "An optional maximum number of connections in the idle connection pool. If conn_max_open is greater than 0 but less than the new conn_max_idle, then the new conn_max_idle will be reduced to match the conn_max_open limit. If `value \u003c= 0`, no idle connections are retained. The default max idle connections is currently 2. This may change in a future release.",
          "required": false,
          "default": 2,
          "advanced": true
        },
        "conn_max_idle_time": {
          "name": "conn_max_idle_time",
          "type": "string",
          "kind": "scalar",
          "description": "An optional maximum amount of time a connection may be idle. Expired connections may be closed lazily before reuse. If `value \u003c= 0`, connections are not closed due to a connections idle time.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "conn_max_life_time": {
          "name": "conn_max_life_time",
          "type": "string",
          "kind": "scalar",
          "description": "An optional maximum amount of time a connection may be reused. Expired connections may be closed lazily before reuse. If `value \u003c= 0`, connections are not closed due to a connections age.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "conn_max_open": {
          "name": "conn_max_open",
          "type": "int",
          "kind": "scalar",
          "description": "An optional maximum number of open connections to the database. If conn_max_idle is greater than 0 and the new conn_max_open is less than conn_max_idle, then conn_max_idle will be reduced to match the new conn_max_open limit. If `value \u003c= 0`, then there is no limit on the number of open connections. The default is 0 (unlimited).",
          "required": false,
          "default": null,
          "advanced": true
        },
        "driver": {
          "name": "driver",
          "type": "string",
          "kind": "scalar",
          "description": "A database \u003c\u003cdrivers, driver\u003e\u003e to use.",
          "required": true,
          "default": null,
          "options": [
            "mysql",
            "postgres",
            "clickhouse",
            "mssql",
            "sqlite",
            "oracle",
            "snowflake",
            "trino",
            "gocosmos",
            "spanner"
          ]
        },
        "dsn": {
          "name": "dsn",
          "type": "string",
          "kind": "scalar",
          "description": "A Data Source Name to identify the target database.\n\n==== Drivers\n\n:driver-support: mysql=certified, postgres=certified, clickhouse=community, mssql=community, sqlite=certified, oracle=certified, snowflake=community, trino=community, gocosmos=community, spanner=community\n\nThe following is a list of supported drivers, their placeholder style, and their respective DSN formats:\n\n|===\n| Driver | Data Source Name Format\n\n| `clickhouse` \n| https://github.com/ClickHouse/clickhouse-go#dsn[`clickhouse://[username[:password\\]@\\][netloc\\][:port\\]/dbname[?param1=value1\u0026...\u0026paramN=valueN\\]`^] \n\n| `mysql` \n| `[username[:password]@][protocol[(address)]]/dbname[?param1=value1\u0026...\u0026paramN=valueN]` \n\n| `postgres` \n| `postgres://[user[:password]@][netloc][:port][/dbname][?param1=value1\u0026...]` \n\n| `mssql` \n| `sqlserver://[user[:password]@][netloc][:port][?database=dbname\u0026param1=value1\u0026...]` \n\n| `sqlite` \n| `file:/path/to/filename.db[?param\u0026=value1\u0026...]` \n\n| `oracle` \n| `oracle://[username[:password]@][netloc][:port]/service_name?server=server2\u0026server=server3` \n\n| `snowflake` \n| `username[:password]@account_identifier/dbname/schemaname[?param1=value\u0026...\u0026paramN=valueN]` \n\n| `trino` \n| https://github.com/trinodb/trino-go-client#dsn-data-source-name[`http[s\\]://user[:pass\\]@host[:port\\][?parameters\\]`^] \n\n| `gocosmos` \n| https://pkg.go.dev/github.com/microsoft/gocosmos#readme-example-usage[`AccountEndpoint=\u003ccosmosdb-endpoint\u003e;AccountKey=\u003ccosmosdb-account-key\u003e[;TimeoutMs=\u003ctimeout-in-ms\u003e\\][;Version=\u003ccosmosdb-api-version\u003e\\][;DefaultDb/Db=\u003cdb-name\u003e\\][;AutoId=\u003ctrue/false\u003e\\][;InsecureSkipVerify=\u003ctrue/false\u003e\\]`^] \n\n| `spanner` \n| projects/[PROJECT]/instances/[INSTANCE]/databases/[DATABASE] \n|===\n\nPlease note that the `postgres` driver enforces SSL by default, you can override this with the parameter `sslmode=disable` if required.\n\nThe `snowflake` driver supports multiple DSN formats. Please consult https://pkg.go.dev/github.com/snowflakedb/gosnowflake#hdr-Connection_String[the docs^] for more details. For https://docs.snowflake.com/en/user-guide/key-pair-auth.html#configuring-key-pair-authentication[key pair authentication^], the DSN has the following format: `\u003csnowflake_user\u003e@\u003csnowflake_account\u003e/\u003cdb_name\u003e/\u003cschema_name\u003e?warehouse=\u003cwarehouse\u003e\u0026role=\u003crole\u003e\u0026authenticator=snowflake_jwt\u0026privateKey=\u003cbase64_url_encoded_private_key\u003e`, where the value for the `privateKey` parameter can be constructed from an unencrypted RSA private key file `rsa_key.p8` using `openssl enc -d -base64 -in rsa_key.p8 | basenc --base64url -w0` (you can use `gbasenc` insted of `basenc` on OSX if you install `coreutils` via Homebrew). If you have a password-encrypted private key, you can decrypt it using `openssl pkcs8 -in rsa_key_encrypted.p8 -out rsa_key.p8`. Also, make sure fields such as the username are URL-encoded.\n\nThe https://pkg.go.dev/github.com/microsoft/gocosmos[`gocosmos`^] driver is still experimental, but it has support for https://learn.microsoft.com/en-us/azure/cosmos-db/hierarchical-partition-keys[hierarchical partition keys^] as well as https://learn.microsoft.com/en-us/azure/cosmos-db/nosql/how-to-query-container#cross-partition-query[cross-partition queries^]. Please refer to the https://github.com/microsoft/gocosmos/blob/main/SQL.md[SQL notes^] for details.",
          "required": true,
          "default": null,
          "examples": [
            "clickhouse://username:password@host1:9000,host2:9000/database?dial_timeout=200ms\u0026max_execution_time=60",
            "foouser:foopassword@tcp(localhost:3306)/foodb",
            "postgres://foouser:foopass@localhost:5432/foodb?sslmode=disable",
            "oracle://foouser:foopass@localhost:1521/service_name"
          ]
        },
        "init_files": {
          "name": "init_files",
          "type": "string",
          "kind": "array",
          "description": "\nAn optional list of file paths containing SQL statements to execute immediately upon the first connection to the target database. This is a useful way to initialise tables before processing data. Glob patterns are supported, including super globs (double star).\n\nCare should be taken to ensure that the statements are idempotent, and therefore would not cause issues when run multiple times after service restarts. If both `init_statement` and `init_files` are specified the `init_statement` is executed _after_ the `init_files`.\n\nIf a statement fails for any reason a warning log will be emitted but the operation of this component will not be stopped.\n",
          "required": false,
          "default": null,
          "examples": [
            [
              "./init/*.sql"
            ],
            [
              "./foo.sql",
              "./bar.sql"
            ]
          ],
          "advanced": true
        },
        "init_statement": {
          "name": "init_statement",
          "type": "string",
          "kind": "scalar",
          "description": "\nAn optional SQL statement to execute immediately upon the first connection to the target database. This is a useful way to initialise tables before processing data. Care should be taken to ensure that the statement is idempotent, and therefore would not cause issues when run multiple times after service restarts.\n\nIf both `init_statement` and `init_files` are specified the `init_statement` is executed _after_ the `init_files`.\n\nIf the statement fails for any reason a warning log will be emitted but the operation of this component will not be stopped.\n",
          "required": false,
          "default": null,
          "examples": [
            "\nCREATE TABLE IF NOT EXISTS some_table (\n  foo varchar(50) not null,\n  bar integer,\n  baz varchar(50),\n  primary key (foo)\n) WITHOUT ROWID;\n"
          ],
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of inserts to run in parallel.",
          "required": true,
          "default": 64
        },
        "options": {
          "name": "options",
          "type": "string",
          "kind": "array",
          "description": "A list of keyword options to add before the INTO clause of the query.",
          "required": false,
          "default": null,
          "examples": [
            [
              "DELAYED",
              "IGNORE"
            ]
          ],
          "advanced": true
        },
        "prefix": {
          "name": "prefix",
          "type": "string",
          "kind": "scalar",
          "description": "An optional prefix to prepend to the insert query (before INSERT).",
          "required": false,
          "default": null,
          "advanced": true
        },
        "suffix": {
          "name": "suffix",
          "type": "string",
          "kind": "scalar",
          "description": "An optional suffix to append to the insert query.",
          "required": false,
          "default": null,
          "examples": [
            "ON CONFLICT (name) DO NOTHING"
          ],
          "advanced": true
        },
        "table": {
          "name": "table",
          "type": "string",
          "kind": "scalar",
          "description": "The table to insert to.",
          "required": true,
          "default": null,
          "examples": [
            "foo"
          ]
        }
      }
    },
    "sql_raw": {
      "name": "sql_raw",
      "type": "output",
      "source": "upstream",
      "summary": "Executes an arbitrary SQL query for each message.",
      "config": {
        "args_mapping": {
          "name": "args_mapping",
          "type": "string",
          "kind": "scalar",
          "description": "An optional xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to an array of values matching in size to the number of placeholder arguments in the field `query`.",
          "required": false,
          "default": null,
          "examples": [
            "root = [ this.cat.meow, this.doc.woofs[0] ]",
            "root = [ meta(\"user.id\") ]"
          ]
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "conn_max_idle": {
          "name": "conn_max_idle",
          "type": "int",
          "kind": "scalar",
          "description": "An optional maximum number of connections in the idle connection pool. If conn_max_open is greater than 0 but less than the new conn_max_idle, then the new conn_max_idle will be reduced to match the conn_max_open limit. If `value \u003c= 0`, no idle connections are retained. The default max idle connections is currently 2. This may change in a future release.",
          "required": false,
          "default": 2,
          "advanced": true
        },
        "conn_max_idle_time": {
          "name": "conn_max_idle_time",
          "type": "string",
          "kind": "scalar",
          "description": "An optional maximum amount of time a connection may be idle. Expired connections may be closed lazily before reuse. If `value \u003c= 0`, connections are not closed due to a connections idle time.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "conn_max_life_time": {
          "name": "conn_max_life_time",
          "type": "string",
          "kind": "scalar",
          "description": "An optional maximum amount of time a connection may be reused. Expired connections may be closed lazily before reuse. If `value \u003c= 0`, connections are not closed due to a connections age.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "conn_max_open": {
          "name": "conn_max_open",
          "type": "int",
          "kind": "scalar",
          "description": "An optional maximum number of open connections to the database. If conn_max_idle is greater than 0 and the new conn_max_open is less than conn_max_idle, then conn_max_idle will be reduced to match the new conn_max_open limit. If `value \u003c= 0`, then there is no limit on the number of open connections. The default is 0 (unlimited).",
          "required": false,
          "default": null,
          "advanced": true
        },
        "driver": {
          "name": "driver",
          "type": "string",
          "kind": "scalar",
          "description": "A database \u003c\u003cdrivers, driver\u003e\u003e to use.",
          "required": true,
          "default": null,
          "options": [
            "mysql",
            "postgres",
            "clickhouse",
            "mssql",
            "sqlite",
            "oracle",
            "snowflake",
            "trino",
            "gocosmos",
            "spanner"
          ]
        },
        "dsn": {
          "name": "dsn",
          "type": "string",
          "kind": "scalar",
          "description": "A Data Source Name to identify the target database.\n\n==== Drivers\n\n:driver-support: mysql=certified, postgres=certified, clickhouse=community, mssql=community, sqlite=certified, oracle=certified, snowflake=community, trino=community, gocosmos=community, spanner=community\n\nThe following is a list of supported drivers, their placeholder style, and their respective DSN formats:\n\n|===\n| Driver | Data Source Name Format\n\n| `clickhouse` \n| https://github.com/ClickHouse/clickhouse-go#dsn[`clickhouse://[username[:password\\]@\\][netloc\\][:port\\]/dbname[?param1=value1\u0026...\u0026paramN=valueN\\]`^] \n\n| `mysql` \n| `[username[:password]@][protocol[(address)]]/dbname[?param1=value1\u0026...\u0026paramN=valueN]` \n\n| `postgres` \n| `postgres://[user[:password]@][netloc][:port][/dbname][?param1=value1\u0026...]` \n\n| `mssql` \n| `sqlserver://[user[:password]@][netloc][:port][?database=dbname\u0026param1=value1\u0026...]` \n\n| `sqlite` \n| `file:/path/to/filename.db[?param\u0026=value1\u0026...]` \n\n| `oracle` \n| `oracle://[username[:password]@][netloc][:port]/service_name?server=server2\u0026server=server3` \n\n| `snowflake` \n| `username[:password]@account_identifier/dbname/schemaname[?param1=value\u0026...\u0026paramN=valueN]` \n\n| `trino` \n| https://github.com/trinodb/trino-go-client#dsn-data-source-name[`http[s\\]://user[:pass\\]@host[:port\\][?parameters\\]`^] \n\n| `gocosmos` \n| https://pkg.go.dev/github.com/microsoft/gocosmos#readme-example-usage[`AccountEndpoint=\u003ccosmosdb-endpoint\u003e;AccountKey=\u003ccosmosdb-account-key\u003e[;TimeoutMs=\u003ctimeout-in-ms\u003e\\][;Version=\u003ccosmosdb-api-version\u003e\\][;DefaultDb/Db=\u003cdb-name\u003e\\][;AutoId=\u003ctrue/false\u003e\\][;InsecureSkipVerify=\u003ctrue/false\u003e\\]`^] \n\n| `spanner` \n| projects/[PROJECT]/instances/[INSTANCE]/databases/[DATABASE] \n|===\n\nPlease note that the `postgres` driver enforces SSL by default, you can override this with the parameter `sslmode=disable` if required.\n\nThe `snowflake` driver supports multiple DSN formats. Please consult https://pkg.go.dev/github.com/snowflakedb/gosnowflake#hdr-Connection_String[the docs^] for more details. For https://docs.snowflake.com/en/user-guide/key-pair-auth.html#configuring-key-pair-authentication[key pair authentication^], the DSN has the following format: `\u003csnowflake_user\u003e@\u003csnowflake_account\u003e/\u003cdb_name\u003e/\u003cschema_name\u003e?warehouse=\u003cwarehouse\u003e\u0026role=\u003crole\u003e\u0026authenticator=snowflake_jwt\u0026privateKey=\u003cbase64_url_encoded_private_key\u003e`, where the value for the `privateKey` parameter can be constructed from an unencrypted RSA private key file `rsa_key.p8` using `openssl enc -d -base64 -in rsa_key.p8 | basenc --base64url -w0` (you can use `gbasenc` insted of `basenc` on OSX if you install `coreutils` via Homebrew). If you have a password-encrypted private key, you can decrypt it using `openssl pkcs8 -in rsa_key_encrypted.p8 -out rsa_key.p8`. Also, make sure fields such as the username are URL-encoded.\n\nThe https://pkg.go.dev/github.com/microsoft/gocosmos[`gocosmos`^] driver is still experimental, but it has support for https://learn.microsoft.com/en-us/azure/cosmos-db/hierarchical-partition-keys[hierarchical partition keys^] as well as https://learn.microsoft.com/en-us/azure/cosmos-db/nosql/how-to-query-container#cross-partition-query[cross-partition queries^]. Please refer to the https://github.com/microsoft/gocosmos/blob/main/SQL.md[SQL notes^] for details.",
          "required": true,
          "default": null,
          "examples": [
            "clickhouse://username:password@host1:9000,host2:9000/database?dial_timeout=200ms\u0026max_execution_time=60",
            "foouser:foopassword@tcp(localhost:3306)/foodb",
            "postgres://foouser:foopass@localhost:5432/foodb?sslmode=disable",
            "oracle://foouser:foopass@localhost:1521/service_name"
          ]
        },
        "init_files": {
          "name": "init_files",
          "type": "string",
          "kind": "array",
          "description": "\nAn optional list of file paths containing SQL statements to execute immediately upon the first connection to the target database. This is a useful way to initialise tables before processing data. Glob patterns are supported, including super globs (double star).\n\nCare should be taken to ensure that the statements are idempotent, and therefore would not cause issues when run multiple times after service restarts. If both `init_statement` and `init_files` are specified the `init_statement` is executed _after_ the `init_files`.\n\nIf a statement fails for any reason a warning log will be emitted but the operation of this component will not be stopped.\n",
          "required": false,
          "default": null,
          "examples": [
            [
              "./init/*.sql"
            ],
            [
              "./foo.sql",
              "./bar.sql"
            ]
          ],
          "advanced": true
        },
        "init_statement": {
          "name": "init_statement",
          "type": "string",
          "kind": "scalar",
          "description": "\nAn optional SQL statement to execute immediately upon the first connection to the target database. This is a useful way to initialise tables before processing data. Care should be taken to ensure that the statement is idempotent, and therefore would not cause issues when run multiple times after service restarts.\n\nIf both `init_statement` and `init_files` are specified the `init_statement` is executed _after_ the `init_files`.\n\nIf the statement fails for any reason a warning log will be emitted but the operation of this component will not be stopped.\n",
          "required": false,
          "default": null,
          "examples": [
            "\nCREATE TABLE IF NOT EXISTS some_table (\n  foo varchar(50) not null,\n  bar integer,\n  baz varchar(50),\n  primary key (foo)\n) WITHOUT ROWID;\n"
          ],
          "advanced": true
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of statements to execute in parallel.",
          "required": true,
          "default": 64
        },
        "queries": {
          "name": "queries",
          "type": "object",
          "kind": "array",
          "description": "A list of statements to run in addition to `query`. When specifying multiple statements, they are all executed within a transaction.",
          "required": false,
          "default": null,
          "children": [
            {
              "name": "query",
              "type": "string",
              "kind": "scalar",
              "description": "The query to execute. The style of placeholder to use depends on the driver, some drivers require question marks (`?`) whereas others expect incrementing dollar signs (`$1`, `$2`, and so on) or colons (`:1`, `:2` and so on). The style to use is outlined in this table:\n\n| Driver | Placeholder Style |\n|---|---|\n| `clickhouse` | Dollar sign |\n| `mysql` | Question mark |\n| `postgres` | Dollar sign |\n| `mssql` | Question mark |\n| `sqlite` | Question mark |\n| `oracle` | Colon |\n| `snowflake` | Question mark |\n| `trino` | Question mark |\n| `gocosmos` | Colon |\n",
              "required": true,
              "default": null
            },
            {
              "name": "args_mapping",
              "type": "string",
              "kind": "scalar",
              "description": "An optional xref:guides:bloblang/about.adoc[Bloblang mapping] which should evaluate to an array of values matching in size to the number of placeholder arguments in the field `query`.",
              "required": false,
              "default": null,
              "examples": [
                "root = [ this.cat.meow, this.doc.woofs[0] ]",
                "root = [ meta(\"user.id\") ]"
              ]
            }
          ]
        },
        "query": {
          "name": "query",
          "type": "string",
          "kind": "scalar",
          "description": "The query to execute. The style of placeholder to use depends on the driver, some drivers require question marks (`?`) whereas others expect incrementing dollar signs (`$1`, `$2`, and so on) or colons (`:1`, `:2` and so on). The style to use is outlined in this table:\n\n| Driver | Placeholder Style |\n|---|---|\n| `clickhouse` | Dollar sign |\n| `mysql` | Question mark |\n| `postgres` | Dollar sign |\n| `mssql` | Question mark |\n| `sqlite` | Question mark |\n| `oracle` | Colon |\n| `snowflake` | Question mark |\n| `trino` | Question mark |\n| `gocosmos` | Colon |\n",
          "required": false,
          "default": null,
          "examples": [
            "INSERT INTO footable (foo, bar, baz) VALUES (?, ?, ?);"
          ]
        },
        "unsafe_dynamic_query": {
          "name": "unsafe_dynamic_query",
          "type": "bool",
          "kind": "scalar",
          "description": "Whether to enable xref:configuration:interpolation.adoc#bloblang-queries[interpolation functions] in the query. Great care should be made to ensure your queries are defended against injection attacks.",
          "required": true,
          "default": false,
          "advanced": true
        }
      }
    },
    "stdout": {
      "name": "stdout",
      "type": "output",
      "source": "upstream",
      "summary": "Prints messages to stdout as a continuous stream of data.",
      "config": {
        "codec": {
          "name": "codec",
          "type": "string",
          "kind": "scalar",
          "description": "The way in which the bytes of messages should be written out into the output data stream. It's possible to write lines using a custom delimiter with the `delim:x` codec, where x is the character sequence custom delimiter.",
          "required": true,
          "default": "lines",
          "examples": [
            "lines",
            "delim:\t",
            "delim:foobar"
          ]
        }
      }
    },
    "subprocess": {
      "name": "subprocess",
      "type": "output",
      "source": "upstream",
      "summary": "Executes a command, runs it as a subprocess, and writes messages to it over stdin.",
      "description": "\nMessages are written according to a specified codec. The process is expected to terminate gracefully when stdin is closed.\n\nIf the subprocess exits unexpectedly then Redpanda Connect will log anything printed to stderr and will log the exit code, and will attempt to execute the command again until success.\n\nThe execution environment of the subprocess is the same as the Redpanda Connect instance, including environment variables and the current working directory.",
      "config": {
        "args": {
          "name": "args",
          "type": "string",
          "kind": "array",
          "description": "A list of arguments to provide the command.",
          "required": true,
          "default": []
        },
        "codec": {
          "name": "codec",
          "type": "string",
          "kind": "scalar",
          "description": "The way in which messages should be written to the subprocess.",
          "required": true,
          "default": "lines",
          "options": [
            "lines"
          ]
        },
        "name": {
          "name": "name",
          "type": "string",
          "kind": "scalar",
          "description": "The command to execute as a subprocess.",
          "required": true,
          "default": null
        }
      }
    },
    "switch": {
      "name": "switch",
      "type": "output",
      "source": "upstream",
      "summary": "The switch output type allows you to route messages to different outputs based on their contents.",
      "description": "Messages that do not pass the check of a single output case are effectively dropped. In order to prevent this outcome set the field \u003c\u003cstrict_mode, `strict_mode`\u003e\u003e to `true`, in which case messages that do not pass at least one case are considered failed and will be nacked and/or reprocessed depending on your input.",
      "config": {
        "cases": {
          "name": "cases",
          "type": "object",
          "kind": "array",
          "description": "A list of switch cases, outlining outputs that can be routed to.",
          "required": true,
          "default": null,
          "examples": [
            [
              {
                "check": "this.urls.contains(\"http://benthos.dev\")",
                "continue": true,
                "output": {
                  "cache": {
                    "key": "${!json(\"id\")}",
                    "target": "foo"
                  }
                }
              },
              {
                "output": {
                  "s3": {
                    "bucket": "bar",
                    "path": "${!json(\"id\")}"
                  }
                }
              }
            ]
          ],
          "children": [
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should be routed to the case output. If left empty the case always passes.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"foo\"",
                "this.contents.urls.contains(\"https://benthos.dev/\")"
              ]
            },
            {
              "name": "output",
              "type": "output",
              "kind": "scalar",
              "description": "An xref:components:outputs/about.adoc[output] for messages that pass the check to be routed to.",
              "required": true,
              "default": null
            },
            {
              "name": "continue",
              "type": "bool",
              "kind": "scalar",
              "description": "Indicates whether, if this case passes for a message, the next case should also be tested.",
              "required": true,
              "default": false,
              "advanced": true
            }
          ]
        },
        "retry_until_success": {
          "name": "retry_until_success",
          "type": "bool",
          "kind": "scalar",
          "description": "\nIf a selected output fails to send a message this field determines whether it is reattempted indefinitely. If set to false the error is instead propagated back to the input level.\n\nIf a message can be routed to \u003e1 outputs it is usually best to set this to true in order to avoid duplicate messages being routed to an output.",
          "required": true,
          "default": false
        },
        "strict_mode": {
          "name": "strict_mode",
          "type": "bool",
          "kind": "scalar",
          "description": "This field determines whether an error should be reported if no condition is met. If set to true, an error is propagated back to the input level. The default behavior is false, which will drop the message.",
          "required": true,
          "default": false,
          "advanced": true
        }
      }
    },
    "sync_response": {
      "name": "sync_response",
      "type": "output",
      "source": "upstream",
      "summary": "Returns the final message payload back to the input origin of the message, where it is dealt with according to that specific input type.",
      "description": "\nFor most inputs this mechanism is ignored entirely, in which case the sync response is dropped without penalty. It is therefore safe to use this output even when combining input types that might not have support for sync responses. An example of an input able to utilize this is the `http_server`.\n\nIt is safe to combine this output with others using broker types. For example, with the `http_server` input we could send the payload to a Kafka topic and also send a modified payload back with:\n\n```yaml\ninput:\n  http_server:\n    path: /post\noutput:\n  broker:\n    pattern: fan_out\n    outputs:\n      - kafka:\n          addresses: [ TODO:9092 ]\n          topic: foo_topic\n      - sync_response: {}\n        processors:\n          - mapping: 'root = content().uppercase()'\n```\n\nUsing the above example and posting the message 'hello world' to the endpoint `/post` Redpanda Connect would send it unchanged to the topic `foo_topic` and also respond with 'HELLO WORLD'.\n\nFor more information please read xref:guides:sync_responses.adoc[synchronous responses].",
      "config": {}
    },
    "timeplus": {
      "name": "timeplus",
      "type": "output",
      "source": "upstream",
      "summary": "Sends message to a Timeplus Enterprise stream via ingest endpoint",
      "description": "\nThis output can send message to Timeplus Enterprise Cloud, Timeplus Enterprise (self-hosted) or directly to timeplusd.\n\nThis output accepts structured message only. It also expects all message contains the same keys and matches the schema of the destination stream. If the upstream source or pipeline returns\nunstructured message such as string, please refer to the \"Unstructured message\" example.",
      "config": {
        "apikey": {
          "name": "apikey",
          "type": "string",
          "kind": "scalar",
          "description": "The API key. Required if you are sending message to Timeplus Enterprise Cloud",
          "required": false,
          "default": null
        },
        "batching": {
          "name": "batching",
          "type": "object",
          "kind": "",
          "description": "\nAllows you to configure a xref:configuration:batching.adoc[batching policy].",
          "required": true,
          "default": null,
          "examples": [
            {
              "byte_size": 5000,
              "count": 0,
              "period": "1s"
            },
            {
              "count": 10,
              "period": "1s"
            },
            {
              "check": "this.contains(\"END BATCH\")",
              "count": 0,
              "period": "1m"
            }
          ],
          "children": [
            {
              "name": "count",
              "type": "int",
              "kind": "scalar",
              "description": "A number of messages at which the batch should be flushed. If `0` disables count based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "byte_size",
              "type": "int",
              "kind": "scalar",
              "description": "An amount of bytes at which the batch should be flushed. If `0` disables size based batching.",
              "required": true,
              "default": 0
            },
            {
              "name": "period",
              "type": "string",
              "kind": "scalar",
              "description": "A period in which an incomplete batch should be flushed regardless of its size.",
              "required": true,
              "default": "",
              "examples": [
                "1s",
                "1m",
                "500ms"
              ]
            },
            {
              "name": "check",
              "type": "string",
              "kind": "scalar",
              "description": "A xref:guides:bloblang/about.adoc[Bloblang query] that should return a boolean value indicating whether a message should end a batch.",
              "required": true,
              "default": "",
              "examples": [
                "this.type == \"end_of_transaction\""
              ]
            },
            {
              "name": "processors",
              "type": "processor",
              "kind": "array",
              "description": "A list of xref:components:processors/about.adoc[processors] to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.",
              "required": false,
              "default": null,
              "examples": [
                [
                  {
                    "archive": {
                      "format": "concatenate"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "lines"
                    }
                  }
                ],
                [
                  {
                    "archive": {
                      "format": "json_array"
                    }
                  }
                ]
              ],
              "advanced": true
            }
          ]
        },
        "max_in_flight": {
          "name": "max_in_flight",
          "type": "int",
          "kind": "scalar",
          "description": "The maximum number of messages to have in flight at a given time. Increase this to improve throughput.",
          "required": true,
          "default": 64
        },
        "password": {
          "name": "password",
          "type": "string",
          "kind": "scalar",
          "description": "The password. Required if you are sending message to Timeplus Enterprise (self-hosted) or timeplusd",
          "required": false,
          "default": null
        },
        "stream": {
          "name": "stream",
          "type": "string",
          "kind": "scalar",
          "description": "The name of the stream. Make sure the schema of the stream matches the input",
          "required": true,
          "default": null
        },
        "target": {
          "name": "target",
          "type": "string",
          "kind": "scalar",
          "description": "The destination type, either Timeplus Enterprise or timeplusd",
          "required": true,
          "default": "timeplus",
          "options": [
            "timeplus",
            "timeplusd"
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The url should always include schema and host.",
          "required": true,
          "default": "https://us-west-2.timeplus.cloud",
          "examples": [
            "http://localhost:8000",
            "http://127.0.0.1:3218"
          ]
        },
        "username": {
          "name": "username",
          "type": "string",
          "kind": "scalar",
          "description": "The username. Required if you are sending message to Timeplus Enterprise (self-hosted) or timeplusd",
          "required": false,
          "default": null
        },
        "workspace": {
          "name": "workspace",
          "type": "string",
          "kind": "scalar",
          "description": "ID of the workspace. Required if target is `timeplus`.",
          "required": false,
          "default": null
        }
      }
    },
    "uns": {
      "name": "uns",
      "type": "output",
      "source": "benthos-umh",
      "summary": "Publishes records to UMH Core's Kafka (Redpanda) topic `umh.messages`.",
      "description": "\nInside UMH Core you usually configure **nothing**:\n\n    output:\n      uns: {}\n\nThe plugin connects to Redpanda on localhost:9092, batches 100 records\nor 100 ms, and writes them to *umh.messages*.  The Kafka key is taken\nfrom '${! meta(\"umh_topic\") }' (set automatically by the tag_processor,\nBloblang, or Node-RED JS).  Outside UMH Core you may override the broker\nor add a custom 'bridged_by' header for traceability.\n",
      "config": {
        "bridged_by": {
          "name": "bridged_by",
          "type": "string",
          "kind": "scalar",
          "description": "\nTraceability header.  Defaults to 'umh-core' but is automatically\noverwritten by UMH Core when the container runs as a protocol-converter:\n'protocol-converter-\u003cINSTANCE\u003e-\u003cNAME\u003e'.\n",
          "required": true,
          "default": "umh_core"
        },
        "broker_address": {
          "name": "broker_address",
          "type": "string",
          "kind": "scalar",
          "description": "\nKafka / Redpanda bootstrap list.  Comma-separated if you have multiple\nbrokers, e.g. \"broker1:9092,broker2:9092\".\n\nDefault 'localhost:9092' is correct for every UMH Core installation.\n",
          "required": true,
          "default": "localhost:9092"
        },
        "schema_registry_url": {
          "name": "schema_registry_url",
          "type": "string",
          "kind": "scalar",
          "description": "\nSchema registry URL for data contract validation.  If not provided, it\nwill be automatically derived from the first broker in the broker_address\nlist by changing the port to 8081.\n\nExample: If broker_address is \"localhost:9092\", the schema registry URL\nwill be \"http://localhost:8081\".\n",
          "required": false,
          "default": null,
          "examples": [
            "http://localhost:8081",
            "https://schema-registry.example.com:8081"
          ]
        },
        "umh_topic": {
          "name": "umh_topic",
          "type": "string",
          "kind": "scalar",
          "description": "\nThe **Kafka key** for every record.  Must follow the UMH naming pattern\n'umh.v1.\u003centerprise\u003e.\u003csite\u003e.\u003carea\u003e.\u003cdata_contract\u003e[.\u003cvirtual_path\u003e].\u003ctag\u003e'.\n\nLeave it at the default '${! meta(\"umh_topic\") }' if you use the tag_processor\nor set it in Bloblang / Node-RED JS.\n\nAny character not matching [a-zA-Z0-9._-] is replaced by '_'.\n",
          "required": true,
          "default": "${! meta(\"umh_topic\") }",
          "examples": [
            "${! meta(\"umh_topic\") }",
            "umh.v1.enterprise.site.area.historian"
          ]
        }
      }
    },
    "websocket": {
      "name": "websocket",
      "type": "output",
      "source": "upstream",
      "summary": "Sends messages to an HTTP server via a websocket connection.",
      "config": {
        "basic_auth": {
          "name": "basic_auth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify basic authentication.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use basic authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "username",
              "type": "string",
              "kind": "scalar",
              "description": "A username to authenticate as.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "password",
              "type": "string",
              "kind": "scalar",
              "description": "A password to authenticate with.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "jwt": {
          "name": "jwt",
          "type": "object",
          "kind": "scalar",
          "description": "BETA: Allows you to specify JWT authentication.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use JWT authentication in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "private_key_file",
              "type": "string",
              "kind": "scalar",
              "description": "A file with the PEM encoded via PKCS1 or PKCS8 as private key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "signing_method",
              "type": "string",
              "kind": "scalar",
              "description": "A method used to sign the token such as RS256, RS384, RS512 or EdDSA.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "claims",
              "type": "unknown",
              "kind": "map",
              "description": "A value used to identify the claims that issued the JWT.",
              "required": true,
              "default": {},
              "advanced": true
            },
            {
              "name": "headers",
              "type": "unknown",
              "kind": "map",
              "description": "Add optional key/value headers to the JWT.",
              "required": true,
              "default": {},
              "advanced": true
            }
          ]
        },
        "oauth": {
          "name": "oauth",
          "type": "object",
          "kind": "scalar",
          "description": "Allows you to specify open authentication via OAuth version 1.",
          "required": false,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to use OAuth version 1 in requests.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "consumer_key",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to identify the client to the service provider.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "consumer_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret used to establish ownership of the consumer key.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "access_token",
              "type": "string",
              "kind": "scalar",
              "description": "A value used to gain access to the protected resources on behalf of the user.",
              "required": true,
              "default": "",
              "advanced": true
            },
            {
              "name": "access_token_secret",
              "type": "string",
              "kind": "scalar",
              "description": "A secret provided in order to establish ownership of a given access token.",
              "required": true,
              "default": "",
              "advanced": true
            }
          ]
        },
        "proxy_url": {
          "name": "proxy_url",
          "type": "string",
          "kind": "scalar",
          "description": "An optional HTTP proxy URL.",
          "required": false,
          "default": null,
          "advanced": true
        },
        "tls": {
          "name": "tls",
          "type": "object",
          "kind": "scalar",
          "description": "Custom TLS settings can be used to override system defaults.",
          "required": true,
          "default": null,
          "advanced": true,
          "children": [
            {
              "name": "enabled",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether custom TLS settings are enabled.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "skip_cert_verify",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to skip server side certificate verification.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "enable_renegotiation",
              "type": "bool",
              "kind": "scalar",
              "description": "Whether to allow the remote server to repeatedly request renegotiation. Enable this option if you're seeing the error message `local error: tls: no renegotiation`.",
              "required": true,
              "default": false,
              "advanced": true
            },
            {
              "name": "root_cas",
              "type": "string",
              "kind": "scalar",
              "description": "An optional root certificate authority to use. This is a string, representing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
              ],
              "advanced": true
            },
            {
              "name": "root_cas_file",
              "type": "string",
              "kind": "scalar",
              "description": "An optional path of a root certificate authority file to use. This is a file, often with a .pem extension, containing a certificate chain from the parent trusted root certificate, to possible intermediate signing certificates, to the host certificate.",
              "required": true,
              "default": "",
              "examples": [
                "./root_cas.pem"
              ],
              "advanced": true
            },
            {
              "name": "client_certs",
              "type": "object",
              "kind": "array",
              "description": "A list of client certificates to use. For each certificate either the fields `cert` and `key`, or `cert_file` and `key_file` should be specified, but not both.",
              "required": true,
              "default": [],
              "examples": [
                [
                  {
                    "cert": "foo",
                    "key": "bar"
                  }
                ],
                [
                  {
                    "cert_file": "./example.pem",
                    "key_file": "./example.key"
                  }
                ]
              ],
              "advanced": true,
              "children": [
                {
                  "name": "cert",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "cert_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "key_file",
                  "type": "string",
                  "kind": "scalar",
                  "description": "The path of a certificate key to use.",
                  "required": true,
                  "default": "",
                  "advanced": true
                },
                {
                  "name": "password",
                  "type": "string",
                  "kind": "scalar",
                  "description": "A plain text password for when the private key is password encrypted in PKCS#1 or PKCS#8 format. The obsolete `pbeWithMD5AndDES-CBC` algorithm is not supported for the PKCS#8 format.\n\nBecause the obsolete pbeWithMD5AndDES-CBC algorithm does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.\n",
                  "required": true,
                  "default": "",
                  "examples": [
                    "foo",
                    "${KEY_PASSWORD}"
                  ],
                  "advanced": true
                }
              ]
            }
          ]
        },
        "url": {
          "name": "url",
          "type": "string",
          "kind": "scalar",
          "description": "The URL to connect to.",
          "required": true,
          "default": null
        }
      }
    }
  }
}