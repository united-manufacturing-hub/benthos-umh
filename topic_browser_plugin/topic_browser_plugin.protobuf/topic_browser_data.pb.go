// Copyright 2025 UMH Systems GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


// Copyright 2025 UMH Systems GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ---------------------------------------------------------------------------
//
// Tag-Processor → FSM wire contracts
// ----------------------------------
// These messages are emitted by the Benthos **tag_processor** and consumed
// exclusively by the finite-state-machine (FSM) that drives UMH-Core.  Once
// inside the FSM the data is reshaped into other structs, and further hops
// (Communicator → Front-End) use plain JSON, not this protobuf.
//
// Typical flow
// ────────────
//    ┌───────────┐   UnsBundle  (LZ4 + hex)   ┌─────────────┐
//    │ tag_proc. │ ───────────────────────────►│   FSM       │
//    └───────────┘                             └─────────────┘
//      UnsBundle.events[*] : EventTableEntry         (~ring-100)
//      UnsBundle.uns_map   : TopicInfo (deltas only)
//
// ---------------------------------------------------------------------------

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.12
// source: topic_browser_data.proto

package topic_browser_plugin_protobuf

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// Each event emitted by the tag-processor falls into **exactly one** payload
// family.
//
// ▸ TIMESERIES … the classic "one tag, one value, one timestamp" sensor point
// ▸ RELATIONAL  … a complete, self-contained JSON document (batch header,
//
//	alarm object, recipe, …) that already belongs together
//
// Anything else is rejected at ingest-time; mixing formats on a single topic
// would break the "one-topic-one-shape" contract.
//
// See full rationale at: https://docs.umh.app/usage/unified-namespace/payload-formats
type PayloadFormat int32

const (
	PayloadFormat_PAYLOAD_FORMAT_UNSPECIFIED PayloadFormat = 0 // this should never happen, can only happen if it wasn't set --> message should be rejected
	PayloadFormat_TIMESERIES                 PayloadFormat = 1 // one scalar value + timestamp (e.g. a float)
	PayloadFormat_RELATIONAL                 PayloadFormat = 2 // full JSON object (e.g. a JSON object)
)

// Enum value maps for PayloadFormat.
var (
	PayloadFormat_name = map[int32]string{
		0: "PAYLOAD_FORMAT_UNSPECIFIED",
		1: "TIMESERIES",
		2: "RELATIONAL",
	}
	PayloadFormat_value = map[string]int32{
		"PAYLOAD_FORMAT_UNSPECIFIED": 0,
		"TIMESERIES":                 1,
		"RELATIONAL":                 2,
	}
)

func (x PayloadFormat) Enum() *PayloadFormat {
	p := new(PayloadFormat)
	*p = x
	return p
}

func (x PayloadFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PayloadFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_topic_browser_data_proto_enumTypes[0].Descriptor()
}

func (PayloadFormat) Type() protoreflect.EnumType {
	return &file_topic_browser_data_proto_enumTypes[0]
}

func (x PayloadFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PayloadFormat.Descriptor instead.
func (PayloadFormat) EnumDescriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{0}
}

// *
// For **TIMESERIES** payloads we also capture the scalar's *primitive* type.
// The Management Console uses this hint to pick a sensible default renderer:
//
//	NUMERIC  → plot on a line/area chart
//	STRING   → show last value in a table or status badge
//	BOOLEAN  → treat as STRING
//
// Storing the type here keeps the TimeSeriesPayload tiny and avoids costly
// JSON introspection on the front-end.
type ScalarType int32

const (
	ScalarType_SCALAR_TYPE_UNSPECIFIED ScalarType = 0 // this should never happen, can only happen if it wasn't set --> message should be rejected
	ScalarType_NUMERIC                 ScalarType = 1
	ScalarType_STRING                  ScalarType = 2
	ScalarType_BOOLEAN                 ScalarType = 3
)

// Enum value maps for ScalarType.
var (
	ScalarType_name = map[int32]string{
		0: "SCALAR_TYPE_UNSPECIFIED",
		1: "NUMERIC",
		2: "STRING",
		3: "BOOLEAN",
	}
	ScalarType_value = map[string]int32{
		"SCALAR_TYPE_UNSPECIFIED": 0,
		"NUMERIC":                 1,
		"STRING":                  2,
		"BOOLEAN":                 3,
	}
)

func (x ScalarType) Enum() *ScalarType {
	p := new(ScalarType)
	*p = x
	return p
}

func (x ScalarType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ScalarType) Descriptor() protoreflect.EnumDescriptor {
	return file_topic_browser_data_proto_enumTypes[1].Descriptor()
}

func (ScalarType) Type() protoreflect.EnumType {
	return &file_topic_browser_data_proto_enumTypes[1]
}

func (x ScalarType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ScalarType.Descriptor instead.
func (ScalarType) EnumDescriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{1}
}

// *
// TopicInfo breaks one UNS topic into its hierarchy levels plus a few aids for
// downstream filtering.  The FSM stores each unique TopicInfo once and refers
// to it from many events via `uns_tree_id`, saving space.
type TopicInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Physical ISA-95 (or custom) hierarchy; level0 must never be empty
	Level0 string                  `protobuf:"bytes,1,opt,name=level0,proto3" json:"level0,omitempty"` // e.g. "corpA"
	Level1 *wrapperspb.StringValue `protobuf:"bytes,2,opt,name=level1,proto3" json:"level1,omitempty"` // e.g. "plant-1"
	Level2 *wrapperspb.StringValue `protobuf:"bytes,3,opt,name=level2,proto3" json:"level2,omitempty"` // e.g. "line-4"
	Level3 *wrapperspb.StringValue `protobuf:"bytes,4,opt,name=level3,proto3" json:"level3,omitempty"` // e.g. "pump-41"
	Level4 *wrapperspb.StringValue `protobuf:"bytes,5,opt,name=level4,proto3" json:"level4,omitempty"`
	Level5 *wrapperspb.StringValue `protobuf:"bytes,6,opt,name=level5,proto3" json:"level5,omitempty"`
	// Data contract that governs payload shape, e.g. "_historian", and the virtual_path
	DataContract string `protobuf:"bytes,7,opt,name=data_contract,json=dataContract,proto3" json:"data_contract,omitempty"`
	// Optional non-physical grouping path (axis.x.position, diagnostics.*, …)
	VirtualPath *wrapperspb.StringValue `protobuf:"bytes,8,opt,name=virtual_path,json=virtualPath,proto3" json:"virtual_path,omitempty"`
	// Aggregated Kafka-header *metadata* for this topic.
	// ───────────────────────────────────────────────────
	//   - Every time the tag_processor sees a Kafka header on this topic it stores
	//     the *latest* value here, keyed by header name.
	//   - The map therefore holds "last known" values for headers such as
	//     `unit`, `serial_number`, `plc_address`, …—anything a bridge, PLC or
	//     stream-processor chose to add.
	//   - The front-end can search or facet by these keys without scanning live
	//     event traffic; it only needs the TopicInfo cache.
	//   - This is *not* duplicated data: EventKafka.headers (inside EventTableEntry)
	//     keeps the raw per-event headers for debugging, whereas this field is
	//     a compact, topic-level index optimised for look-ups and UI filters.
	Metadata      map[string]string `protobuf:"bytes,9,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopicInfo) Reset() {
	*x = TopicInfo{}
	mi := &file_topic_browser_data_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopicInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopicInfo) ProtoMessage() {}

func (x *TopicInfo) ProtoReflect() protoreflect.Message {
	mi := &file_topic_browser_data_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopicInfo.ProtoReflect.Descriptor instead.
func (*TopicInfo) Descriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{0}
}

func (x *TopicInfo) GetLevel0() string {
	if x != nil {
		return x.Level0
	}
	return ""
}

func (x *TopicInfo) GetLevel1() *wrapperspb.StringValue {
	if x != nil {
		return x.Level1
	}
	return nil
}

func (x *TopicInfo) GetLevel2() *wrapperspb.StringValue {
	if x != nil {
		return x.Level2
	}
	return nil
}

func (x *TopicInfo) GetLevel3() *wrapperspb.StringValue {
	if x != nil {
		return x.Level3
	}
	return nil
}

func (x *TopicInfo) GetLevel4() *wrapperspb.StringValue {
	if x != nil {
		return x.Level4
	}
	return nil
}

func (x *TopicInfo) GetLevel5() *wrapperspb.StringValue {
	if x != nil {
		return x.Level5
	}
	return nil
}

func (x *TopicInfo) GetDataContract() string {
	if x != nil {
		return x.DataContract
	}
	return ""
}

func (x *TopicInfo) GetVirtualPath() *wrapperspb.StringValue {
	if x != nil {
		return x.VirtualPath
	}
	return nil
}

func (x *TopicInfo) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// TopicMap provides a fast lookup structure for topics using their UNS Tree ID as the key.
// The UNS Tree ID is a hash of the TopicInfo fields, providing a compact unique identifier.
type TopicMap struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Key is the UNS Tree id, which is a hash over the TopicInfo entries.
	// Using a hash instead of the full topic name reduces storage requirements while maintaining uniqueness.
	Entries       map[string]*TopicInfo `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopicMap) Reset() {
	*x = TopicMap{}
	mi := &file_topic_browser_data_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopicMap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopicMap) ProtoMessage() {}

func (x *TopicMap) ProtoReflect() protoreflect.Message {
	mi := &file_topic_browser_data_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopicMap.ProtoReflect.Descriptor instead.
func (*TopicMap) Descriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{1}
}

func (x *TopicMap) GetEntries() map[string]*TopicInfo {
	if x != nil {
		return x.Entries
	}
	return nil
}

// * Copy of the Kafka message as the tag-processor received it.
type EventKafka struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Headers       map[string]string      `protobuf:"bytes,1,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Payload       []byte                 `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EventKafka) Reset() {
	*x = EventKafka{}
	mi := &file_topic_browser_data_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventKafka) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventKafka) ProtoMessage() {}

func (x *EventKafka) ProtoReflect() protoreflect.Message {
	mi := &file_topic_browser_data_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventKafka.ProtoReflect.Descriptor instead.
func (*EventKafka) Descriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{2}
}

func (x *EventKafka) GetHeaders() map[string]string {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *EventKafka) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

// *
// TimeSeriesPayload  ─ the canonical UMH "one-tag / one-value" shape
// ---------------------------------------------------------------
//   - Holds exactly one scalar *and* the moment it was observed at the source.
//   - `scalar_type` mirrors the ScalarType enum so the UI can decide quickly
//     whether the value should be plotted (numeric), shown as text (string) or
//     rendered as a state indicator (boolean).
//   - `value` is wrapped in google.protobuf.Any to keep the wire payload tiny
//     while still allowing three primitive types:
//     ▸ google.protobuf.DoubleValue   → NUMERIC
//     ▸ google.protobuf.StringValue   → STRING
//     ▸ google.protobuf.BoolValue     → BOOLEAN
//   - `timestamp_ms` is the **source** timestamp (epoch-ms).  It describes when
//     the PLC / device generated the value, *not* when Kafka wrote the message.
//     The latter lives in `EventTableEntry.produced_at_ms` for debugging.
type TimeSeriesPayload struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ScalarType    ScalarType             `protobuf:"varint,1,opt,name=scalar_type,json=scalarType,proto3,enum=umh.events.ScalarType" json:"scalar_type,omitempty"` // numeric / string / boolean
	Value         *anypb.Any             `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`                                                         // DoubleValue, StringValue, BoolValue
	TimestampMs   int64                  `protobuf:"varint,3,opt,name=timestamp_ms,json=timestampMs,proto3" json:"timestamp_ms,omitempty"`                         // source time
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TimeSeriesPayload) Reset() {
	*x = TimeSeriesPayload{}
	mi := &file_topic_browser_data_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimeSeriesPayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimeSeriesPayload) ProtoMessage() {}

func (x *TimeSeriesPayload) ProtoReflect() protoreflect.Message {
	mi := &file_topic_browser_data_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimeSeriesPayload.ProtoReflect.Descriptor instead.
func (*TimeSeriesPayload) Descriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{3}
}

func (x *TimeSeriesPayload) GetScalarType() ScalarType {
	if x != nil {
		return x.ScalarType
	}
	return ScalarType_SCALAR_TYPE_UNSPECIFIED
}

func (x *TimeSeriesPayload) GetValue() *anypb.Any {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *TimeSeriesPayload) GetTimestampMs() int64 {
	if x != nil {
		return x.TimestampMs
	}
	return 0
}

// *
// RelationalPayload  ─ full JSON document shape
// ---------------------------------------------
//   - Used when an event already bundles multiple related fields (order header,
//     batch summary, set-point list, …) that *belong together*.
//   - Payload arrives as valid UTF-8 JSON bytes; no extra framing or base64.
//   - Downstream processors are free to validate this blob against the data
//     contract referenced in TopicInfo.data_contract.
type RelationalPayload struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Json          []byte                 `protobuf:"bytes,1,opt,name=json,proto3" json:"json,omitempty"` // already UTF-8 JSON bytes
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RelationalPayload) Reset() {
	*x = RelationalPayload{}
	mi := &file_topic_browser_data_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelationalPayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelationalPayload) ProtoMessage() {}

func (x *RelationalPayload) ProtoReflect() protoreflect.Message {
	mi := &file_topic_browser_data_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelationalPayload.ProtoReflect.Descriptor instead.
func (*RelationalPayload) Descriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{4}
}

func (x *RelationalPayload) GetJson() []byte {
	if x != nil {
		return x.Json
	}
	return nil
}

// *
// EventTableEntry – one *normalised* UNS event
// -------------------------------------------
// The tag-processor converts every raw Kafka record into exactly one of these
// entries and drops it into the ring-buffer that later becomes
// UnsBundle.events[*].
//
// Why the split?
//   - **TopicInfo** (in UnsBundle.uns_map) describes the *where* and *what* of
//     the signal and changes rarely.
//   - **EventTableEntry** carries the *latest value* plus a few breadcrumbs
//     that make troubleshooting painless.
//
// Field-by-field rundown
// ──────────────────────
// uns_tree_id      – 64-bit xxHash of the TopicInfo.  Lets the Frontend join the
//
//	payload back to its TopicInfo without repeating long
//	strings in every row.
//
// payload          – `oneof` branch holding either:
//
//	▸ TimeSeriesPayload  (scalar + timestamp_ms)
//	▸ RelationalPayload  (full JSON document)
//
// raw_kafka_msg    – Exact copy of the message *before* the tag-processor
//
//	touched it (headers + value only).  Included **solely**
//	for deep debugging, packet captures, etc.  Normal runtime
//	logic should ignore it.
//
// bridged_by       – Ordered list of Benthos instances the record traversed.
//
//	Helpful when chains of bridges reshape or forward the same topic multiple times to get the trace of the record.
//
// produced_at_ms   – Kafka's own timestamp (epoch-ms) when the record was
//
//	written to the UNS.  Use this to spot buffering or
//	network latency.  Do *not* confuse with
//	TimeSeriesPayload.timestamp_ms, which is the **source**
//	time inside the PLC/device.
type EventTableEntry struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	UnsTreeId string                 `protobuf:"bytes,1,opt,name=uns_tree_id,json=unsTreeId,proto3" json:"uns_tree_id,omitempty"` // xxHash over TopicInfo
	// Types that are valid to be assigned to Payload:
	//
	//	*EventTableEntry_Ts
	//	*EventTableEntry_Rel
	Payload       isEventTableEntry_Payload `protobuf_oneof:"payload"`
	RawKafkaMsg   *EventKafka               `protobuf:"bytes,5,opt,name=raw_kafka_msg,json=rawKafkaMsg,proto3" json:"raw_kafka_msg,omitempty"`     // headers + value, for debugging
	BridgedBy     []string                  `protobuf:"bytes,6,rep,name=bridged_by,json=bridgedBy,proto3" json:"bridged_by,omitempty"`             // Benthos hops (oldest → newest)
	ProducedAtMs  uint64                    `protobuf:"varint,7,opt,name=produced_at_ms,json=producedAtMs,proto3" json:"produced_at_ms,omitempty"` // Kafka write time, epoch-ms
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EventTableEntry) Reset() {
	*x = EventTableEntry{}
	mi := &file_topic_browser_data_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventTableEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTableEntry) ProtoMessage() {}

func (x *EventTableEntry) ProtoReflect() protoreflect.Message {
	mi := &file_topic_browser_data_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventTableEntry.ProtoReflect.Descriptor instead.
func (*EventTableEntry) Descriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{5}
}

func (x *EventTableEntry) GetUnsTreeId() string {
	if x != nil {
		return x.UnsTreeId
	}
	return ""
}

func (x *EventTableEntry) GetPayload() isEventTableEntry_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *EventTableEntry) GetTs() *TimeSeriesPayload {
	if x != nil {
		if x, ok := x.Payload.(*EventTableEntry_Ts); ok {
			return x.Ts
		}
	}
	return nil
}

func (x *EventTableEntry) GetRel() *RelationalPayload {
	if x != nil {
		if x, ok := x.Payload.(*EventTableEntry_Rel); ok {
			return x.Rel
		}
	}
	return nil
}

func (x *EventTableEntry) GetRawKafkaMsg() *EventKafka {
	if x != nil {
		return x.RawKafkaMsg
	}
	return nil
}

func (x *EventTableEntry) GetBridgedBy() []string {
	if x != nil {
		return x.BridgedBy
	}
	return nil
}

func (x *EventTableEntry) GetProducedAtMs() uint64 {
	if x != nil {
		return x.ProducedAtMs
	}
	return 0
}

type isEventTableEntry_Payload interface {
	isEventTableEntry_Payload()
}

type EventTableEntry_Ts struct {
	Ts *TimeSeriesPayload `protobuf:"bytes,10,opt,name=ts,proto3,oneof"`
}

type EventTableEntry_Rel struct {
	Rel *RelationalPayload `protobuf:"bytes,11,opt,name=rel,proto3,oneof"`
}

func (*EventTableEntry_Ts) isEventTableEntry_Payload() {}

func (*EventTableEntry_Rel) isEventTableEntry_Payload() {}

// EventTable contains a batch of processed events.
type EventTable struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Entries       []*EventTableEntry     `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EventTable) Reset() {
	*x = EventTable{}
	mi := &file_topic_browser_data_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventTable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTable) ProtoMessage() {}

func (x *EventTable) ProtoReflect() protoreflect.Message {
	mi := &file_topic_browser_data_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventTable.ProtoReflect.Descriptor instead.
func (*EventTable) Descriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{6}
}

func (x *EventTable) GetEntries() []*EventTableEntry {
	if x != nil {
		return x.Entries
	}
	return nil
}

// *
// A single frame delivered to the FSM:
//   - `uns_map`  – any new / changed TopicInfo
//   - `events`   – matching EventTable entries
type UnsBundle struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UnsMap        *TopicMap              `protobuf:"bytes,1,opt,name=uns_map,json=unsMap,proto3" json:"uns_map,omitempty"` // Map of new or changed topics
	Events        *EventTable            `protobuf:"bytes,2,opt,name=events,proto3" json:"events,omitempty"`               // Events associated with these topics
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnsBundle) Reset() {
	*x = UnsBundle{}
	mi := &file_topic_browser_data_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnsBundle) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnsBundle) ProtoMessage() {}

func (x *UnsBundle) ProtoReflect() protoreflect.Message {
	mi := &file_topic_browser_data_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnsBundle.ProtoReflect.Descriptor instead.
func (*UnsBundle) Descriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{7}
}

func (x *UnsBundle) GetUnsMap() *TopicMap {
	if x != nil {
		return x.UnsMap
	}
	return nil
}

func (x *UnsBundle) GetEvents() *EventTable {
	if x != nil {
		return x.Events
	}
	return nil
}

var File_topic_browser_data_proto protoreflect.FileDescriptor

const file_topic_browser_data_proto_rawDesc = "" +
	"\n" +
	"\x18topic_browser_data.proto\x12\n" +
	"umh.events\x1a\x1egoogle/protobuf/wrappers.proto\x1a\x19google/protobuf/any.proto\"\x95\x04\n" +
	"\tTopicInfo\x12\x16\n" +
	"\x06level0\x18\x01 \x01(\tR\x06level0\x124\n" +
	"\x06level1\x18\x02 \x01(\v2\x1c.google.protobuf.StringValueR\x06level1\x124\n" +
	"\x06level2\x18\x03 \x01(\v2\x1c.google.protobuf.StringValueR\x06level2\x124\n" +
	"\x06level3\x18\x04 \x01(\v2\x1c.google.protobuf.StringValueR\x06level3\x124\n" +
	"\x06level4\x18\x05 \x01(\v2\x1c.google.protobuf.StringValueR\x06level4\x124\n" +
	"\x06level5\x18\x06 \x01(\v2\x1c.google.protobuf.StringValueR\x06level5\x12#\n" +
	"\rdata_contract\x18\a \x01(\tR\fdataContract\x12?\n" +
	"\fvirtual_path\x18\b \x01(\v2\x1c.google.protobuf.StringValueR\vvirtualPath\x12?\n" +
	"\bmetadata\x18\t \x03(\v2#.umh.events.TopicInfo.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x9a\x01\n" +
	"\bTopicMap\x12;\n" +
	"\aentries\x18\x01 \x03(\v2!.umh.events.TopicMap.EntriesEntryR\aentries\x1aQ\n" +
	"\fEntriesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12+\n" +
	"\x05value\x18\x02 \x01(\v2\x15.umh.events.TopicInfoR\x05value:\x028\x01\"\xa1\x01\n" +
	"\n" +
	"EventKafka\x12=\n" +
	"\aheaders\x18\x01 \x03(\v2#.umh.events.EventKafka.HeadersEntryR\aheaders\x12\x18\n" +
	"\apayload\x18\x02 \x01(\fR\apayload\x1a:\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x9b\x01\n" +
	"\x11TimeSeriesPayload\x127\n" +
	"\vscalar_type\x18\x01 \x01(\x0e2\x16.umh.events.ScalarTypeR\n" +
	"scalarType\x12*\n" +
	"\x05value\x18\x02 \x01(\v2\x14.google.protobuf.AnyR\x05value\x12!\n" +
	"\ftimestamp_ms\x18\x03 \x01(\x03R\vtimestampMs\"'\n" +
	"\x11RelationalPayload\x12\x12\n" +
	"\x04json\x18\x01 \x01(\fR\x04json\"\xa1\x02\n" +
	"\x0fEventTableEntry\x12\x1e\n" +
	"\vuns_tree_id\x18\x01 \x01(\tR\tunsTreeId\x12/\n" +
	"\x02ts\x18\n" +
	" \x01(\v2\x1d.umh.events.TimeSeriesPayloadH\x00R\x02ts\x121\n" +
	"\x03rel\x18\v \x01(\v2\x1d.umh.events.RelationalPayloadH\x00R\x03rel\x12:\n" +
	"\rraw_kafka_msg\x18\x05 \x01(\v2\x16.umh.events.EventKafkaR\vrawKafkaMsg\x12\x1d\n" +
	"\n" +
	"bridged_by\x18\x06 \x03(\tR\tbridgedBy\x12$\n" +
	"\x0eproduced_at_ms\x18\a \x01(\x04R\fproducedAtMsB\t\n" +
	"\apayload\"C\n" +
	"\n" +
	"EventTable\x125\n" +
	"\aentries\x18\x01 \x03(\v2\x1b.umh.events.EventTableEntryR\aentries\"j\n" +
	"\tUnsBundle\x12-\n" +
	"\auns_map\x18\x01 \x01(\v2\x14.umh.events.TopicMapR\x06unsMap\x12.\n" +
	"\x06events\x18\x02 \x01(\v2\x16.umh.events.EventTableR\x06events*O\n" +
	"\rPayloadFormat\x12\x1e\n" +
	"\x1aPAYLOAD_FORMAT_UNSPECIFIED\x10\x00\x12\x0e\n" +
	"\n" +
	"TIMESERIES\x10\x01\x12\x0e\n" +
	"\n" +
	"RELATIONAL\x10\x02*O\n" +
	"\n" +
	"ScalarType\x12\x1b\n" +
	"\x17SCALAR_TYPE_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aNUMERIC\x10\x01\x12\n" +
	"\n" +
	"\x06STRING\x10\x02\x12\v\n" +
	"\aBOOLEAN\x10\x03B\x1fZ\x1dtopic_browser_plugin.protobufb\x06proto3"

var (
	file_topic_browser_data_proto_rawDescOnce sync.Once
	file_topic_browser_data_proto_rawDescData []byte
)

func file_topic_browser_data_proto_rawDescGZIP() []byte {
	file_topic_browser_data_proto_rawDescOnce.Do(func() {
		file_topic_browser_data_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_topic_browser_data_proto_rawDesc), len(file_topic_browser_data_proto_rawDesc)))
	})
	return file_topic_browser_data_proto_rawDescData
}

var file_topic_browser_data_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_topic_browser_data_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_topic_browser_data_proto_goTypes = []any{
	(PayloadFormat)(0),             // 0: umh.events.PayloadFormat
	(ScalarType)(0),                // 1: umh.events.ScalarType
	(*TopicInfo)(nil),              // 2: umh.events.TopicInfo
	(*TopicMap)(nil),               // 3: umh.events.TopicMap
	(*EventKafka)(nil),             // 4: umh.events.EventKafka
	(*TimeSeriesPayload)(nil),      // 5: umh.events.TimeSeriesPayload
	(*RelationalPayload)(nil),      // 6: umh.events.RelationalPayload
	(*EventTableEntry)(nil),        // 7: umh.events.EventTableEntry
	(*EventTable)(nil),             // 8: umh.events.EventTable
	(*UnsBundle)(nil),              // 9: umh.events.UnsBundle
	nil,                            // 10: umh.events.TopicInfo.MetadataEntry
	nil,                            // 11: umh.events.TopicMap.EntriesEntry
	nil,                            // 12: umh.events.EventKafka.HeadersEntry
	(*wrapperspb.StringValue)(nil), // 13: google.protobuf.StringValue
	(*anypb.Any)(nil),              // 14: google.protobuf.Any
}
var file_topic_browser_data_proto_depIdxs = []int32{
	13, // 0: umh.events.TopicInfo.level1:type_name -> google.protobuf.StringValue
	13, // 1: umh.events.TopicInfo.level2:type_name -> google.protobuf.StringValue
	13, // 2: umh.events.TopicInfo.level3:type_name -> google.protobuf.StringValue
	13, // 3: umh.events.TopicInfo.level4:type_name -> google.protobuf.StringValue
	13, // 4: umh.events.TopicInfo.level5:type_name -> google.protobuf.StringValue
	13, // 5: umh.events.TopicInfo.virtual_path:type_name -> google.protobuf.StringValue
	10, // 6: umh.events.TopicInfo.metadata:type_name -> umh.events.TopicInfo.MetadataEntry
	11, // 7: umh.events.TopicMap.entries:type_name -> umh.events.TopicMap.EntriesEntry
	12, // 8: umh.events.EventKafka.headers:type_name -> umh.events.EventKafka.HeadersEntry
	1,  // 9: umh.events.TimeSeriesPayload.scalar_type:type_name -> umh.events.ScalarType
	14, // 10: umh.events.TimeSeriesPayload.value:type_name -> google.protobuf.Any
	5,  // 11: umh.events.EventTableEntry.ts:type_name -> umh.events.TimeSeriesPayload
	6,  // 12: umh.events.EventTableEntry.rel:type_name -> umh.events.RelationalPayload
	4,  // 13: umh.events.EventTableEntry.raw_kafka_msg:type_name -> umh.events.EventKafka
	7,  // 14: umh.events.EventTable.entries:type_name -> umh.events.EventTableEntry
	3,  // 15: umh.events.UnsBundle.uns_map:type_name -> umh.events.TopicMap
	8,  // 16: umh.events.UnsBundle.events:type_name -> umh.events.EventTable
	2,  // 17: umh.events.TopicMap.EntriesEntry.value:type_name -> umh.events.TopicInfo
	18, // [18:18] is the sub-list for method output_type
	18, // [18:18] is the sub-list for method input_type
	18, // [18:18] is the sub-list for extension type_name
	18, // [18:18] is the sub-list for extension extendee
	0,  // [0:18] is the sub-list for field type_name
}

func init() { file_topic_browser_data_proto_init() }
func file_topic_browser_data_proto_init() {
	if File_topic_browser_data_proto != nil {
		return
	}
	file_topic_browser_data_proto_msgTypes[5].OneofWrappers = []any{
		(*EventTableEntry_Ts)(nil),
		(*EventTableEntry_Rel)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_topic_browser_data_proto_rawDesc), len(file_topic_browser_data_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   11,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_topic_browser_data_proto_goTypes,
		DependencyIndexes: file_topic_browser_data_proto_depIdxs,
		EnumInfos:         file_topic_browser_data_proto_enumTypes,
		MessageInfos:      file_topic_browser_data_proto_msgTypes,
	}.Build()
	File_topic_browser_data_proto = out.File
	file_topic_browser_data_proto_goTypes = nil
	file_topic_browser_data_proto_depIdxs = nil
}
