// Copyright 2025 UMH Systems GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


// Copyright 2025 UMH Systems GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: tag_browser_data.proto

package tag_browser_plugin_protobuf

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type UnsInfo struct {
	state         protoimpl.MessageState  `protogen:"open.v1"`
	Enterprise    string                  `protobuf:"bytes,1,opt,name=enterprise,proto3" json:"enterprise,omitempty"`                   // This must always be set
	Site          *wrapperspb.StringValue `protobuf:"bytes,2,opt,name=site,proto3" json:"site,omitempty"`                               // Optional
	Area          *wrapperspb.StringValue `protobuf:"bytes,3,opt,name=area,proto3" json:"area,omitempty"`                               // Optional
	Line          *wrapperspb.StringValue `protobuf:"bytes,4,opt,name=line,proto3" json:"line,omitempty"`                               // Optional
	WorkCell      *wrapperspb.StringValue `protobuf:"bytes,5,opt,name=work_cell,json=workCell,proto3" json:"work_cell,omitempty"`       // Optional
	OriginId      *wrapperspb.StringValue `protobuf:"bytes,6,opt,name=origin_id,json=originId,proto3" json:"origin_id,omitempty"`       // Optional
	Schema        string                  `protobuf:"bytes,7,opt,name=schema,proto3" json:"schema,omitempty"`                           // This must always be set
	EventGroup    *wrapperspb.StringValue `protobuf:"bytes,8,opt,name=event_group,json=eventGroup,proto3" json:"event_group,omitempty"` // Optional
	EventTag      *wrapperspb.StringValue `protobuf:"bytes,9,opt,name=event_tag,json=eventTag,proto3" json:"event_tag,omitempty"`       // Optional
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnsInfo) Reset() {
	*x = UnsInfo{}
	mi := &file_tag_browser_data_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnsInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnsInfo) ProtoMessage() {}

func (x *UnsInfo) ProtoReflect() protoreflect.Message {
	mi := &file_tag_browser_data_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnsInfo.ProtoReflect.Descriptor instead.
func (*UnsInfo) Descriptor() ([]byte, []int) {
	return file_tag_browser_data_proto_rawDescGZIP(), []int{0}
}

func (x *UnsInfo) GetEnterprise() string {
	if x != nil {
		return x.Enterprise
	}
	return ""
}

func (x *UnsInfo) GetSite() *wrapperspb.StringValue {
	if x != nil {
		return x.Site
	}
	return nil
}

func (x *UnsInfo) GetArea() *wrapperspb.StringValue {
	if x != nil {
		return x.Area
	}
	return nil
}

func (x *UnsInfo) GetLine() *wrapperspb.StringValue {
	if x != nil {
		return x.Line
	}
	return nil
}

func (x *UnsInfo) GetWorkCell() *wrapperspb.StringValue {
	if x != nil {
		return x.WorkCell
	}
	return nil
}

func (x *UnsInfo) GetOriginId() *wrapperspb.StringValue {
	if x != nil {
		return x.OriginId
	}
	return nil
}

func (x *UnsInfo) GetSchema() string {
	if x != nil {
		return x.Schema
	}
	return ""
}

func (x *UnsInfo) GetEventGroup() *wrapperspb.StringValue {
	if x != nil {
		return x.EventGroup
	}
	return nil
}

func (x *UnsInfo) GetEventTag() *wrapperspb.StringValue {
	if x != nil {
		return x.EventTag
	}
	return nil
}

type UnsMap struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Key is the UNS Tree id, which is basically a fast hash over the UnsInfo entries
	Entries       map[string]*UnsInfo `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnsMap) Reset() {
	*x = UnsMap{}
	mi := &file_tag_browser_data_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnsMap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnsMap) ProtoMessage() {}

func (x *UnsMap) ProtoReflect() protoreflect.Message {
	mi := &file_tag_browser_data_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnsMap.ProtoReflect.Descriptor instead.
func (*UnsMap) Descriptor() ([]byte, []int) {
	return file_tag_browser_data_proto_rawDescGZIP(), []int{1}
}

func (x *UnsMap) GetEntries() map[string]*UnsInfo {
	if x != nil {
		return x.Entries
	}
	return nil
}

type EventKafka struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This version does not contain fields like topic, key
	// Since there cannot be a user defined key and the topic will always be umh.messages
	Headers           map[string]string `protobuf:"bytes,1,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	InsertedTimestamp int64             `protobuf:"varint,2,opt,name=inserted_timestamp,json=insertedTimestamp,proto3" json:"inserted_timestamp,omitempty"` // As seen by kafka
	Payload           string            `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`                                               // Raw payload of the message
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *EventKafka) Reset() {
	*x = EventKafka{}
	mi := &file_tag_browser_data_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventKafka) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventKafka) ProtoMessage() {}

func (x *EventKafka) ProtoReflect() protoreflect.Message {
	mi := &file_tag_browser_data_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventKafka.ProtoReflect.Descriptor instead.
func (*EventKafka) Descriptor() ([]byte, []int) {
	return file_tag_browser_data_proto_rawDescGZIP(), []int{2}
}

func (x *EventKafka) GetHeaders() map[string]string {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *EventKafka) GetInsertedTimestamp() int64 {
	if x != nil {
		return x.InsertedTimestamp
	}
	return 0
}

func (x *EventKafka) GetPayload() string {
	if x != nil {
		return x.Payload
	}
	return ""
}

type EventTableEntry struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UnsTreeId     string                 `protobuf:"bytes,1,opt,name=uns_tree_id,json=unsTreeId,proto3" json:"uns_tree_id,omitempty"`         // Generated by the hash over it's UnsInfo
	Value         *anypb.Any             `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`                                    // This is the inner payload of our event. Since this can be any kind of data we represent it here as such
	TimestampMs   int64                  `protobuf:"varint,3,opt,name=timestamp_ms,json=timestampMs,proto3" json:"timestamp_ms,omitempty"`    // Extracted from the payload
	IsTimeseries  bool                   `protobuf:"varint,4,opt,name=is_timeseries,json=isTimeseries,proto3" json:"is_timeseries,omitempty"` // True if time series data as defined by our payload format, false otherwise
	RawKafkaMsg   *EventKafka            `protobuf:"bytes,5,opt,name=raw_kafka_msg,json=rawKafkaMsg,proto3" json:"raw_kafka_msg,omitempty"`
	Origin        string                 `protobuf:"bytes,6,opt,name=origin,proto3" json:"origin,omitempty"`                        // If present inside the messages headers
	BridgedBy     []string               `protobuf:"bytes,7,rep,name=bridged_by,json=bridgedBy,proto3" json:"bridged_by,omitempty"` // If present inside the messages headers
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EventTableEntry) Reset() {
	*x = EventTableEntry{}
	mi := &file_tag_browser_data_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventTableEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTableEntry) ProtoMessage() {}

func (x *EventTableEntry) ProtoReflect() protoreflect.Message {
	mi := &file_tag_browser_data_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventTableEntry.ProtoReflect.Descriptor instead.
func (*EventTableEntry) Descriptor() ([]byte, []int) {
	return file_tag_browser_data_proto_rawDescGZIP(), []int{3}
}

func (x *EventTableEntry) GetUnsTreeId() string {
	if x != nil {
		return x.UnsTreeId
	}
	return ""
}

func (x *EventTableEntry) GetValue() *anypb.Any {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *EventTableEntry) GetTimestampMs() int64 {
	if x != nil {
		return x.TimestampMs
	}
	return 0
}

func (x *EventTableEntry) GetIsTimeseries() bool {
	if x != nil {
		return x.IsTimeseries
	}
	return false
}

func (x *EventTableEntry) GetRawKafkaMsg() *EventKafka {
	if x != nil {
		return x.RawKafkaMsg
	}
	return nil
}

func (x *EventTableEntry) GetOrigin() string {
	if x != nil {
		return x.Origin
	}
	return ""
}

func (x *EventTableEntry) GetBridgedBy() []string {
	if x != nil {
		return x.BridgedBy
	}
	return nil
}

type EventTable struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Entries       []*EventTableEntry     `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EventTable) Reset() {
	*x = EventTable{}
	mi := &file_tag_browser_data_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventTable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTable) ProtoMessage() {}

func (x *EventTable) ProtoReflect() protoreflect.Message {
	mi := &file_tag_browser_data_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventTable.ProtoReflect.Descriptor instead.
func (*EventTable) Descriptor() ([]byte, []int) {
	return file_tag_browser_data_proto_rawDescGZIP(), []int{4}
}

func (x *EventTable) GetEntries() []*EventTableEntry {
	if x != nil {
		return x.Entries
	}
	return nil
}

// ---------- UNS Bundle ----------------------------------------------------
type UnsBundle struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UnsMap        *UnsMap                `protobuf:"bytes,1,opt,name=uns_map,json=unsMap,proto3" json:"uns_map,omitempty"`
	Events        *EventTable            `protobuf:"bytes,2,opt,name=events,proto3" json:"events,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnsBundle) Reset() {
	*x = UnsBundle{}
	mi := &file_tag_browser_data_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnsBundle) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnsBundle) ProtoMessage() {}

func (x *UnsBundle) ProtoReflect() protoreflect.Message {
	mi := &file_tag_browser_data_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnsBundle.ProtoReflect.Descriptor instead.
func (*UnsBundle) Descriptor() ([]byte, []int) {
	return file_tag_browser_data_proto_rawDescGZIP(), []int{5}
}

func (x *UnsBundle) GetUnsMap() *UnsMap {
	if x != nil {
		return x.UnsMap
	}
	return nil
}

func (x *UnsBundle) GetEvents() *EventTable {
	if x != nil {
		return x.Events
	}
	return nil
}

var File_tag_browser_data_proto protoreflect.FileDescriptor

const file_tag_browser_data_proto_rawDesc = "" +
	"\n" +
	"\x16tag_browser_data.proto\x12\n" +
	"umh.events\x1a\x1egoogle/protobuf/wrappers.proto\x1a\x19google/protobuf/any.proto\"\xc7\x03\n" +
	"\aUnsInfo\x12\x1e\n" +
	"\n" +
	"enterprise\x18\x01 \x01(\tR\n" +
	"enterprise\x120\n" +
	"\x04site\x18\x02 \x01(\v2\x1c.google.protobuf.StringValueR\x04site\x120\n" +
	"\x04area\x18\x03 \x01(\v2\x1c.google.protobuf.StringValueR\x04area\x120\n" +
	"\x04line\x18\x04 \x01(\v2\x1c.google.protobuf.StringValueR\x04line\x129\n" +
	"\twork_cell\x18\x05 \x01(\v2\x1c.google.protobuf.StringValueR\bworkCell\x129\n" +
	"\torigin_id\x18\x06 \x01(\v2\x1c.google.protobuf.StringValueR\boriginId\x12\x16\n" +
	"\x06schema\x18\a \x01(\tR\x06schema\x12=\n" +
	"\vevent_group\x18\b \x01(\v2\x1c.google.protobuf.StringValueR\n" +
	"eventGroup\x129\n" +
	"\tevent_tag\x18\t \x01(\v2\x1c.google.protobuf.StringValueR\beventTag\"\x94\x01\n" +
	"\x06UnsMap\x129\n" +
	"\aentries\x18\x01 \x03(\v2\x1f.umh.events.UnsMap.EntriesEntryR\aentries\x1aO\n" +
	"\fEntriesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12)\n" +
	"\x05value\x18\x02 \x01(\v2\x13.umh.events.UnsInfoR\x05value:\x028\x01\"\xd0\x01\n" +
	"\n" +
	"EventKafka\x12=\n" +
	"\aheaders\x18\x01 \x03(\v2#.umh.events.EventKafka.HeadersEntryR\aheaders\x12-\n" +
	"\x12inserted_timestamp\x18\x02 \x01(\x03R\x11insertedTimestamp\x12\x18\n" +
	"\apayload\x18\x03 \x01(\tR\apayload\x1a:\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x98\x02\n" +
	"\x0fEventTableEntry\x12\x1e\n" +
	"\vuns_tree_id\x18\x01 \x01(\tR\tunsTreeId\x12*\n" +
	"\x05value\x18\x02 \x01(\v2\x14.google.protobuf.AnyR\x05value\x12!\n" +
	"\ftimestamp_ms\x18\x03 \x01(\x03R\vtimestampMs\x12#\n" +
	"\ris_timeseries\x18\x04 \x01(\bR\fisTimeseries\x12:\n" +
	"\rraw_kafka_msg\x18\x05 \x01(\v2\x16.umh.events.EventKafkaR\vrawKafkaMsg\x12\x16\n" +
	"\x06origin\x18\x06 \x01(\tR\x06origin\x12\x1d\n" +
	"\n" +
	"bridged_by\x18\a \x03(\tR\tbridgedBy\"C\n" +
	"\n" +
	"EventTable\x125\n" +
	"\aentries\x18\x01 \x03(\v2\x1b.umh.events.EventTableEntryR\aentries\"h\n" +
	"\tUnsBundle\x12+\n" +
	"\auns_map\x18\x01 \x01(\v2\x12.umh.events.UnsMapR\x06unsMap\x12.\n" +
	"\x06events\x18\x02 \x01(\v2\x16.umh.events.EventTableR\x06eventsB\x1dZ\x1btag_browser_plugin.protobufb\x06proto3"

var (
	file_tag_browser_data_proto_rawDescOnce sync.Once
	file_tag_browser_data_proto_rawDescData []byte
)

func file_tag_browser_data_proto_rawDescGZIP() []byte {
	file_tag_browser_data_proto_rawDescOnce.Do(func() {
		file_tag_browser_data_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_tag_browser_data_proto_rawDesc), len(file_tag_browser_data_proto_rawDesc)))
	})
	return file_tag_browser_data_proto_rawDescData
}

var file_tag_browser_data_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_tag_browser_data_proto_goTypes = []any{
	(*UnsInfo)(nil),                // 0: umh.events.UnsInfo
	(*UnsMap)(nil),                 // 1: umh.events.UnsMap
	(*EventKafka)(nil),             // 2: umh.events.EventKafka
	(*EventTableEntry)(nil),        // 3: umh.events.EventTableEntry
	(*EventTable)(nil),             // 4: umh.events.EventTable
	(*UnsBundle)(nil),              // 5: umh.events.UnsBundle
	nil,                            // 6: umh.events.UnsMap.EntriesEntry
	nil,                            // 7: umh.events.EventKafka.HeadersEntry
	(*wrapperspb.StringValue)(nil), // 8: google.protobuf.StringValue
	(*anypb.Any)(nil),              // 9: google.protobuf.Any
}
var file_tag_browser_data_proto_depIdxs = []int32{
	8,  // 0: umh.events.UnsInfo.site:type_name -> google.protobuf.StringValue
	8,  // 1: umh.events.UnsInfo.area:type_name -> google.protobuf.StringValue
	8,  // 2: umh.events.UnsInfo.line:type_name -> google.protobuf.StringValue
	8,  // 3: umh.events.UnsInfo.work_cell:type_name -> google.protobuf.StringValue
	8,  // 4: umh.events.UnsInfo.origin_id:type_name -> google.protobuf.StringValue
	8,  // 5: umh.events.UnsInfo.event_group:type_name -> google.protobuf.StringValue
	8,  // 6: umh.events.UnsInfo.event_tag:type_name -> google.protobuf.StringValue
	6,  // 7: umh.events.UnsMap.entries:type_name -> umh.events.UnsMap.EntriesEntry
	7,  // 8: umh.events.EventKafka.headers:type_name -> umh.events.EventKafka.HeadersEntry
	9,  // 9: umh.events.EventTableEntry.value:type_name -> google.protobuf.Any
	2,  // 10: umh.events.EventTableEntry.raw_kafka_msg:type_name -> umh.events.EventKafka
	3,  // 11: umh.events.EventTable.entries:type_name -> umh.events.EventTableEntry
	1,  // 12: umh.events.UnsBundle.uns_map:type_name -> umh.events.UnsMap
	4,  // 13: umh.events.UnsBundle.events:type_name -> umh.events.EventTable
	0,  // 14: umh.events.UnsMap.EntriesEntry.value:type_name -> umh.events.UnsInfo
	15, // [15:15] is the sub-list for method output_type
	15, // [15:15] is the sub-list for method input_type
	15, // [15:15] is the sub-list for extension type_name
	15, // [15:15] is the sub-list for extension extendee
	0,  // [0:15] is the sub-list for field type_name
}

func init() { file_tag_browser_data_proto_init() }
func file_tag_browser_data_proto_init() {
	if File_tag_browser_data_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_tag_browser_data_proto_rawDesc), len(file_tag_browser_data_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   8,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_tag_browser_data_proto_goTypes,
		DependencyIndexes: file_tag_browser_data_proto_depIdxs,
		MessageInfos:      file_tag_browser_data_proto_msgTypes,
	}.Build()
	File_tag_browser_data_proto = out.File
	file_tag_browser_data_proto_goTypes = nil
	file_tag_browser_data_proto_depIdxs = nil
}
