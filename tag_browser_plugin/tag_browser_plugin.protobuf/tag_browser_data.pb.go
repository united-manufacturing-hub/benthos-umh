// Copyright 2025 UMH Systems GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


// Copyright 2025 UMH Systems GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: tag_browser_data.proto

package tag_browser_plugin_protobuf

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TopicInfo struct {
	state         protoimpl.MessageState  `protogen:"open.v1"`
	Level0        string                  `protobuf:"bytes,1,opt,name=level0,proto3" json:"level0,omitempty"`                                                                                // This must always be set
	Level1        *wrapperspb.StringValue `protobuf:"bytes,2,opt,name=level1,proto3" json:"level1,omitempty"`                                                                                // Optional
	Level2        *wrapperspb.StringValue `protobuf:"bytes,3,opt,name=level2,proto3" json:"level2,omitempty"`                                                                                // Optional
	Level3        *wrapperspb.StringValue `protobuf:"bytes,4,opt,name=level3,proto3" json:"level3,omitempty"`                                                                                // Optional
	Level4        *wrapperspb.StringValue `protobuf:"bytes,5,opt,name=level4,proto3" json:"level4,omitempty"`                                                                                // Optional
	Level5        *wrapperspb.StringValue `protobuf:"bytes,6,opt,name=level5,proto3" json:"level5,omitempty"`                                                                                // Optional
	Datacontract  string                  `protobuf:"bytes,7,opt,name=datacontract,proto3" json:"datacontract,omitempty"`                                                                    // This must always be set
	VirtualPath   *wrapperspb.StringValue `protobuf:"bytes,8,opt,name=virtual_path,json=virtualPath,proto3" json:"virtual_path,omitempty"`                                                   // Optional
	EventTag      *wrapperspb.StringValue `protobuf:"bytes,9,opt,name=event_tag,json=eventTag,proto3" json:"event_tag,omitempty"`                                                            // Optional
	Metadata      map[string]string       `protobuf:"bytes,10,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Optional. These are all the headers that where ever seen in this topic
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopicInfo) Reset() {
	*x = TopicInfo{}
	mi := &file_tag_browser_data_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopicInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopicInfo) ProtoMessage() {}

func (x *TopicInfo) ProtoReflect() protoreflect.Message {
	mi := &file_tag_browser_data_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopicInfo.ProtoReflect.Descriptor instead.
func (*TopicInfo) Descriptor() ([]byte, []int) {
	return file_tag_browser_data_proto_rawDescGZIP(), []int{0}
}

func (x *TopicInfo) GetLevel0() string {
	if x != nil {
		return x.Level0
	}
	return ""
}

func (x *TopicInfo) GetLevel1() *wrapperspb.StringValue {
	if x != nil {
		return x.Level1
	}
	return nil
}

func (x *TopicInfo) GetLevel2() *wrapperspb.StringValue {
	if x != nil {
		return x.Level2
	}
	return nil
}

func (x *TopicInfo) GetLevel3() *wrapperspb.StringValue {
	if x != nil {
		return x.Level3
	}
	return nil
}

func (x *TopicInfo) GetLevel4() *wrapperspb.StringValue {
	if x != nil {
		return x.Level4
	}
	return nil
}

func (x *TopicInfo) GetLevel5() *wrapperspb.StringValue {
	if x != nil {
		return x.Level5
	}
	return nil
}

func (x *TopicInfo) GetDatacontract() string {
	if x != nil {
		return x.Datacontract
	}
	return ""
}

func (x *TopicInfo) GetVirtualPath() *wrapperspb.StringValue {
	if x != nil {
		return x.VirtualPath
	}
	return nil
}

func (x *TopicInfo) GetEventTag() *wrapperspb.StringValue {
	if x != nil {
		return x.EventTag
	}
	return nil
}

func (x *TopicInfo) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type TopicMap struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Key is the UNS Tree id, which is basically a fast hash over the TopicInfo entries
	// A hash was chosen over the full topic name, as it is smaller, while still giving good enough   uniqueness.
	Entries       map[string]*TopicInfo `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopicMap) Reset() {
	*x = TopicMap{}
	mi := &file_tag_browser_data_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopicMap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopicMap) ProtoMessage() {}

func (x *TopicMap) ProtoReflect() protoreflect.Message {
	mi := &file_tag_browser_data_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopicMap.ProtoReflect.Descriptor instead.
func (*TopicMap) Descriptor() ([]byte, []int) {
	return file_tag_browser_data_proto_rawDescGZIP(), []int{1}
}

func (x *TopicMap) GetEntries() map[string]*TopicInfo {
	if x != nil {
		return x.Entries
	}
	return nil
}

type EventKafka struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This version does not contain fields like topic, key
	// Since there cannot be a user defined key and the topic will always be umh.messages
	Headers       map[string]string `protobuf:"bytes,1,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Payload       string            `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"` // Raw payload of the message
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EventKafka) Reset() {
	*x = EventKafka{}
	mi := &file_tag_browser_data_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventKafka) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventKafka) ProtoMessage() {}

func (x *EventKafka) ProtoReflect() protoreflect.Message {
	mi := &file_tag_browser_data_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventKafka.ProtoReflect.Descriptor instead.
func (*EventKafka) Descriptor() ([]byte, []int) {
	return file_tag_browser_data_proto_rawDescGZIP(), []int{2}
}

func (x *EventKafka) GetHeaders() map[string]string {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *EventKafka) GetPayload() string {
	if x != nil {
		return x.Payload
	}
	return ""
}

type EventTableEntry struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UnsTreeId     string                 `protobuf:"bytes,1,opt,name=uns_tree_id,json=unsTreeId,proto3" json:"uns_tree_id,omitempty"`         // Generated by the hash over it's TopicInfo
	Value         *anypb.Any             `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`                                    // This is the inner payload of our event. Since this can be any kind of data we represent it here as such
	TimestampMs   *wrapperspb.Int64Value `protobuf:"bytes,3,opt,name=timestamp_ms,json=timestampMs,proto3" json:"timestamp_ms,omitempty"`     // Extracted from the payload (If timeseries data)
	IsTimeseries  bool                   `protobuf:"varint,4,opt,name=is_timeseries,json=isTimeseries,proto3" json:"is_timeseries,omitempty"` // True if time series data as defined by our payload format, false otherwise
	RawKafkaMsg   *EventKafka            `protobuf:"bytes,5,opt,name=raw_kafka_msg,json=rawKafkaMsg,proto3" json:"raw_kafka_msg,omitempty"`
	ProcessedBy   []string               `protobuf:"bytes,6,rep,name=processed_by,json=processedBy,proto3" json:"processed_by,omitempty"` // If present inside the messages headers. In the kafka headers, this is a comma seperated list
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EventTableEntry) Reset() {
	*x = EventTableEntry{}
	mi := &file_tag_browser_data_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventTableEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTableEntry) ProtoMessage() {}

func (x *EventTableEntry) ProtoReflect() protoreflect.Message {
	mi := &file_tag_browser_data_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventTableEntry.ProtoReflect.Descriptor instead.
func (*EventTableEntry) Descriptor() ([]byte, []int) {
	return file_tag_browser_data_proto_rawDescGZIP(), []int{3}
}

func (x *EventTableEntry) GetUnsTreeId() string {
	if x != nil {
		return x.UnsTreeId
	}
	return ""
}

func (x *EventTableEntry) GetValue() *anypb.Any {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *EventTableEntry) GetTimestampMs() *wrapperspb.Int64Value {
	if x != nil {
		return x.TimestampMs
	}
	return nil
}

func (x *EventTableEntry) GetIsTimeseries() bool {
	if x != nil {
		return x.IsTimeseries
	}
	return false
}

func (x *EventTableEntry) GetRawKafkaMsg() *EventKafka {
	if x != nil {
		return x.RawKafkaMsg
	}
	return nil
}

func (x *EventTableEntry) GetProcessedBy() []string {
	if x != nil {
		return x.ProcessedBy
	}
	return nil
}

type EventTable struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Entries       []*EventTableEntry     `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EventTable) Reset() {
	*x = EventTable{}
	mi := &file_tag_browser_data_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventTable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTable) ProtoMessage() {}

func (x *EventTable) ProtoReflect() protoreflect.Message {
	mi := &file_tag_browser_data_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventTable.ProtoReflect.Descriptor instead.
func (*EventTable) Descriptor() ([]byte, []int) {
	return file_tag_browser_data_proto_rawDescGZIP(), []int{4}
}

func (x *EventTable) GetEntries() []*EventTableEntry {
	if x != nil {
		return x.Entries
	}
	return nil
}

// UnsBundle contains both, a map of all new topics
// and a list of all events for those topics that where processed in this batch.
type UnsBundle struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UnsMap        *TopicMap              `protobuf:"bytes,1,opt,name=uns_map,json=unsMap,proto3" json:"uns_map,omitempty"`
	Events        *EventTable            `protobuf:"bytes,2,opt,name=events,proto3" json:"events,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnsBundle) Reset() {
	*x = UnsBundle{}
	mi := &file_tag_browser_data_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnsBundle) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnsBundle) ProtoMessage() {}

func (x *UnsBundle) ProtoReflect() protoreflect.Message {
	mi := &file_tag_browser_data_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnsBundle.ProtoReflect.Descriptor instead.
func (*UnsBundle) Descriptor() ([]byte, []int) {
	return file_tag_browser_data_proto_rawDescGZIP(), []int{5}
}

func (x *UnsBundle) GetUnsMap() *TopicMap {
	if x != nil {
		return x.UnsMap
	}
	return nil
}

func (x *UnsBundle) GetEvents() *EventTable {
	if x != nil {
		return x.Events
	}
	return nil
}

var File_tag_browser_data_proto protoreflect.FileDescriptor

const file_tag_browser_data_proto_rawDesc = "" +
	"\n" +
	"\x16tag_browser_data.proto\x12\n" +
	"umh.events\x1a\x1egoogle/protobuf/wrappers.proto\x1a\x19google/protobuf/any.proto\"\xcf\x04\n" +
	"\tTopicInfo\x12\x16\n" +
	"\x06level0\x18\x01 \x01(\tR\x06level0\x124\n" +
	"\x06level1\x18\x02 \x01(\v2\x1c.google.protobuf.StringValueR\x06level1\x124\n" +
	"\x06level2\x18\x03 \x01(\v2\x1c.google.protobuf.StringValueR\x06level2\x124\n" +
	"\x06level3\x18\x04 \x01(\v2\x1c.google.protobuf.StringValueR\x06level3\x124\n" +
	"\x06level4\x18\x05 \x01(\v2\x1c.google.protobuf.StringValueR\x06level4\x124\n" +
	"\x06level5\x18\x06 \x01(\v2\x1c.google.protobuf.StringValueR\x06level5\x12\"\n" +
	"\fdatacontract\x18\a \x01(\tR\fdatacontract\x12?\n" +
	"\fvirtual_path\x18\b \x01(\v2\x1c.google.protobuf.StringValueR\vvirtualPath\x129\n" +
	"\tevent_tag\x18\t \x01(\v2\x1c.google.protobuf.StringValueR\beventTag\x12?\n" +
	"\bmetadata\x18\n" +
	" \x03(\v2#.umh.events.TopicInfo.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x9a\x01\n" +
	"\bTopicMap\x12;\n" +
	"\aentries\x18\x01 \x03(\v2!.umh.events.TopicMap.EntriesEntryR\aentries\x1aQ\n" +
	"\fEntriesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12+\n" +
	"\x05value\x18\x02 \x01(\v2\x15.umh.events.TopicInfoR\x05value:\x028\x01\"\xa1\x01\n" +
	"\n" +
	"EventKafka\x12=\n" +
	"\aheaders\x18\x01 \x03(\v2#.umh.events.EventKafka.HeadersEntryR\aheaders\x12\x18\n" +
	"\apayload\x18\x02 \x01(\tR\apayload\x1a:\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xa1\x02\n" +
	"\x0fEventTableEntry\x12\x1e\n" +
	"\vuns_tree_id\x18\x01 \x01(\tR\tunsTreeId\x12*\n" +
	"\x05value\x18\x02 \x01(\v2\x14.google.protobuf.AnyR\x05value\x12>\n" +
	"\ftimestamp_ms\x18\x03 \x01(\v2\x1b.google.protobuf.Int64ValueR\vtimestampMs\x12#\n" +
	"\ris_timeseries\x18\x04 \x01(\bR\fisTimeseries\x12:\n" +
	"\rraw_kafka_msg\x18\x05 \x01(\v2\x16.umh.events.EventKafkaR\vrawKafkaMsg\x12!\n" +
	"\fprocessed_by\x18\x06 \x03(\tR\vprocessedBy\"C\n" +
	"\n" +
	"EventTable\x125\n" +
	"\aentries\x18\x01 \x03(\v2\x1b.umh.events.EventTableEntryR\aentries\"j\n" +
	"\tUnsBundle\x12-\n" +
	"\auns_map\x18\x01 \x01(\v2\x14.umh.events.TopicMapR\x06unsMap\x12.\n" +
	"\x06events\x18\x02 \x01(\v2\x16.umh.events.EventTableR\x06eventsB\x1dZ\x1btag_browser_plugin.protobufb\x06proto3"

var (
	file_tag_browser_data_proto_rawDescOnce sync.Once
	file_tag_browser_data_proto_rawDescData []byte
)

func file_tag_browser_data_proto_rawDescGZIP() []byte {
	file_tag_browser_data_proto_rawDescOnce.Do(func() {
		file_tag_browser_data_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_tag_browser_data_proto_rawDesc), len(file_tag_browser_data_proto_rawDesc)))
	})
	return file_tag_browser_data_proto_rawDescData
}

var file_tag_browser_data_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_tag_browser_data_proto_goTypes = []any{
	(*TopicInfo)(nil),              // 0: umh.events.TopicInfo
	(*TopicMap)(nil),               // 1: umh.events.TopicMap
	(*EventKafka)(nil),             // 2: umh.events.EventKafka
	(*EventTableEntry)(nil),        // 3: umh.events.EventTableEntry
	(*EventTable)(nil),             // 4: umh.events.EventTable
	(*UnsBundle)(nil),              // 5: umh.events.UnsBundle
	nil,                            // 6: umh.events.TopicInfo.MetadataEntry
	nil,                            // 7: umh.events.TopicMap.EntriesEntry
	nil,                            // 8: umh.events.EventKafka.HeadersEntry
	(*wrapperspb.StringValue)(nil), // 9: google.protobuf.StringValue
	(*anypb.Any)(nil),              // 10: google.protobuf.Any
	(*wrapperspb.Int64Value)(nil),  // 11: google.protobuf.Int64Value
}
var file_tag_browser_data_proto_depIdxs = []int32{
	9,  // 0: umh.events.TopicInfo.level1:type_name -> google.protobuf.StringValue
	9,  // 1: umh.events.TopicInfo.level2:type_name -> google.protobuf.StringValue
	9,  // 2: umh.events.TopicInfo.level3:type_name -> google.protobuf.StringValue
	9,  // 3: umh.events.TopicInfo.level4:type_name -> google.protobuf.StringValue
	9,  // 4: umh.events.TopicInfo.level5:type_name -> google.protobuf.StringValue
	9,  // 5: umh.events.TopicInfo.virtual_path:type_name -> google.protobuf.StringValue
	9,  // 6: umh.events.TopicInfo.event_tag:type_name -> google.protobuf.StringValue
	6,  // 7: umh.events.TopicInfo.metadata:type_name -> umh.events.TopicInfo.MetadataEntry
	7,  // 8: umh.events.TopicMap.entries:type_name -> umh.events.TopicMap.EntriesEntry
	8,  // 9: umh.events.EventKafka.headers:type_name -> umh.events.EventKafka.HeadersEntry
	10, // 10: umh.events.EventTableEntry.value:type_name -> google.protobuf.Any
	11, // 11: umh.events.EventTableEntry.timestamp_ms:type_name -> google.protobuf.Int64Value
	2,  // 12: umh.events.EventTableEntry.raw_kafka_msg:type_name -> umh.events.EventKafka
	3,  // 13: umh.events.EventTable.entries:type_name -> umh.events.EventTableEntry
	1,  // 14: umh.events.UnsBundle.uns_map:type_name -> umh.events.TopicMap
	4,  // 15: umh.events.UnsBundle.events:type_name -> umh.events.EventTable
	0,  // 16: umh.events.TopicMap.EntriesEntry.value:type_name -> umh.events.TopicInfo
	17, // [17:17] is the sub-list for method output_type
	17, // [17:17] is the sub-list for method input_type
	17, // [17:17] is the sub-list for extension type_name
	17, // [17:17] is the sub-list for extension extendee
	0,  // [0:17] is the sub-list for field type_name
}

func init() { file_tag_browser_data_proto_init() }
func file_tag_browser_data_proto_init() {
	if File_tag_browser_data_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_tag_browser_data_proto_rawDesc), len(file_tag_browser_data_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_tag_browser_data_proto_goTypes,
		DependencyIndexes: file_tag_browser_data_proto_depIdxs,
		MessageInfos:      file_tag_browser_data_proto_msgTypes,
	}.Build()
	File_tag_browser_data_proto = out.File
	file_tag_browser_data_proto_goTypes = nil
	file_tag_browser_data_proto_depIdxs = nil
}
