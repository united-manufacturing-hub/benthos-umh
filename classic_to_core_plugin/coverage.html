
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>classic_to_core_plugin: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/united-manufacturing-hub/benthos-umh/classic_to_core_plugin/classic_to_core_plugin.go (86.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2025 UMH Systems GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package classic_to_core_plugin

import (
        "context"
        "encoding/json"
        "fmt"
        "strconv"
        "strings"

        "github.com/redpanda-data/benthos/v4/public/service"
)

type ClassicToCoreConfig struct {
        TimestampField     string   `json:"timestamp_field" yaml:"timestamp_field"`
        ExcludeFields      []string `json:"exclude_fields" yaml:"exclude_fields"`
        TargetDataContract string   `json:"target_data_contract" yaml:"target_data_contract"`
        PreserveMeta       bool     `json:"preserve_meta" yaml:"preserve_meta"`
        MaxRecursionDepth  int      `json:"max_recursion_depth" yaml:"max_recursion_depth"`
        MaxTagsPerMessage  int      `json:"max_tags_per_message" yaml:"max_tags_per_message"`
}

func init() <span class="cov1" title="1">{
        spec := service.NewConfigSpec().
                Version("1.0.0").
                Summary("Convert UMH Historian Data Contract format to Core format").
                Description(`The classic_to_core processor converts Historian Data Contract messages containing multiple values 
and tag groups into individual Core format messages, following the "one tag, one message, one topic" principle.

Input format (Historian Data Contract):
- Single message with timestamp_ms and multiple data fields or tag groups
- Topic: umh.v1.&lt;location&gt;._historian.&lt;context&gt;
- Supports flat tags: {"timestamp_ms": 123, "temperature": 23.4}
- Supports tag groups: {"timestamp_ms": 123, "axis": {"x": 1.0, "y": 2.0}}

Output format (Core):
- Multiple messages, one per tag (including flattened tag groups)
- Each with {"value": &lt;field_value&gt;, "timestamp_ms": &lt;timestamp&gt;}
- Topics: umh.v1.&lt;location&gt;.&lt;target_data_contract&gt;.&lt;context&gt;.&lt;tag_name&gt;
- Tag groups flattened with dot separators: "axis.x", "axis.y"

The processor will:
1. Extract the timestamp field from the payload
2. Flatten any nested tag groups using dot separator for intuitive paths
3. Create one output message per tag
4. Construct new topics by appending tag names
5. Preserve original metadata while updating topic-related fields`).
                Field(service.NewStringField("timestamp_field").
                        Description("Field name containing the timestamp (default: timestamp_ms)").
                        Default("timestamp_ms")).
                Field(service.NewStringListField("exclude_fields").
                        Description("List of fields to exclude from conversion (timestamp_field is automatically excluded)").
                        Default([]string{}).
                        Optional()).
                Field(service.NewStringField("target_data_contract").
                        Description("Target data contract for output topics. If empty, uses the input's data contract (e.g., _historian)").
                        Default("").
                        Optional()).
                Field(service.NewBoolField("preserve_meta").
                        Description("Whether to preserve original metadata from source message").
                        Default(true)).
                Field(service.NewIntField("max_recursion_depth").
                        Description("Maximum recursion depth for flattening nested tag groups (default: 10)").
                        Default(10).
                        Optional()).
                Field(service.NewIntField("max_tags_per_message").
                        Description("Maximum number of tags to extract from a single input message (default: 1000)").
                        Default(1000).
                        Optional())

        err := service.RegisterBatchProcessor(
                "classic_to_core",
                spec,
                func(conf *service.ParsedConfig, mgr *service.Resources) (service.BatchProcessor, error) </span><span class="cov7" title="18">{
                        timestampField, err := conf.FieldString("timestamp_field")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov7" title="18">excludeFields, err := conf.FieldStringList("exclude_fields")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov7" title="18">targetDataContract, _ := conf.FieldString("target_data_contract")

                        preserveMeta, err := conf.FieldBool("preserve_meta")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov7" title="18">maxRecursionDepth, err := conf.FieldInt("max_recursion_depth")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov7" title="18">maxTagsPerMessage, err := conf.FieldInt("max_tags_per_message")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov7" title="18">config := ClassicToCoreConfig{
                                TimestampField:     timestampField,
                                ExcludeFields:      excludeFields,
                                TargetDataContract: targetDataContract,
                                PreserveMeta:       preserveMeta,
                                MaxRecursionDepth:  maxRecursionDepth,
                                MaxTagsPerMessage:  maxTagsPerMessage,
                        }

                        return newClassicToCoreProcessor(config, mgr.Logger(), mgr.Metrics())</span>
                })
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

type ClassicToCoreProcessor struct {
        config            ClassicToCoreConfig
        logger            *service.Logger
        messagesProcessed *service.MetricCounter
        messagesErrored   *service.MetricCounter
        messagesExpanded  *service.MetricCounter
        messagesDropped   *service.MetricCounter
        recursionLimitHit *service.MetricCounter
        tagLimitExceeded  *service.MetricCounter
        excludeFieldsMap  map[string]bool
}

func newClassicToCoreProcessor(config ClassicToCoreConfig, logger *service.Logger, metrics *service.Metrics) (*ClassicToCoreProcessor, error) <span class="cov7" title="18">{
        // Create exclude fields map for fast lookup
        excludeFieldsMap := make(map[string]bool)
        excludeFieldsMap[config.TimestampField] = true // Always exclude timestamp field
        for _, field := range config.ExcludeFields </span><span class="cov2" title="2">{
                excludeFieldsMap[field] = true
        }</span>

        <span class="cov7" title="18">return &amp;ClassicToCoreProcessor{
                config:            config,
                logger:            logger,
                messagesProcessed: metrics.NewCounter("messages_processed"),
                messagesErrored:   metrics.NewCounter("messages_errored"),
                messagesExpanded:  metrics.NewCounter("messages_expanded"),
                messagesDropped:   metrics.NewCounter("messages_dropped"),
                recursionLimitHit: metrics.NewCounter("recursion_limit_hit"),
                tagLimitExceeded:  metrics.NewCounter("tag_limit_exceeded"),
                excludeFieldsMap:  excludeFieldsMap,
        }, nil</span>
}

func (p *ClassicToCoreProcessor) ProcessBatch(ctx context.Context, batch service.MessageBatch) ([]service.MessageBatch, error) <span class="cov7" title="18">{
        var outputBatch service.MessageBatch

        for _, msg := range batch </span><span class="cov7" title="18">{
                p.messagesProcessed.Incr(1)

                // Process single message and add results to output batch
                expandedMessages, err := p.processMessage(msg)
                if err != nil </span><span class="cov4" title="4">{
                        p.logger.Errorf("Failed to process message: %v", err)
                        p.messagesErrored.Incr(1)
                        continue</span>
                }

                // Check tag limit per message
                <span class="cov7" title="14">if len(expandedMessages) &gt; p.config.MaxTagsPerMessage </span><span class="cov1" title="1">{
                        p.logger.Errorf("Message produced %d tags, exceeding limit of %d", len(expandedMessages), p.config.MaxTagsPerMessage)
                        p.tagLimitExceeded.Incr(1)
                        p.messagesDropped.Incr(1)
                        continue</span>
                }

                <span class="cov6" title="13">outputBatch = append(outputBatch, expandedMessages...)
                p.messagesExpanded.Incr(int64(len(expandedMessages)))</span>
        }

        <span class="cov7" title="18">if len(outputBatch) == 0 </span><span class="cov4" title="5">{
                return nil, nil
        }</span>

        <span class="cov6" title="13">return []service.MessageBatch{outputBatch}, nil</span>
}

// processMessage handles the conversion of a single input message to multiple Core format messages
func (p *ClassicToCoreProcessor) processMessage(msg *service.Message) ([]*service.Message, error) <span class="cov7" title="18">{
        // Parse and validate payload
        payload, err := p.parsePayload(msg)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("payload parsing failed: %w", err)
        }</span>

        // Extract and validate timestamp
        <span class="cov7" title="17">timestamp, err := p.validateAndExtractTimestamp(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("timestamp validation failed: %w", err)
        }</span>

        // Parse and validate topic
        <span class="cov7" title="17">topicComponents, err := p.validateAndParseTopic(msg)
        if err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("topic parsing failed: %w", err)
        }</span>

        // Flatten payload with recursion limit
        <span class="cov7" title="14">flattenedTags := p.flattenPayload(payload, "", 0)

        // Convert to Core messages
        var expandedMessages []*service.Message
        for tagName, tagValue := range flattenedTags </span><span class="cov8" title="30">{
                if p.excludeFieldsMap[tagName] </span><span class="cov2" title="2">{
                        continue</span>
                }

                <span class="cov8" title="28">newMsg, err := p.createCoreMessage(msg, tagName, tagValue, timestamp, topicComponents)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create Core message for tag '%s': %w", tagName, err)
                }</span>

                <span class="cov8" title="28">expandedMessages = append(expandedMessages, newMsg)</span>
        }

        <span class="cov7" title="14">return expandedMessages, nil</span>
}

// parsePayload extracts and validates the JSON payload from the message
func (p *ClassicToCoreProcessor) parsePayload(msg *service.Message) (map[string]interface{}, error) <span class="cov7" title="18">{
        structured, err := msg.AsStructured()
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse as structured data: %w", err)
        }</span>

        <span class="cov7" title="17">payload, ok := structured.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("payload is not a JSON object")
        }</span>

        <span class="cov7" title="17">return payload, nil</span>
}

// validateAndExtractTimestamp validates the timestamp field exists and extracts its value
func (p *ClassicToCoreProcessor) validateAndExtractTimestamp(payload map[string]interface{}) (int64, error) <span class="cov7" title="17">{
        timestampValue, exists := payload[p.config.TimestampField]
        if !exists </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("timestamp field '%s' not found in payload", p.config.TimestampField)
        }</span>

        <span class="cov7" title="17">timestamp, err := p.extractTimestamp(timestampValue)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse timestamp: %w", err)
        }</span>

        <span class="cov7" title="17">return timestamp, nil</span>
}

// validateAndParseTopic extracts and validates the topic from message metadata
func (p *ClassicToCoreProcessor) validateAndParseTopic(msg *service.Message) (*TopicComponents, error) <span class="cov7" title="17">{
        originalTopic, exists := msg.MetaGet("topic")
        if !exists </span><span class="cov1" title="1">{
                // Try to get it from umh_topic as fallback
                if umhTopic, exists := msg.MetaGet("umh_topic"); exists </span><span class="cov0" title="0">{
                        originalTopic = umhTopic
                }</span> else<span class="cov1" title="1"> {
                        return nil, fmt.Errorf("no topic found in message metadata")
                }</span>
        }

        <span class="cov7" title="16">topicComponents, err := p.parseClassicTopic(originalTopic)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("failed to parse topic '%s': %w", originalTopic, err)
        }</span>

        <span class="cov7" title="14">return topicComponents, nil</span>
}

// TopicComponents represents the parsed parts of a UMH topic
type TopicComponents struct {
        Prefix       string // "umh.v1"
        LocationPath string // "enterprise.site.area"
        DataContract string // "_historian"
        Context      string // Additional context after data contract
}

func (p *ClassicToCoreProcessor) parseClassicTopic(topic string) (*TopicComponents, error) <span class="cov7" title="16">{
        parts := strings.Split(topic, ".")
        if len(parts) &lt; 4 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid topic structure, expected at least 4 parts: %s", topic)
        }</span>

        // Validate UMH topic prefix
        <span class="cov7" title="16">if len(parts) &lt; 2 || parts[0] != "umh" || parts[1] != "v1" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid UMH topic prefix, expected 'umh.v1': %s", topic)
        }</span>

        // Find the data contract (starts with underscore)
        <span class="cov7" title="15">var dataContractIndex = -1
        for i := 2; i &lt; len(parts); i++ </span><span class="cov9" title="35">{ // Start from index 2 (after umh.v1)
                if strings.HasPrefix(parts[i], "_") </span><span class="cov7" title="15">{
                        dataContractIndex = i
                        break</span>
                }
        }

        <span class="cov7" title="15">if dataContractIndex == -1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no data contract found in topic: %s", topic)
        }</span>

        <span class="cov7" title="15">if dataContractIndex == 2 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("missing location path in topic: %s", topic)
        }</span>

        // Reconstruct components
        <span class="cov7" title="14">prefix := strings.Join(parts[:2], ".") // umh.v1
        locationPath := strings.Join(parts[2:dataContractIndex], ".")
        dataContract := parts[dataContractIndex]

        var context string
        if len(parts) &gt; dataContractIndex+1 </span><span class="cov7" title="14">{
                context = strings.Join(parts[dataContractIndex+1:], ".")
        }</span>

        <span class="cov7" title="14">return &amp;TopicComponents{
                Prefix:       prefix,
                LocationPath: locationPath,
                DataContract: dataContract,
                Context:      context,
        }, nil</span>
}

func (p *ClassicToCoreProcessor) createCoreMessage(originalMsg *service.Message, fieldName string, fieldValue interface{}, timestamp int64, topicComponents *TopicComponents) (*service.Message, error) <span class="cov8" title="28">{
        // Create Core format payload
        corePayload := map[string]interface{}{
                "value":        fieldValue,
                "timestamp_ms": timestamp,
        }

        // Marshal payload
        payloadBytes, err := json.Marshal(corePayload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal Core payload: %v", err)
        }</span>

        // Create new message
        <span class="cov8" title="28">newMsg := service.NewMessage(payloadBytes)

        // Preserve original metadata if requested
        if p.config.PreserveMeta </span><span class="cov8" title="28">{
                _ = originalMsg.MetaWalkMut(func(key string, value any) error </span><span class="cov8" title="30">{
                        if str, ok := value.(string); ok </span><span class="cov8" title="30">{
                                newMsg.MetaSet(key, str)
                        }</span>
                        <span class="cov8" title="30">return nil</span>
                })
        }

        // Determine target data contract
        <span class="cov8" title="28">targetDataContract := p.config.TargetDataContract
        if targetDataContract == "" </span><span class="cov1" title="1">{
                // Use the original data contract if not specified
                targetDataContract = topicComponents.DataContract
        }</span>

        // Construct new topic
        <span class="cov8" title="28">newTopic := p.constructCoreTopic(topicComponents, fieldName, targetDataContract)
        newMsg.MetaSet("topic", newTopic)
        newMsg.MetaSet("umh_topic", newTopic)

        // Set Core-specific metadata
        newMsg.MetaSet("location_path", topicComponents.LocationPath)
        newMsg.MetaSet("data_contract", targetDataContract)
        newMsg.MetaSet("tag_name", fieldName)

        // Set virtual path if there was context in the original topic
        if topicComponents.Context != "" </span><span class="cov8" title="28">{
                newMsg.MetaSet("virtual_path", topicComponents.Context)
        }</span>

        <span class="cov8" title="28">return newMsg, nil</span>
}

func (p *ClassicToCoreProcessor) constructCoreTopic(components *TopicComponents, fieldName string, targetDataContract string) string <span class="cov8" title="28">{
        parts := []string{
                components.Prefix,
                components.LocationPath,
                targetDataContract,
        }

        if components.Context != "" </span><span class="cov8" title="28">{
                parts = append(parts, components.Context)
        }</span>

        <span class="cov8" title="28">parts = append(parts, fieldName)

        return strings.Join(parts, ".")</span>
}

// flattenPayload recursively flattens nested objects using . as separator
// This creates intuitive dot-notation paths for nested tag groups
func (p *ClassicToCoreProcessor) flattenPayload(payload map[string]interface{}, prefix string, depth int) map[string]interface{} <span class="cov7" title="21">{
        result := make(map[string]interface{})

        // Check recursion depth limit
        if depth &gt;= p.config.MaxRecursionDepth </span><span class="cov1" title="1">{
                p.recursionLimitHit.Incr(1)
                p.logger.Warnf("Recursion depth limit (%d) reached at prefix '%s', stopping further flattening", p.config.MaxRecursionDepth, prefix)
                return result
        }</span>

        <span class="cov7" title="20">for key, value := range payload </span><span class="cov10" title="51">{
                // Skip the timestamp field as it's handled separately
                if key == p.config.TimestampField </span><span class="cov7" title="14">{
                        continue</span>
                }

                <span class="cov9" title="37">var fullKey string
                if prefix == "" </span><span class="cov8" title="24">{
                        fullKey = key
                }</span> else<span class="cov6" title="13"> {
                        fullKey = prefix + "." + key
                }</span>

                // Check if value is a nested object (tag group)
                <span class="cov9" title="37">if nestedMap, ok := value.(map[string]interface{}); ok </span><span class="cov5" title="7">{
                        // Recursively flatten nested objects with incremented depth
                        nestedResults := p.flattenPayload(nestedMap, fullKey, depth+1)
                        for nestedKey, nestedValue := range nestedResults </span><span class="cov7" title="16">{
                                result[nestedKey] = nestedValue
                        }</span>
                } else<span class="cov8" title="30"> {
                        // Regular tag - add to result
                        result[fullKey] = value
                }</span>
        }

        <span class="cov7" title="20">return result</span>
}

func (p *ClassicToCoreProcessor) extractTimestamp(value interface{}) (int64, error) <span class="cov7" title="17">{
        switch v := value.(type) </span>{
        case float64:<span class="cov0" title="0">
                return int64(v), nil</span>
        case int64:<span class="cov0" title="0">
                return v, nil</span>
        case int:<span class="cov0" title="0">
                return int64(v), nil</span>
        case json.Number:<span class="cov7" title="16">
                if f, err := v.Float64(); err == nil </span><span class="cov7" title="16">{
                        return int64(f), nil
                }</span>
                <span class="cov0" title="0">return 0, fmt.Errorf("invalid timestamp number format")</span>
        case string:<span class="cov1" title="1">
                if i, err := strconv.ParseInt(v, 10, 64); err == nil </span><span class="cov1" title="1">{
                        return i, nil
                }</span>
                <span class="cov0" title="0">return 0, fmt.Errorf("invalid timestamp string format")</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("unsupported timestamp type: %T", v)</span>
        }
}

func (p *ClassicToCoreProcessor) Close(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
