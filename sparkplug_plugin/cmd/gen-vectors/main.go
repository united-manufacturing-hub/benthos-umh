// Vector Generation Tool for Sparkplug B Plugin
// Single Go tool to generate static test vectors (no Python/Docker complexity)
// Generates test_vectors.go with Base64-encoded Sparkplug B payloads

package main

import (
	"encoding/base64"
	"fmt"
	"log"
	"time"

	"github.com/weekaung/sparkplugb-client/sproto"
	"google.golang.org/protobuf/proto"
)

// TestVector represents a test payload with metadata
type TestVector struct {
	Name        string
	Base64Data  string
	Description string
	MessageType string
	MetricCount int
}

func main() {
	fmt.Println("// Generated by gen-vectors - DO NOT EDIT")
	fmt.Println("// Static test vectors for Sparkplug B plugin")
	fmt.Println("package sparkplug_plugin")
	fmt.Println()
	fmt.Println("// TestVector represents a test payload with metadata")
	fmt.Println("type TestVector struct {")
	fmt.Println("	Name        string")
	fmt.Println("	Base64Data  string")
	fmt.Println("	Description string")
	fmt.Println("	MessageType string")
	fmt.Println("	MetricCount int")
	fmt.Println("}")
	fmt.Println()
	fmt.Println("// TestVectors contains all static test vectors")
	fmt.Println("var TestVectors = []TestVector{")

	// Generate happy path vectors
	generateHappyPathVectors()

	// Generate edge case vectors
	generateEdgeCaseVectors()

	// Generate performance test vectors
	generatePerformanceVectors()

	fmt.Println("}")
	fmt.Println()
	fmt.Println("// GetTestVector retrieves a test vector by name")
	fmt.Println("func GetTestVector(name string) *TestVector {")
	fmt.Println("	for _, vector := range TestVectors {")
	fmt.Println("		if vector.Name == name {")
	fmt.Println("			return &vector")
	fmt.Println("		}")
	fmt.Println("	}")
	fmt.Println("	return nil")
	fmt.Println("}")
}

func generateHappyPathVectors() {
	fmt.Println("	// Happy path vectors - basic protocol flow")

	// NBIRTH with corrected format from expert.md
	nbirth := createNBirth(0, []Metric{
		{Name: "bdSeq", Alias: 1, DataType: sproto.DataType_UInt64, Value: uint64(88)},
		{Name: "Node Control/Rebirth", Alias: 2, DataType: sproto.DataType_Boolean, Value: false},
		{Name: "Temperature", Alias: 100, DataType: sproto.DataType_Double, Value: 21.5},
	})
	fmt.Printf("	{\"NBIRTH_V1\", \"%s\", \"Basic node birth with temperature\", \"NBIRTH\", 3},\n",
		b64(nbirth))

	// NDATA with temperature update
	ndata := createNData(1, []Metric{
		{Alias: 100, DataType: sproto.DataType_Double, Value: 22.5},
	})
	fmt.Printf("	{\"NDATA_V1\", \"%s\", \"Temperature update by alias\", \"NDATA\", 1},\n",
		b64(ndata))

	// NDEATH
	ndeath := createNDeath([]Metric{
		{Name: "bdSeq", DataType: sproto.DataType_UInt64, Value: uint64(0)},
	})
	fmt.Printf("	{\"NDEATH_V1\", \"%s\", \"Node death certificate\", \"NDEATH\", 1},\n",
		b64(ndeath))
}

func generateEdgeCaseVectors() {
	fmt.Println("	// Edge case vectors - boundary conditions and error cases")

	// Sequence gap
	ndataGap := createNData(5, []Metric{
		{Alias: 100, DataType: sproto.DataType_Double, Value: 27.0},
	})
	fmt.Printf("	{\"NDATA_GAP\", \"%s\", \"Sequence gap 1→5\", \"NDATA\", 1},\n",
		b64(ndataGap))

	// Pre-birth data
	ndataPreBirth := createNData(1, []Metric{
		{Alias: 100, DataType: sproto.DataType_Double, Value: 25.0},
	})
	fmt.Printf("	{\"NDATA_BEFORE_BIRTH\", \"%s\", \"Data without birth context\", \"NDATA\", 1},\n",
		b64(ndataPreBirth))

	// Sequence wraparound
	ndataWrap := createNData(0, []Metric{
		{Alias: 100, DataType: sproto.DataType_Double, Value: 30.0},
	})
	fmt.Printf("	{\"NDATA_WRAPAROUND\", \"%s\", \"Sequence wraparound 255→0\", \"NDATA\", 1},\n",
		b64(ndataWrap))
}

func generatePerformanceVectors() {
	fmt.Println("	// Performance test vectors - large payloads")

	// Large NBIRTH with many metrics
	var metrics []Metric
	metrics = append(metrics, Metric{Name: "bdSeq", Alias: 1, DataType: sproto.DataType_UInt64, Value: uint64(88)})
	metrics = append(metrics, Metric{Name: "Node Control/Rebirth", Alias: 2, DataType: sproto.DataType_Boolean, Value: false})

	for i := 1; i <= 100; i++ {
		metrics = append(metrics, Metric{
			Name:     fmt.Sprintf("Metric_%d", i),
			Alias:    uint64(i),
			DataType: sproto.DataType_Double,
			Value:    float64(i) * 1.5,
		})
	}

	largeNBirth := createNBirth(0, metrics)
	fmt.Printf("	{\"NBIRTH_LARGE\", \"%s\", \"Large NBIRTH with 100+ metrics\", \"NBIRTH\", %d},\n",
		b64(largeNBirth), len(metrics))
}

// Metric helper struct
type Metric struct {
	Name     string
	Alias    uint64
	DataType sproto.DataType
	Value    interface{}
}

func createNBirth(seq uint64, metrics []Metric) []byte {
	timestamp := uint64(time.Now().UnixMilli())
	payload := &sproto.Payload{
		Timestamp: &timestamp,
		Seq:       &seq,
		Metrics:   make([]*sproto.Payload_Metric, len(metrics)),
	}

	for i, metric := range metrics {
		payload.Metrics[i] = createProtoMetric(metric, true) // Include names in birth
	}

	data, err := proto.Marshal(payload)
	if err != nil {
		log.Fatalf("Failed to marshal NBIRTH: %v", err)
	}
	return data
}

func createNData(seq uint64, metrics []Metric) []byte {
	timestamp := uint64(time.Now().UnixMilli())
	payload := &sproto.Payload{
		Timestamp: &timestamp,
		Seq:       &seq,
		Metrics:   make([]*sproto.Payload_Metric, len(metrics)),
	}

	for i, metric := range metrics {
		payload.Metrics[i] = createProtoMetric(metric, false) // Aliases only in data
	}

	data, err := proto.Marshal(payload)
	if err != nil {
		log.Fatalf("Failed to marshal NDATA: %v", err)
	}
	return data
}

func createNDeath(metrics []Metric) []byte {
	timestamp := uint64(time.Now().UnixMilli())
	seq := uint64(0) // Death messages reset sequence
	payload := &sproto.Payload{
		Timestamp: &timestamp,
		Seq:       &seq,
		Metrics:   make([]*sproto.Payload_Metric, len(metrics)),
	}

	for i, metric := range metrics {
		payload.Metrics[i] = createProtoMetric(metric, true) // Include names in death
	}

	data, err := proto.Marshal(payload)
	if err != nil {
		log.Fatalf("Failed to marshal NDEATH: %v", err)
	}
	return data
}

func createProtoMetric(metric Metric, includeName bool) *sproto.Payload_Metric {
	datatype := uint32(metric.DataType)
	protoMetric := &sproto.Payload_Metric{
		Datatype: &datatype,
	}

	if includeName && metric.Name != "" {
		protoMetric.Name = &metric.Name
	}

	// Always set alias for metrics that have one defined
	protoMetric.Alias = &metric.Alias

	// Set value based on type
	switch v := metric.Value.(type) {
	case bool:
		protoMetric.Value = &sproto.Payload_Metric_BooleanValue{BooleanValue: v}
	case uint64:
		protoMetric.Value = &sproto.Payload_Metric_LongValue{LongValue: v}
	case float64:
		protoMetric.Value = &sproto.Payload_Metric_DoubleValue{DoubleValue: v}
	case string:
		protoMetric.Value = &sproto.Payload_Metric_StringValue{StringValue: v}
	default:
		log.Fatalf("Unsupported metric value type: %T", v)
	}

	return protoMetric
}

func b64(data []byte) string {
	return base64.StdEncoding.EncodeToString(data)
}
